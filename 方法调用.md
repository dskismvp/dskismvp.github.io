# [方法调用](https://delaube1.github.io/#/javase/基础/方法调用?id=方法调用)

------

## [参数传递](https://delaube1.github.io/#/javase/基础/方法调用?id=参数传递)

**值传递**：在 Java 方法中传递参数，形参本质是实参的副本。

1. 参数是基础数据类型：对形参的改变不会影响实参。
2. 参数是指向对象的引用（包括数组、字符串）：对对象数据进行更改会影响实参，但改变引用指向的对象不会影响实参。

```java
public class Test{
    public static void main(){
        int i = 0;
        int[] arr = {0};
        test(i, arr);
        System.out.print(i);            // 输出为 0
        System.out.print(arr[0]);       // 输出为 1
    }

    public void test(int i, int[] arr){
        i++;                            // 实参不改变
        arr[0]++;                       // 实参指向的对象改变
        arr = new int[]{2};             // 实参不改变
        return;
    }
}
```

------

## [Lambda 表达式](https://delaube1.github.io/#/javase/基础/方法调用?id=lambda-表达式)

JDK 1.8 新增。

# [面向对象](https://delaube1.github.io/#/javase/基础/面向对象?id=面向对象)

------

## [什么是面向对象](https://delaube1.github.io/#/javase/基础/面向对象?id=什么是面向对象)

- **面向过程**：根据解决问题的过程，直接设计系统。如 C 语言。
- **面向对象**：将问题分解成多个对象，设计模块化、低耦合的系统。如 java 语言。
  - 特性：封装、继承、多态。
  - 优点：使系统更加灵活，易维护、易复用、易扩展。

------

## [封装](https://delaube1.github.io/#/javase/基础/面向对象?id=封装)

### [普通内部类](https://delaube1.github.io/#/javase/基础/面向对象?id=普通内部类)

定义在类中的类，可以使用外部类所有属性和方法。普通内部类属于具体对象，因此不能声明 static 成员变量和方法。

成员内部类依附外部类而存在。也就是说，如果要创建普通内部类的对象，就必须首先存在外部类的对象。

```java
public class Test {
    public static void main(String[] args)  {
        // 创建内部类
        Outter outter = new Outter();
        Outter.Inner inner = outter.new Inner();  
        inner.output();
    }
}

// 外部类 
class Outter {
    private int num = "10";
    // 内部类  
    class Inner {
        void output(){
            System.out.println(num);
        }
    }
}
```

### [局部内部类](https://delaube1.github.io/#/javase/基础/面向对象?id=局部内部类)

定义在一个方法或者一个作用域里的内部类。对局部内部类的访问仅限于方法内或者该作用域内，且局部内部类不能被访问权限所修饰。

```java
public class Test {
    public static void main(String[] args)  {
        // 创建内部类
        Factory f = new Factory();
        Gun myrifle = f.getRifle();  
    }
}

class Factory {
    // 局部内部类
    public Gun getRifle(){
        class Rifle extends Gun {   
            int len = 60;
        }
        return new Rifle();
    }
}
```

### [匿名内部类](https://delaube1.github.io/#/javase/基础/面向对象?id=匿名内部类)

匿名内部类不用定义名称，但必须继承一个父类或实现一个接口。由于没有类名，匿名内部类不能定义构造器。在创建匿名内部类的时候会立即创建它的实例。因此匿名内部类只能使用一次，通常用来简化代码编写。

最常用的情况就是在多线程的实现上，创建线程类传入参数需要继承 Thread 类或实现 Runnable 接口。

```java
// 父类或接口
interface Person {
    public void eat();
}

public class Demo {
    public static void main(String[] args) {
        Person p = new Person() { 
            // 定义匿名内部类并直接使用
            public void eat() {
                System.out.println("eat apple");
            }
        };
        p.eat();
    }
}
```

*JDK 1.8 中引入了 Lambda 表达式，你甚至连方法名都不需要写。*

```java
public class Demo {
    public static void main(String[] args) {
        Person p = new Person(() -> {
            System.out.println("eat apple");
        });
        p.eat();
    }
}
```

局部内部类和匿名内部类都定义在方法中，如果调用方法中的其他局部变量，只能调用外部类的局部 final 变量。因为在多线程中，外部类方法中定义的变量 A 在方法执行完毕后生命周期就结束了，而此时 Thread 对象的生命周期很可能还没有结束。内部类方法中访问的变量 A 实际上是拷贝。这就必须限定变量为 final，否则改动将导致数据不一致。

```java
public class Test {
    public void test(final int b) {
        final int a = 10;
        new Thread(){
            public void run() {
                System.out.println(a);
                System.out.println(b);
            };
        }.start();
    }
}
```

### [静态内部类](https://delaube1.github.io/#/javase/基础/面向对象?id=静态内部类)

静态内部类是不需要依赖于外部类，可以在不创建外部类对象的情况下创建内部类的对象。静态内部类不能使用外部类的非 static 成员变量或者方法。

```java
public class Test {
    public static void main(String[] args)  {
        // 无需外部对象，直接创建内部类
        Outter.Inner inner = new Outter.Inner();
    }
}

class Outter {
    static class Inner {
        int data = 0;
    }
}
```

------

## [继承](https://delaube1.github.io/#/javase/基础/面向对象?id=继承)

### [类的继承](https://delaube1.github.io/#/javase/基础/面向对象?id=类的继承)

子类继承父类后，无需定义也可使用父类定义好的 public/protected 方法和属性。也可以进行扩展和方法的重写。

- 父类的**属性值**不会被子类继承，但子类可以通过父类提供的方法得到父类的属性值。
- 父类的 **static 方法**不会被子类继承，子类的 static 方法会隐藏父类的同名 static 方法。
- 父类的**构造方法**不会被子类继承，子类必须在构造方法首行调用父类构造方法（先构造父类，再构造子类）

```java
final public class Trunk extends Car{ 
    // 重定义属性（未公开无法继承）
    String brand;
    String description = "this is a trunk";
    // 扩展属性
    int goods;
    // 扩展方法              
    public void load(int num){
        this.goods += num;
    }
    // 子类构造方法
    public Trunk(String brand){    
        super(brand);        
        this.goods = 0;                          
    }
    // 重写方法
    @Override         
    public void go(String loc){
        super.go(loc);                            
        System.out.print(" with" + goods + "goods"); 
        this.goods = 0;
    }
}
```

*Object 类是一切 java 类的父类。对于普通的 java 类,即便不声明也默认继承了 Object 类。*

------

### [接口继承](https://delaube1.github.io/#/javase/基础/面向对象?id=接口继承)

和类的继承类似。但 Java 类只能单继承，而 Java 接口可以多继承。

```java
interface Charge extends Move, Fight{  
    public abstract void kill(int num);
}
```

------

## [多态](https://delaube1.github.io/#/javase/基础/面向对象?id=多态)

### [继承多态](https://delaube1.github.io/#/javase/基础/面向对象?id=继承多态)

- **重载**(overload)：定义多种同名方法，调用时根据传入参数判定调用哪种方法。
- **重写**(override)：子类定义完全相同的方法覆盖父类。

重写是多态的前提，其允许父类引用指向子类对象（引用类型为父类，指向的实际对象类型为子类）。

```
Car mycar = new Trunk("Benz");
```

但不允许子类引用指向父类对象。

~~`Trunk mycar = new Car("Benz");`~~

如果两个类之间存在继承关系，可以进行强制类型转换。强制类型转换只能改变引用类型，实际指向对象类型不会发生变化。

```
Trunk newCar = (Trunk)mycar;
```

### [方法多态](https://delaube1.github.io/#/javase/基础/面向对象?id=方法多态)

- **调用普通方法**

  子类同名方法会覆盖父类。执行方法根据实际对象类型来判定，即执行子类重写的方法。

- **调用 static / private / final 以及构造方法**

  特殊方法不能被覆盖，不存在多态。执行方法会根据引用类型来判定，即执行父类方法。

- **调用成员变量**

  父类属性值不会被子类继承，不存在多态。调用变量会根据引用类型来判定，即得到父类属性值。

```java
Car myCar = new Trunk("Benz");

myCar.go("London");                    // (trunk) go to London with 0 goods
myCar.showNum();                       // (car) 1
System.out.print(myCar.description);   // (car) this is a car

Trunk newCar = (Trunk)mycar;           // 强制类型转换
System.out.print(newCar.description);  // (trunk) this is a trunk
```

### [反射机制](https://delaube1.github.io/#/javase/基础/面向对象?id=反射机制)

JAVA 是动态编译语言（运行时才确定类型），支持反射机制。在运行状态中

- 对于任意一个类，都能够知道这个类的所有属性和方法；
- 对于任意一个对象，都能够调用它的任意一个方法和属性。

通过反射机制能更好地支持多态，降低模块耦合，提高代码灵活度（根据传入类名不同，就能实例化出不同的对象）。

但是在性能上会有较大的损耗。

*尽管在应用层面很少使用反射机制，但在设计基础框架的时候反射机制非常有用。*

#### [反射机制运用](https://delaube1.github.io/#/javase/基础/面向对象?id=反射机制运用)

类的相关信息保存在以下类中，通过特定方法获取其对象能够知道这个类的信息。

- **Class 类**：类
- **Constructor 类**：类的构造方法
- **Field 类**：类的属性
- **Method 类**：类的方法

```java
public class Reflection {
    public static void main(String[] args) {

        /************************** 获取 Class 对象 **************************/

        // 第一种方式 返回对象的类 【已有对象，获取类无意义】
        Student stu = new Student();
        Class stuClass = stu.getClass();

        // 第二种方式 获取数据类型的静态 class 属性 【需要导入类包】
        Class stuClass = Student.class;

        // 第三种方式 返回路径下的类 【常用】
        Class stuClass = Class.forName("Reflection.Student");

        /************************** 获取 Class 信息 **************************/

        // 获取类名
        String name = stuClass.getName());   

        // 获取类的公有构造方法
        Constructor[] conArray = stuClass.getConstructors();
        // 获取类的全部构造方法
        Constructor[] conArray = stuClass.getDeclaredConstructors();
        // 获取类的指定构造方法（参数）
        Constructor con = stuClass.getConstructor(null);
        Constructor con = stuClass.getDeclaredConstructor(char.class);

        // 获取类的公有属性
        Field[] fieldArray = stuClass.getFields(); 
        // 获取类的全部属性
        Field[] fieldArray = stuClass.getDeclaredFields();
        // 获取类的指定属性（属性名）
        Field f = stuClass.getField("name");    

        // 获取类的公有方法
        Method[] methodArray = stuClass.getMethods(); 
        // 获取类的全部方法                
        Method[] methodArray = stuClass.getDeclaredMethods();
        // 获取类的指定方法（方法名+形参类型）                  
        Method m = stuClass.getMethod("main", String.class);   

        /************************** 在对象中使用 **************************/

        Object obj = con.newInstance();   // 调用公有无参构造方法创建对象
        f.set(obj, "X-man");              // 为对象的公有属性赋值
        m.invoke(obj, "X-man");           // 调用对象的公有方法

    }
```

[泛型](https://delaube1.github.io/#/java/数据类型?id=泛型)在编译时检查类型安全，编译过后泛型被擦除、实际类型才确定。反射是在编译期模拟 java 运行时的环境读取和调用程序，因此不能获得泛型的实际类型。但可以通过反射越过泛型检查：

*在 String 泛型的集合中，你甚至可以添加一个 Integer 类型的值。*

```java
public class Demo {
    public static void main(String[] args) throws Exception{
        ArrayList<String> strList = new ArrayList<>();    
        Class listClass = strList.getClass(); 
        Method m = listClass.getMethod("add", Object.class);
        m.invoke(strList, 100);
    }
}
```







- [数据类型](https://delaube1.github.io/#/javase/基础/数据类型?id=数据类型)

- - [基本类型](https://delaube1.github.io/#/javase/基础/数据类型?id=基本类型)

  - - [基本类型](https://delaube1.github.io/#/javase/基础/数据类型?id=基本类型-1)
    - [包装类型](https://delaube1.github.io/#/javase/基础/数据类型?id=包装类型)
    - [类型转换](https://delaube1.github.io/#/javase/基础/数据类型?id=类型转换)

  - [数组](https://delaube1.github.io/#/javase/基础/数据类型?id=数组)

  - - [Array 类](https://delaube1.github.io/#/javase/基础/数据类型?id=array-类)

    - - [创建数组](https://delaube1.github.io/#/javase/基础/数据类型?id=创建数组)

    - [Arrays 类](https://delaube1.github.io/#/javase/基础/数据类型?id=arrays-类)

    - - [数组排序](https://delaube1.github.io/#/javase/基础/数据类型?id=数组排序)
      - [数组复制](https://delaube1.github.io/#/javase/基础/数据类型?id=数组复制)
      - [数组转化](https://delaube1.github.io/#/javase/基础/数据类型?id=数组转化)

  - [字符串](https://delaube1.github.io/#/javase/基础/数据类型?id=字符串)

  - - [String 类](https://delaube1.github.io/#/javase/基础/数据类型?id=string-类)

    - - [创建字符串](https://delaube1.github.io/#/javase/基础/数据类型?id=创建字符串)
      - [常用方法](https://delaube1.github.io/#/javase/基础/数据类型?id=常用方法)
      - [类型转换](https://delaube1.github.io/#/javase/基础/数据类型?id=类型转换-1)

    - [StringBuilder / StringBuffer 类](https://delaube1.github.io/#/javase/基础/数据类型?id=stringbuilder-stringbuffer-类)

    - - [创建字符串](https://delaube1.github.io/#/javase/基础/数据类型?id=创建字符串-1)
      - [专用方法](https://delaube1.github.io/#/javase/基础/数据类型?id=专用方法)

  - [大数](https://delaube1.github.io/#/javase/基础/数据类型?id=大数)

  - - [BigInteger 类](https://delaube1.github.io/#/javase/基础/数据类型?id=biginteger-类)

    - [BigDecimal 类](https://delaube1.github.io/#/javase/基础/数据类型?id=bigdecimal-类)

    - - [BigInteger 和 BigDecimal 类常用方法](https://delaube1.github.io/#/javase/基础/数据类型?id=biginteger-和-bigdecimal-类常用方法)

  - [枚举](https://delaube1.github.io/#/javase/基础/数据类型?id=枚举)

  - - [Enum 类](https://delaube1.github.io/#/javase/基础/数据类型?id=enum-类)

  - [时间](https://delaube1.github.io/#/javase/基础/数据类型?id=时间)

  - - [数字类型](https://delaube1.github.io/#/javase/基础/数据类型?id=数字类型)

  - [泛型](https://delaube1.github.io/#/javase/基础/数据类型?id=泛型)

  - - [泛型定义](https://delaube1.github.io/#/javase/基础/数据类型?id=泛型定义)
    - [泛型使用](https://delaube1.github.io/#/javase/基础/数据类型?id=泛型使用)

# [数据类型](https://delaube1.github.io/#/javase/基础/数据类型?id=数据类型)

------

## [基本类型](https://delaube1.github.io/#/javase/基础/数据类型?id=基本类型)

### [基本类型](https://delaube1.github.io/#/javase/基础/数据类型?id=基本类型-1)

Java 语言提供了八种基本类型，用户无需定义也可以直接使用。其数据保存在相应的方法栈中。

| 基本数据类型 | 字节数 | 默认值 | 包装数据类型 | 备注         |
| ------------ | ------ | ------ | ------------ | ------------ |
| byte         | 1      | 0      | Byte         |              |
| short        | 2      | 0      | Short        |              |
| int          | 4      | 0      | Integer      |              |
| long         | 8      | 0      | Long         |              |
| float        | 4      | 0.0f   | Float        | 数字后加f    |
| double       | 8      | 0.0    | Double       |              |
| char         | 2      | null   | Character    | 必须用单引号 |
| boolean      | 1      | false  | Boolean      |              |

- **布尔型**

boolean 类型只含有两个值：true 和 false。字节存储为 11111111 和 00000000 。

```java
boolean b = true;      
boolean b = false;   
```

- **字符型**

char 类型使用单引号来表示字符。因为 Java 统一采用 unicode 编码，2 字节可以表示一字符。char 类型同样可以用十六进制码保存汉字等特殊字符：'\u0000' - '\uffff'。

```java
char ch = 'a';      
char ch = '中';
char ch = '/u3089';   
```

- **整型和浮点型**

Java 没有无符号类型，所有数据都有符号。

1. 整型(byte/short/int/long) 用来表示整型数据。
2. 浮点型(float/double) 用来表示浮点数据，实际以指数形式存储，所以和实际值之间有偏差。
   - 为 float 类型赋值必须在数字后加 f，否则数字默认被识别为 double 类型，会导致赋值出错。
   - 数字基本类型都包含最大最小值常量，如 `Integer.MAX_VALUE` 和 `Integer.MIN_VALUE` .
   - 在浮点型有三个特殊数值表示溢出和出错：
     - `POSITIVE_INFINITY` ：正无穷大，正数除以 0 可以得到。
     - `NEGATIVE_INFINITY` ：负无穷大，负数除以 0 可以得到。
     - `NaN` ：非数，零除以 0 可以得到。（两个 NAN 值也不相等）

```java
int n = 0;
float f = 0.0f;
long l = Long.MAX_VALUE;               
double d = POSITIVE_INFINITY;
```

### [包装类型](https://delaube1.github.io/#/javase/基础/数据类型?id=包装类型)

均继承自 Number 抽象类，把基本类型数据封装成对象。基本类型和包装类型之间会自动进行转化。

- **基本类型**（如int），是一个值。允许不赋初值，系统自动添加默认值。
- **包装类型**（如Integer），是一个对象。**实例化必须赋初值，且赋值后不能改变(final)。**

包装类型主要用于集合框架中的元素。但阿里巴巴要求所有实体类(POJO) 属性、远程过程调用方法(RPC) 的返回值和参数都必须使用包装数据类型。以此来提醒使用者在需要使用时，必须显式地进行赋值。

### [类型转换](https://delaube1.github.io/#/javase/基础/数据类型?id=类型转换)

![img](https://delaube1.github.io/javase/%E5%9F%BA%E7%A1%80/%E8%BD%AC%E6%8D%A2.png)

对于基础类型：

- 按上图顺序可以自动进行类型转换。但整型转化为浮点型时，如果数据过大可能会导致数据丢失精度。
- 反之则必须进行强制类型转换。但务必小心，超出范围可能会产生意想不到的错误。

```java
int i = 'x';                  // 自动转换
char c = (char)60;            // 强制转换
```

但是包装类型之间的转换，需要使用特殊的方法。

```java
Integer i = l.intValue();
Long l = i.longValue();
```

------

## [数组](https://delaube1.github.io/#/javase/基础/数据类型?id=数组)

### [Array 类](https://delaube1.github.io/#/javase/基础/数据类型?id=array-类)

数据的集合。本质是一个对象，数据存储在堆区，由引用指向数组首个元素的地址。

#### [创建数组](https://delaube1.github.io/#/javase/基础/数据类型?id=创建数组)

创建数组时，必须确定数组长度和类型。但如果储存的是基本类型，允许不赋初值（使用默认值）。

```java
int[] arr = new int[4];                    // 方法一
int[] arr = {1,2,3,4};                     // 方法二
int[] arr = new int[]{1,2,3,4};            // 方法三
```

**数组长度**：在数组对象中，定义了 length 属性记录了数组长度。

```java
int len = arr.length;                      // 返回数组长度  
```

### [Arrays 类](https://delaube1.github.io/#/javase/基础/数据类型?id=arrays-类)

对数组进行操作的辅助类，实现了对数组的常用操作。

#### [数组排序](https://delaube1.github.io/#/javase/基础/数据类型?id=数组排序)

**sort 方法**：可以对数组排序，默认数组数值从小到大排列，用户可以自定义排列顺序，

```java
Arrays.sort(arr);                                     // 数组排序
```

#### [数组复制](https://delaube1.github.io/#/javase/基础/数据类型?id=数组复制)

**copyOf/copyOfRange 方法**：复制数组。底层调用 System.arrayCopy 的本地方法实现，常用于数组扩容。

```java
int[] arr1 = Arrays.copyOf(arr, 10);                  // 复制数组：前 10 个单位
int[] arr2 = Arrays.copyOf(arr, 0, arr.length);       // 复制数组：从 0 到 arr.length - 1
```

#### [数组转化](https://delaube1.github.io/#/javase/基础/数据类型?id=数组转化)

**asList 方法**：将数组转化为列表（List 类），但数组数据必须是包装类型。

调用该方法将数组转换为列表后，在内存中实际还是以数组形式存储。这可能会导致以下两个问题：

1. 调用 List 类的 add 方法向列表中插入数据，会导致异常；
2. 对原数组进行更改，也会导致列表中的数据发生变化。

```java
arr[] = new Integer[]{1, 2, 3, 4};                    // 数组必须是包装数据类型

List list = Arrays.asList(arr);                       // 将数组转换为集合（有问题）               
List list = new ArrayList<>(Arrays.asList(arr));      // 将数组转换为集合（推荐）  
```

------

## [字符串](https://delaube1.github.io/#/javase/基础/数据类型?id=字符串)

### [String 类](https://delaube1.github.io/#/javase/基础/数据类型?id=string-类)

保存字符串。String 类本质是一个 final 对象，由引用指向存储字符串对象的地址。引用虽然可变，但内存数据不能被更改。

#### [创建字符串](https://delaube1.github.io/#/javase/基础/数据类型?id=创建字符串)

String 对象创建后一经赋值不再改变，有以下两种创建方式：

1. 直接赋值：如果常量池没有，则在常量池新建对象。否则直接使用常量池中已有对象，**引用指向常量池。**
2. 构造方法：如果常量池没有，则在常量池新建对象。无论如何一定会在堆区创建对象，**引用指向堆区。**

```java
String str1 = "string";                       // 引用指向常量池
String str2 = "str" + "ing";                  // 引用指向常量池（指向 str1 的字符串对象）

String str3 = new String("string");           // 引用指向堆区（在堆区新建字符串对象）
String str4 = str1 + str2;                    // 引用指向堆区

String newStr = new String(str.getBytes("ISO-8859-1"), "GBK");          // 获取指定类型编码对象，按指定类型编码
```

String 对象创建后一经赋值不再改变。对字符串数据进行改变，实际是创建新的 String 对象，并改变引用指向新的对象。

```java
str1 = "goodbye";                             // str1 指向新的字符串对象
```

#### [常用方法](https://delaube1.github.io/#/javase/基础/数据类型?id=常用方法)

```java
int len = str.length();                   // 返回字符串长度

String[] strs = str.split(",");           // 按分隔符分解字符串

boolean c = str.contains(str2);           // 判断是否存在子字符串
int index = str.indexOf(str2);            // 查找子字符串出现的第一个位置，没有返回-1
int index = str.lastIndexOf(str2);        // 查找子字符串出现的最后一个位置，没有返回-1

String str2 = str.trim();                 // 去除字符串左右空格　　
String str2 = str.substring(0,3);         // 截取指定位置（0-2）的子字符串
String str2 = str.replace("a", "b");      // 新字符 a 替换旧字符 b
```

#### [类型转换](https://delaube1.github.io/#/javase/基础/数据类型?id=类型转换-1)

```java
// Number > String

String s1 = data.toString();              // data 必须为包装数据类型
String s2 = Integer.toString(data);       // data 可以为基础数据类型，包括字符数组 char[]
String s3 = String.valueOf(data);         // data 可以为基础数据类型，包括字符数组 char[]

// String > char

char c = str.charAt(0);
char[] ch = str.toCharArray();

// String > int

int n1 = Integer.parseInt(str);          
int n2 = Integer.valueOf(str);
```

### [StringBuilder / StringBuffer 类](https://delaube1.github.io/#/javase/基础/数据类型?id=stringbuilder-stringbuffer-类)

由于 String 类不可变性，对其频繁更改往往会产生较多临时变量类，占用大量内存。对此我们通常使用 StringBuilder/StringBuffer 来避免，这两个类允许在原有内存地址对字符串进行操作。其中 StringBuilder 类性能更好，StringBuffer 类线程安全。

#### [创建字符串](https://delaube1.github.io/#/javase/基础/数据类型?id=创建字符串-1)

必须通过构造方法创建，不可以直接赋值的形式创建：~~`StringBuffer str = "hello";`~~。

字符串默认长度为16，超出后会进行自动扩容。

```java
StringBuffer str = new StringBuffer("hello");
```

将 StringBuilder / StringBuffer 类转化为 String 类。

```java
String str2 = str.toString();    
```

#### [专用方法](https://delaube1.github.io/#/javase/基础/数据类型?id=专用方法)

StringBuilder / StringBuffer 类可以使用 String 类的全部方法，还新增了以下方法直接对字符串进行修改。

```java
str.append("add");                 // 末尾添加字符串，也可以是其他基础类型
str.insert(0,"insert");            // 指定位置插入字符串，也可以是其他基础类型
str.deleteCharAt(6);               // 删除指定位置（6）的字符
str.delete(6,8);                   // 删除指定位置（6和7）的字符串
str.reverse(str2);                 // 翻转字符串
```

------

## [大数](https://delaube1.github.io/#/javase/基础/数据类型?id=大数)

在 Java 程序中，我们可能会用到一些数值特别巨大、或者小数特别精确的数值，这些数值无法用基础类型表示。因此我们定义了 BigInteger/BigDecimal 类来保存这类数据，实际是以字符串形式在堆区存储。

### [BigInteger 类](https://delaube1.github.io/#/javase/基础/数据类型?id=biginteger-类)

主要用来操作比 long 类型更大的整型数字。

### [BigDecimal 类](https://delaube1.github.io/#/javase/基础/数据类型?id=bigdecimal-类)

基于 BigInteger 类实现。由于基本浮点数类型(float/double) 会产生精度丢失问题，因此常使用 BigDecimal 类代替。涉及金额必须使用该类。

```java
float x = 1.0f;                           // 约等于 0.1
float a = 1.0f - 0.9f;
float b = 0.9f - 0.8f;
System.out.println(a == b);               // false

BigDecimal a = new BigDecimal("1.0");     // 等于 0.1
BigDecimal b = new BigDecimal("0.9");
BigDecimal c = new BigDecimal("0.8");
BigDecimal x = a.subtract(b);
BigDecimal y = b.subtract(c);
System.out.println(x.equals(y));          // true
```

#### [BigInteger 和 BigDecimal 类常用方法](https://delaube1.github.io/#/javase/基础/数据类型?id=biginteger-和-bigdecimal-类常用方法)

```java
BigDecimal x = a.add(b);                  // 加
BigDecimal x = a.subtract(b);             // 减
BigDecimal x = a.multiply(b);             // 乘
BigDecimal x = a.divide(b);               // 除
BigDecimal x = a.abs();                   // 绝对值
a.compareTo(b);                           // 比较大小

// BigDecimal 类专用
BigDecimal x = y.setScale(3, rules);      // 设置精度和保留规则
```

## [枚举](https://delaube1.github.io/#/javase/基础/数据类型?id=枚举)

### [Enum 类](https://delaube1.github.io/#/javase/基础/数据类型?id=enum-类)

（JDK 1.5 新增）比 Class 类多了部分特殊约束的特殊类型，能更加简洁地定义常量。

使代码更具可读性，允许进行编译时检查，预先记录可接受值的列表，并避免由于传入无效值而引起的意外行为。

> 自定义枚举类实际是继承 Enum 类的 final 类，在类中将自定义该类型的 public static final 属性，并引入了相关方法。

```java
// 定义枚举类
public enum Day {
    MONDAY, TUESDAY, WEDNESDAY,
    THURSDAY, FRIDAY, SATURDAY, SUNDAY
}

// 使用枚举类
public class Demo {
    public boolean test(Day today){
        if(today == Day.MONDAY) return true;
        else teturn false;
    }
}
```

我们可以通过在枚举类型中定义属性,方法和构造函数让它变得更加强大。

*实际开发中，枚举类通常的形式是有两个参数（int code，Sring msg）的构造器，可以作为状态码进行返回。*

```java
public enum StatusCodeEnum{

    SUCCESS(200,"成功"), NOTFOUND(404,"未找到"), ERROR(500,"错误");

    private int code;
    private String message;

    // 根据常量自动构造
    private StatusCodeEnum(int code, String message) {
        this.code = code;
        this.message = message;
    }

    public int getCode() {
        return code;
    }

    public String getMessage() {
        return message;
    }

    @Override
    public String toString() {
        return "PinType{" +
                "code=" + code +
                ", message='" + message + '\'' +
                '}';
    }
}
```

根据常量自动构造对象并调用方法

```
System.out.println(StatusCodeEnum.SUCCESS.getCode());
```

------

## [时间](https://delaube1.github.io/#/javase/基础/数据类型?id=时间)

### [数字类型](https://delaube1.github.io/#/javase/基础/数据类型?id=数字类型)

在日常 Java 开发中，我们最常使用 Long 类型，而不是 Date/Timestamp 类型表示时间。

我们可以通过 System.currentTimeMillis 方法获取当前系统时间，默认为 13 位的数字（精确到 ms）。

```java
Long timestamp1 = System.currentTimeMillis();                 // 13 位 精确到 ms
Long timestamp2 = (System.currentTimeMillis()) / 1000;        // 10 位 精确到 s
```

------

## [泛型](https://delaube1.github.io/#/javase/基础/数据类型?id=泛型)

### [泛型定义](https://delaube1.github.io/#/javase/基础/数据类型?id=泛型定义)

定义类时并不固定数据类型，等到创建对象或调用方法时再明确数据类型。

[编译](https://delaube1.github.io/#/javase/JVM/JVM介绍?id=java-运行原理)过程中，由编译器检查类型安全，自动隐性地对类的数据类型进行强制转换（Object -> 指定数据类型）。编译后生成的 字节码文件(.class) 将不再含有泛型。

### [泛型使用](https://delaube1.github.io/#/javase/基础/数据类型?id=泛型使用)

可使用 A-Z 之间的任何一个字母，常用：

- T (type)： 表示具体的一个 java 类型
- K V (key value)： 分别代表 java 键值中的 Key Value
- E (element)： 代表 java 集合框架元素
- ？：表示不确定的 java 类

```java
// 定义时使用泛型
public class Box<T> {
    private T t;
    public void set(T t) {
        this.t = t;
    }
    public T get() {
        return t;
    }
} 

// 调用时明确类型
class Test{
    static void main(String[] args){
        Box<Integer> myBox = new Box<>();
        myBox.set(3);
        System.out.print(myBox.get());
    }
}
```

- [数值比较和排序的常用方法](https://delaube1.github.io/#/javase/基础/数值比较?id=数值比较和排序的常用方法)

- - [等值判断](https://delaube1.github.io/#/javase/基础/数值比较?id=等值判断)

  - - [和 == 的区别](https://delaube1.github.io/#/javase/基础/数值比较?id=和-的区别)
    - [重写 equals 方法](https://delaube1.github.io/#/javase/基础/数值比较?id=重写-equals-方法)

  - [数值比较](https://delaube1.github.io/#/javase/基础/数值比较?id=数值比较)

  - - [compareTo 方法](https://delaube1.github.io/#/javase/基础/数值比较?id=compareto-方法)
    - [compare 方法](https://delaube1.github.io/#/javase/基础/数值比较?id=compare-方法)

  - [数据排序](https://delaube1.github.io/#/javase/基础/数值比较?id=数据排序)

# [数值比较和排序的常用方法](https://delaube1.github.io/#/javase/基础/数值比较?id=数值比较和排序的常用方法)

------

## [等值判断](https://delaube1.github.io/#/javase/基础/数值比较?id=等值判断)

Object 类实现了 equals 方法 ，用于比较两个数据元素是否相等。

浮点类型由于精度丢失问题，进行等值判断常出现错误。如果有需求推荐使用 [BigDecimal 类](https://delaube1.github.io/#/java/数据类型?id=bigdecimal-类)。

```java
int a = 20 - 10;
int b = 10;
System.out.println(a.equals(b));         // true

double a = 20.0 - 10.0;
double b = 10.0;
System.out.println(a.equals(b));         // false
```

### [和 == 的区别](https://delaube1.github.io/#/javase/基础/数值比较?id=和-的区别)

1. 对于基本类型，两者等价：判断数据是否相等。
2. 对于对象（如 String 类）：
   - **==**：比较两个元素内存地址是否相等，即是否是同一个元素。
   - **equals 方法**：比较两个元素内容是否一致。

```java
System.out.println(s1 == s2);                 // 判断两个引用指向的内存地址是否相等  
System.out.println(s1.equals(s2));            // 判断两个引用指向的内存地址是否相等（s1 为空抛出空指针异常）
System.out.println(Objects.equals(s1,s2));    // 判断两个引用指向的元素是否一致（推荐）
```

### [重写 equals 方法](https://delaube1.github.io/#/javase/基础/数值比较?id=重写-equals-方法)

对于用户自定义类，正常使用 equals 方法需要进行重写。**重写 equals 方法必须重写 hashcode 方法**：以保证相同对象拥有相同的哈希地址。这样才能正常地把该类对象放入 HashSet/HashMap 等集合框架中查找。

*Object 类的 hashcode 方法是本地方法（底层用 c/c++ 实现），直接返回对象的内存地址。*

```java
public class User{
    int ID;
    String name;

    ......

    @Override
    public boolean equals(Object obj) {
        if(this == obj)  return true;

        if(obj == null) return false;

        if(obj instanceof User){
            User other = (User) obj;
            if(equals(this.ID, other.ID) && equals(this.name, other.name)){
                return true;
            }
        }

        return false;
    }

    @Override
    public int hashCode() {
        int result = 17;
        result = 31 * result + (ID == null ? 0 : ID.hashCode());
        result = 31 * result + (name == null ? 0 : name.hashCode());
        return result;
    }
}
```

------

## [数值比较](https://delaube1.github.io/#/javase/基础/数值比较?id=数值比较)

Comparator 接口和 Comparable 接口都用于比较两个元素的大小：

1. Comparable 接口位于 java.lang 包内，定义在要比较的实体类内部：包含 compareTo 方法。
2. Comparator 接口位于 java.util 包内，实现在类的外部：包含 compare 方法和 equals 方法。

*Comparator 接口的 equals 方法和 Object 类的 equals 方法不同， Object 类的 equals 方法实现在实体类的内部。*

### [compareTo 方法](https://delaube1.github.io/#/javase/基础/数值比较?id=compareto-方法)

Java 自带数据类型均已实现 Comparable 接口并重写 compareTo 方法，默认情况下

- 如果 s1 等于 s2，则返回 0；
- 如果 s1 小于 s2，则返回小于 0 的值；
- 如果 s1 大于 s2，则返回大于 0 的值。

```java
Integer s1 = 100;
Integer s2 = 90;
System.out.println(s1.compareTo(s2));        
```

### [compare 方法](https://delaube1.github.io/#/javase/基础/数值比较?id=compare-方法)

Arrays/Collections 类定义了 sort 方法对数组或者集合元素进行排列，数值的比较通过调用 Comparator 接口的 compare 方法实现。

执行 sort 方法时如果没有重写 compare 方法，默认调用的 compare 方法将会直接调用数据类型的 compareTo 方法，使数据从小到大排列。如果是自定义数据类型且未实现 compareTo 方法，则必须重写 compare 方法。

```java
Arrays.sort(students);                      // 对数组排序
Collections.sort(students);                 // 对集合元素排序
```

开发者可以通过重写 compare 方法，实现自定义排列顺序。但要注意，如果数组中保存的是基础类型数据则无法自定义排序。

```java
Arrays.sort(students, new Comparator<Student>() {          
    @Override
    public int compare(Student s1, Student s2) {
        return s1.getID() - s2.getID();
    }            
});

Collections.sort(students, (s1, s2) ->  s1.getID() - s2.getID());     // 使用 Lamdba 表达式简写
```

------

## [数据排序](https://delaube1.github.io/#/javase/基础/数值比较?id=数据排序)

Arrays/Collections 类定义了 sort 方法对数组或者集合元素进行排列，数值的比较通过调用 Comparator 接口的 compare 方法实现。

- [异常](https://delaube1.github.io/#/javase/基础/异常处理?id=异常)

- - [异常类型](https://delaube1.github.io/#/javase/基础/异常处理?id=异常类型)

  - - [Throwable 类](https://delaube1.github.io/#/javase/基础/异常处理?id=throwable-类)
    - [RuntimeException 类](https://delaube1.github.io/#/javase/基础/异常处理?id=runtimeexception-类)
    - [Checked Exception 类](https://delaube1.github.io/#/javase/基础/异常处理?id=checked-exception-类)

  - [Exception 类](https://delaube1.github.io/#/javase/基础/异常处理?id=exception-类)

  - - [源码解析](https://delaube1.github.io/#/javase/基础/异常处理?id=源码解析)
    - [自定义异常](https://delaube1.github.io/#/javase/基础/异常处理?id=自定义异常)
    - [异常转译](https://delaube1.github.io/#/javase/基础/异常处理?id=异常转译)

  - [异常处理](https://delaube1.github.io/#/javase/基础/异常处理?id=异常处理)

  - - [抛出异常 throw](https://delaube1.github.io/#/javase/基础/异常处理?id=抛出异常-throw)
    - [捕获异常 catch](https://delaube1.github.io/#/javase/基础/异常处理?id=捕获异常-catch)

# [异常](https://delaube1.github.io/#/javase/基础/异常处理?id=异常)

------

## [异常类型](https://delaube1.github.io/#/javase/基础/异常处理?id=异常类型)

### [Throwable 类](https://delaube1.github.io/#/javase/基础/异常处理?id=throwable-类)

Java 程序中的异常是一个在程序执行期间发生的事件，它中断正在执行程序的正常指令流。为了能够及时有效地处理程序中的运行错误，必须使用异常类。

java 程序中所有的异常都继承自 Throwable 类，Throwable 类有两个子类 Error 类和 Exception 类：

- **Error 类**：【错误】表示 java 程序在运行时产生的无法处理的故障（如堆栈溢出），错误出现时会导致程序无法正常执行并强制退出。
- **Exception 类**：【异常】表示 java 程序中产生的可以被处理的故障，异常出现时可以由程序进行处理。

![Throwable](https://delaube1.github.io/javase/%E5%9F%BA%E7%A1%80/exception.png)

### [RuntimeException 类](https://delaube1.github.io/#/javase/基础/异常处理?id=runtimeexception-类)

【运行时异常】 Exception 类的子类。

表示 java 程序运行状态中发生的异常，在编译时无法被检测。在 java 程序运行时会由系统自动抛出，允许应用程序不进行处理。

| 异常类型                      | 介绍                   |
| ----------------------------- | ---------------------- |
| ArithmeticException           | 算术异常，以零做除数   |
| ArrayIndexOutOfBoundException | 数组越界异常           |
| NullPointerException          | 空指针异常，对象不存在 |

### [Checked Exception 类](https://delaube1.github.io/#/javase/基础/异常处理?id=checked-exception-类)

【可检查异常】Exception 类除 RuntimeException 以外其他子类的统称。

表示 java 程序编译时检测到的异常。出现时必须在程序中进行捕获或抛出，否则编译不会通过。

| 异常类型               | 介绍                           |
| ---------------------- | ------------------------------ |
| IOException            | IO 异常                        |
| FileNotFoundException  | 找不到文件异常，继承自 IO 异常 |
| ClassNotFoundException | 找不到类异常                   |

------

## [Exception 类](https://delaube1.github.io/#/javase/基础/异常处理?id=exception-类)

### [源码解析](https://delaube1.github.io/#/javase/基础/异常处理?id=源码解析)

**状态信息**

Throwable / Exception 类是有状态的（因此 Throwable 是接口而不能是类），记录了四个信息：

```java
private transient Object backtrace;                          // 栈的回溯点
private String detailMessage;                                // 异常的信息：在创建异常时备注
private Throwable cause = this;                              // 异常的原因：导致该异常的异常，默认为自身
private StackTraceElement[] stackTrace = UNASSIGNED_STACK;   // 异常的发生顺序：以栈的形式存储
```

**构造方法**

Throwable / Exception 类含有四个构造方法，在创建时可以记录异常信息：

```java
throw new Exception();                           // 默认
throw new Exception("message");                  // 记录异常信息
throw new Exception(e);                          // 记录异常原因
throw new Exception("message", e);               // 记录详细信息和异常原因
```

**常用方法**

Throwable / Exception 类定义了多种常用方法用于获取异常数据，常用的有：

- getMessage 方法：获取异常的信息。
- getStackTrace 方法：获取的异常发生顺序。
- printStackTrace 方法：获取异常的发生顺序并打印（开发和调试阶段用来显示异常信息，帮助开发者找出错误）。

```java
catch(Exception e){
    System.out.println(e.getMessage());
    e.printStacTrace();                           
}
```

### [自定义异常](https://delaube1.github.io/#/javase/基础/异常处理?id=自定义异常)

我们也可以通过继承并重写 Exception / RuntimeException 类的方式，自定义异常类并使用。

```java
// 自定义异常，重写方法可任选
class MyException extends Exception {
    @Override
    public MyException() {
        super();
    }
    @Override
    public MyException(String message) {
        super(message);
    } 
    @Override
    public MyException(String message, Throwable cause){
        super(message,cause);
    }
    @Override
    public MyException(Throwable cause) {
        super(cause);
    }
}
```

### [异常转译](https://delaube1.github.io/#/javase/基础/异常处理?id=异常转译)

在项目开发过程中，当 Sevice/DAO 层出现如 SQLException 异常时，程序一般不会把底层的异常传到 controller 层。程序可以捕获原始异常，然后再抛出一个新的业务异常。

```java
catch(SQLException e){
    throw new MyException("SQL Error", e);
}
```

------

## [异常处理](https://delaube1.github.io/#/javase/基础/异常处理?id=异常处理)

### [抛出异常 throw](https://delaube1.github.io/#/javase/基础/异常处理?id=抛出异常-throw)

当方法执行出现问题时，方法就会创建异常对象并抛出。开发者可以在程序中自行抛出异常；JVM 在执行程序时发现问题也会自动抛出异常。

- **throw 语句**：开发者自行创建异常对象并抛出，等待程序进行异常处理。
- **throws 语句**：声明方法可能抛出某种异常且未经处理，调用该方法的上级需要进行异常处理。

```java
class TestException{       
    // 把方法中的抛出异常交给上层处理     
    public void writeList(int size) throws IndexOutOfBoundsException, IOException{
        PrintWriter out = null;
        // 用户自定义异常并抛出
        if(size < 1) throw new IndexOutOfBoundsException("至少要输出1个字符");
        try{
            // 虚拟机自动发现异常也会抛出，必须出现在 try 代码块中
            out = new PrintWriter(new FileWriter(txt));
            for (int i = 0; i < size; i++)
                System.out.println("Value at: " + i + " = " + list.get(i));
        }finally{
            if (out != null) out.close();
        }
     }
}
```

### [捕获异常 catch](https://delaube1.github.io/#/javase/基础/异常处理?id=捕获异常-catch)

当方法执行抛出异常时，必须由专门的代码块对异常进行处理。

- **try 语句**：可能出现异常的代码块。
- **catch 语句**：捕获相应异常后停止执行 try 代码，转而执行对应 catch 代码。如果没有异常 catch 代码不会执行。
- **finally 语句**：无论是否发生异常，finally 代码总会被执行。一般用于释放资源。

**注意事项**

1. 如果 try 语句中出现的异常未被 catch，默认将异常 throw 给上层调用者处理。但必须在方法中声明 throws。
2. try/catch 代码中的 return 语句会在执行完 finally 后再返回，但 finally 中对返回变量的改变不会影响最终的返回结果。
3. finally 代码中应避免含有 return 语句或抛出异常，否则只会执行 finally 中的 return 语句，且不会向上级抛出异常。

*Java 7 后在 try 语句中打开 IO 流，会在跳出后自动关闭流。不必再用 finally 语句关闭。*

```java
class TestException{               
    public void writeList(int size) {
        PrintWriter out = null;
        try {
            if(size < 1) throw new IndexOutOfBoundsException("至少要输出1个字符");
            out = new PrintWriter(new FileWriter("OutFile.txt"));
            for (int i = 0; i < size; i++)
                System.out.println("Value at: " + i + " = " + list.get(i));
        } catch (IndexOutOfBoundsException e) {
            System.err.println("Caught IndexOutOfBoundsException: " + e.getMessage());
        } catch (IOException e) {
            System.err.println("Caught IOException: " + e.getMessage());
        } finally {
            if (out != null) out.close();
        }
    }
}
```

- [基础容器](https://delaube1.github.io/#/javase/容器/基础容器?id=基础容器)

- - [基本接口](https://delaube1.github.io/#/javase/容器/基础容器?id=基本接口)

  - - [Collection 接口](https://delaube1.github.io/#/javase/容器/基础容器?id=collection-接口)

    - [List 接口](https://delaube1.github.io/#/javase/容器/基础容器?id=list-接口)

    - [Queue 接口](https://delaube1.github.io/#/javase/容器/基础容器?id=queue-接口)

    - - [Deque 接口](https://delaube1.github.io/#/javase/容器/基础容器?id=deque-接口)

    - [Set 接口](https://delaube1.github.io/#/javase/容器/基础容器?id=set-接口)

    - [Collections 类](https://delaube1.github.io/#/javase/容器/基础容器?id=collections-类)

    - [Map 接口](https://delaube1.github.io/#/javase/容器/基础容器?id=map-接口)

    - - [Map 接口方法](https://delaube1.github.io/#/javase/容器/基础容器?id=map-接口方法)

  - [线性存储](https://delaube1.github.io/#/javase/容器/基础容器?id=线性存储)

  - - [ArrayList 类](https://delaube1.github.io/#/javase/容器/基础容器?id=arraylist-类)
    - [LinkedList 类](https://delaube1.github.io/#/javase/容器/基础容器?id=linkedlist-类)
    - [ArrayDeque 类](https://delaube1.github.io/#/javase/容器/基础容器?id=arraydeque-类)
    - [PriorityQueue 类](https://delaube1.github.io/#/javase/容器/基础容器?id=priorityqueue-类)

  - [哈希存储](https://delaube1.github.io/#/javase/容器/基础容器?id=哈希存储)

  - - [HashMap 类](https://delaube1.github.io/#/javase/容器/基础容器?id=hashmap-类)
    - [LinkedHashMap 类](https://delaube1.github.io/#/javase/容器/基础容器?id=linkedhashmap-类)
    - [TreeMap 类](https://delaube1.github.io/#/javase/容器/基础容器?id=treemap-类)
    - [Set 子类](https://delaube1.github.io/#/javase/容器/基础容器?id=set-子类)

  - [元素遍历](https://delaube1.github.io/#/javase/容器/基础容器?id=元素遍历)

  - - [遍历容器](https://delaube1.github.io/#/javase/容器/基础容器?id=遍历容器)

    - - [Iterable 接口](https://delaube1.github.io/#/javase/容器/基础容器?id=iterable-接口)
      - [Iterator 接口](https://delaube1.github.io/#/javase/容器/基础容器?id=iterator-接口)

    - [遍历顺序](https://delaube1.github.io/#/javase/容器/基础容器?id=遍历顺序)

    - - [List / Queue 接口](https://delaube1.github.io/#/javase/容器/基础容器?id=list-queue-接口)
      - [Map / Set 接口](https://delaube1.github.io/#/javase/容器/基础容器?id=map-set-接口)

    - [遍历方法](https://delaube1.github.io/#/javase/容器/基础容器?id=遍历方法)

    - - [Collection 接口](https://delaube1.github.io/#/javase/容器/基础容器?id=collection-接口-1)
      - [Map 接口](https://delaube1.github.io/#/javase/容器/基础容器?id=map-接口-1)

    - [遍历失败](https://delaube1.github.io/#/javase/容器/基础容器?id=遍历失败)

# [基础容器](https://delaube1.github.io/#/javase/容器/基础容器?id=基础容器)

------

## [基本接口](https://delaube1.github.io/#/javase/容器/基础容器?id=基本接口)

java 提供了一些基础容器类，可以用特定的方式组织、存储和操作对象数据。这些集合框架分为两大分支：Collection 接口和 Map 接口。

所有容器都定义在 java.util 文件夹内，使用时需要进行导入。

### [Collection 接口](https://delaube1.github.io/#/javase/容器/基础容器?id=collection-接口)

【集合】用特定的方式组织、存储和操作对象数据。有三个常用子接口 List 接口、Queue 接口、Set 接口。

Collection 接口以及所有子接口和子方法 都定义在 java.util 文件夹内，使用时需进行导入。

```java
// 修改
collection.add(1);                // 添加元素
collection.remove(1);             // 删除元素
collection.clear();               // 清除所有元素

// 查询
collection.isEmpty();             // 判断集合是否为空
collection.size();                // 返回集合元素个数
collection.contains(1):           // 判断集合中是否含有元素

// 多集合操作
collection.addAll(c2);            // 并操作，添加其他集合中元素
collection.removeAll(c2);         // 减操作，删除和其他集合共有元素
collection.retainAll(c2);         // 交操作，只保留和其他集合共有元素 
collection.equals(c2);            // 判断是否和其他集合元素相同
collection.containsAll(c2);       // 判断是否包含其它集合所有元素  

// 创建迭代器
Iterator<Integer> iter = collection.iterator();
```

### [List 接口](https://delaube1.github.io/#/javase/容器/基础容器?id=list-接口)

【列表】元素有序，可以按索引操作。

```java
// 修改
list.add("data1");              // 末尾添加元素
list.add(0, "data0");           // 插入元素
list.remove(0);                 // 按索引删除元素(int)
list.remove("data");            // 按内容删除对象元素(Object)
list.remove(new Integer(3));    // 按内容删除基础类型元素
list.clear();                   // 清除所有元素
list.set(0, "data2");           // 修改元素

// 查找
list.isEmpty();                 // 判定是否为空
list.size();                    // 查询列表元素个数
list.contains("data3");         // 判定是否含有元素
list.get(1);                    // 按索引查找元素
list.indexOf("data1");          // 查询索引号：如果有返回第一个，没有返回-1
list.lastIndexOf("data1");      // 查询索引号：如果有返回最后一个，没有返回-1

// 转化
list.toString();                // 转化为字符串
list.toArray();                 // 转化为 Object[] 数组
(String [])list.toArray();      // 转化为对象数组，但不能是基础类型
```

### [Queue 接口](https://delaube1.github.io/#/javase/容器/基础容器?id=queue-接口)

【队列】元素有序，在队列尾插入/在队列首移除。常用 Deque 子接口。

```java
//修改
queue.offer(10);                // 队列尾插入元素，队列满返回 false
queue.peek();                   // 获取队列首元素，队列空返回 null
queue.poll();                   // 获取并移除队列首元素，队列空返回 null
queue.clear();                  // 清空元素

/* offer/peek/poll 方法可以用 add/get/remove 方法代替，但队列空/满时会抛出异常。 */

// 查找
queue.isEmpty();                 // 判定是否为空
queue.size();                    // 查询列表元素个数
queue.contains("data3");         // 判定是否含有元素
```

#### [Deque 接口](https://delaube1.github.io/#/javase/容器/基础容器?id=deque-接口)

【双端队列】元素可以在两端进出。

```java
deque.offerFirst(e);            // 队列首添加元素 
deque.pollFirst();              // 队列首移除元素
deque.peekFirst();              // 获取队列首元素

deque.offerLast(e);                // 队列尾添加元素
deque.pollLast();               // 队列尾移除元素
deque.peekLast();               // 获取队列尾元素 

/* offer/peek/poll 方法可以用 add/get/remove 方法代替，但队列空/满时会抛出异常。 */
```

### [Set 接口](https://delaube1.github.io/#/javase/容器/基础容器?id=set-接口)

【集】数据不可重复。

```java
// 修改
set.add("data");              // 添加元素
set.remove("data");           // 删除元素
set.clear();                  // 清除所有元素

// 查询
set.get(1);                   // 按序号查找元素（仅限于有序的 set 接口）
set.isEmpty();                // 判断是否为空
set.size();                   // 返回元素个数
set.contains("data");         // 判定是否含有元素
```

*HashSet 类无序，因此不支持 get 方法：获取对象必须要通过 Iterator 来遍历。*

### [Collections 类](https://delaube1.github.io/#/javase/容器/基础容器?id=collections-类)

Collections 类是针对集合类的一个帮助类，他提供一系列静态方法实现各种集合操作。

1. 排序操作（主要针对List接口）

```java
Collections.swap(list, 1, 2);          // 元素交换顺序
Collections.shuffle(list);             // 元素随机排序
Collections.reverse(list);             // 元素颠倒排序
Collections.sort(list);                // 元素按大小排序，可以自定义比较顺序
Collections.rotate(list, 2);           // 元素右移指定长度
```

1. 查找和替换

```java
Collections.binarySearch(list, "data");              // 二分查找元素索引，只适用于有序集合
Collections.max(list);                               // 返回最大元素，可以自定义比较顺序
Collections.min(list);                               // 返回最小元素，可以自定义比较顺序
Collections.frequency(list, "data");                 // 返回对象出现次数

Collections.fill(list, "data");                      // 使用指定元素填充
Collections.replaceAll(list, "old", "new");          // 使用指定元素替换
```

1. 上锁（主要针对List接口）

调用 Collections 类中的 synchronizedList 方法，可以将 List 接口转换成线程安全的容器使用。

List 接口中的方法都会被添加 synchronized 锁（效率不高）。但是 iterator 方法没有加锁，如果要遍历还需要在外层加锁。

```java
List list = Collections.synchronizedList(new ArrayList());

synchronized (list) {
    Iterator i = list.iterator(); 
    while (i.hasNext())
        foo(i.next());
}
```

### [Map 接口](https://delaube1.github.io/#/javase/容器/基础容器?id=map-接口)

【图】组织存储 key-value 的数据元素组合：内部实际存储的是 `Map.Entry<K, V>` 静态内部类。

Entry 类可以通过 getKey、getValue、setKey、setValue 方法调整数据。

#### [Map 接口方法](https://delaube1.github.io/#/javase/容器/基础容器?id=map-接口方法)

```java
map.put("key_1",1);               // 添加键值对,已有 key 则覆盖 value
map.putIfAbsent("key_2",2);       // 添加键值对,已有 key 则不操作

map.remove("key_1");              // 删除键值对（按值）           
map.remove("key_2",2);            // 删除键值对（按键值）

map.get("key_1");                 // 获取值, key 不存在返回null
map.getOrDefault("key_2",-1);     // 获取值, key 不存在返回默认值

map.containsKey("key_1");       // 判断 key 是否存在  
map.containsValue(1);             // 判断 value 是否存在      
```

------

## [线性存储](https://delaube1.github.io/#/javase/容器/基础容器?id=线性存储)

### [ArrayList 类](https://delaube1.github.io/#/javase/容器/基础容器?id=arraylist-类)

【数组序列】实现了 List 接口，内部使用 Object 数组存储：

1. 可以高效地按索引进行元素修改和查询。
2. 添加元素时动态扩容：当容量满后，ArrayList 类会新建一个 1.5 倍容量的新数组，然后将当前数组数据全部复制过去。

**ArrayList 构造方法**

```java
List<Integer> list = new ArrayList<>();              // 默认初始容量为 10
List<Integer> list = new ArrayList<>(100);           // 自定义初始容量
List<Integer> list = new ArrayList<>(queue);         // 构造时直接复制其他容器元素（可以是任何 Collection 类）

List list = new ArrayList();                         // 未指定元素类型则为 Object 类
```

### [LinkedList 类](https://delaube1.github.io/#/javase/容器/基础容器?id=linkedlist-类)

【链表序列】实现了 List 和 Deque 接口。内部使用双向链表存储：

1. 可以高效地进行元素插入和删除。
2. 容量无限。

**LinkedList 构造方法**

```java
List<String> list = new LinkedList<>();              // 创建空对象
List<String> list = new LinkedList<>(queue);         // 复制其他容器元素
```

### [ArrayDeque 类](https://delaube1.github.io/#/javase/容器/基础容器?id=arraydeque-类)

【数组双端队列】实现了 Deque 接口。内部使用 Object 数组存储（不允许存储 null 值）：

1. 可以高效进行元素查找和尾部插入取出，是用作队列、双端队列、栈甚至递归树的绝佳选择。
2. 添加元素时动态扩容：当容量满后，ArrayDeque 类会新建一个 1.5 倍容量的新数组，然后将当前数组数据全部复制过去。

**ArrayDeque 构造方法**

```java
ArrayDeque<String> queue = new ArrayDeque<>();              // 创建空对象
ArrayDeque<String> queue = new ArrayDeque<>(list);          // 复制其他容器元素
```

### [PriorityQueue 类](https://delaube1.github.io/#/javase/容器/基础容器?id=priorityqueue-类)

【无界优先级队列】实现了 Queue 接口。内部使用 Object 数组存储（不允许存储 null 值）：

1. **PriorityQueue 类内会自动对元素进行排序**，是作为堆的绝佳选择。但实际在数组中并不是有序存储，而只保证队首元素是最小值：每次弹出队首元素后会自动查找剩余队列中的最小元素放到队首。
2. 添加元素时动态扩容：当容量满后，PriorityQueue 类会新建一个 1.5 倍容量的新数组，然后将当前数组数据全部复制过去。

**PriorityQueue 构造方法**

开发者在构造队列时可通过重写 compare 方法自定义排序规则。如果存储未重写 compareTo 方法的自定义对象，则必须重写 compare 方法。

```java
// 默认排序方法
PriorityQueue<Integer> queue = new PriorityQueue<Integer>();

// 自定义排序方法(Lambda 表达式)
PriorityQueue<Student> queue = new PriorityQueue<Student>((s1, s2) -> {
    if(s1.getScore() == s2.getScore()){
        return s1.getName().compareTo(s2.getName());
    }
    return s1.getScore() - s2.getScore();
});
```

------

## [哈希存储](https://delaube1.github.io/#/javase/容器/基础容器?id=哈希存储)

### [HashMap 类](https://delaube1.github.io/#/javase/容器/基础容器?id=hashmap-类)

【哈希表】 实现 Map 接口。底层使用散列存储：构造一个 Entry 数组，根据 key 的 hash 值将 Entry 存入指定位置。

- key 值无序且不可重复，且允许 null 作为 key 值存在。
- 发生哈希冲突时，HashMap 采用链表保存多个元素。当链表长度大于 8 时，链表自动转化为红黑树。
- 达到负载因数后，HashMap 将调用 resize 方法动态扩容：新建一个 2 倍容量的新数组复制当前数组的数据。

**HashMap 构造方法**

```java
Map<String,Integer> map = new HashMap<>();                       // 默认初始容量 16 负载因数 0.75
Map<String,Integer> map = new HashMap<>(32);                     // 自定义初始容量
Map<String,Integer> map = new HashMap<>(32, 0.5f);               // 自定义初始容量和负载因数
```

### [LinkedHashMap 类](https://delaube1.github.io/#/javase/容器/基础容器?id=linkedhashmap-类)

【链式哈希表】继承 HashMap 类。

1. 底层使用散列存储：构造一个 Entry 数组，根据 key 的 hash 值将 Entry 存入指定位置。
2. Entry 额外添加了引用 before & after ，使哈希表内的所有 Entry 构成一个双向链表维护 Entry 的顺序。

**LinkedHashMap 构造方法**

在默认情况下 Entry 按照插入顺序排序，可指定创建时的初始容量和负载因数。

```java
Map<String,Integer> map = new LinkedHashMap<>();                  // 默认初始容量 16 负载因数 0.75 
Map<String,Integer> map = new LinkedHashMap<>(32);                // 自定义初始容量
Map<String,Integer> map = new LinkedHashMap<>(32, 0.5f);          // 自定义初始容量和负载因数
```

Entry 也可以按照访问顺序排序：对 Entry 进行操作时会先删除再插入，将 Entry 移动到双向链表的表尾。

```java
Map<String,Integer> map = new LinkedHashMap<>(32，0.5f, true);    // 基于访问顺序排序
```

LinkedHashMap 类提供了 removeEldestEntry 方法，在使用 put 操作插入 Entry 时将自动调用此方法决定是否移除双向链表表头的 Entry：默认返回 false ，可通过重写此方法以实现 LRU 算法。

```java
// Entry 超过容量后自动删除最久未使用的 Entry
Map<String,Integer> map = new LinkedHashMap<>(capacity, 0.5f, true){
    @Override
    protected boolean removeEldestEntry(Map.Entry eldest) {  
        return size() > capacity;  
    }  
};
```

### [TreeMap 类](https://delaube1.github.io/#/javase/容器/基础容器?id=treemap-类)

【树表】 实现了 Map 接口。底层使用红黑树存储：Entry 按照 key 值大小插入红黑树，并动态调整红黑树高度。

**TreeMap 类方法**

TreeMap 类提供了以下专属方法使用。

```java
map.firstKey();                   // 返回最小 key
map.lastKey();                    // 返回最大 key

map.ceilingKey("10");             // 返回大于等于10的最小 Key，不存在则返回 null
map.ceilingEntry("10");           // 返回大于等于10的最小 Key 的键值对(getKey / getValue 方法)

map.floorKey("10");               // 返回小于等于10的最大 Key，不存在则返回 null
map.floorEntry("10");             // 返回小于等于10的最大 Key 的键值对
```

### [Set 子类](https://delaube1.github.io/#/javase/容器/基础容器?id=set-子类)

- **HashSet 类**：【散列集】基于 HashMap 类实现。
- **LinkedHashSet 类**：【链式散列集】基于 LinkedHashMap 类实现。
- **TreeSet 类**：【树集】基于 TreeMap 类实现。

------

## [元素遍历](https://delaube1.github.io/#/javase/容器/基础容器?id=元素遍历)

### [遍历容器](https://delaube1.github.io/#/javase/容器/基础容器?id=遍历容器)

#### [Iterable 接口](https://delaube1.github.io/#/javase/容器/基础容器?id=iterable-接口)

是集合框架的顶级接口，被所有容器类都实现。

1. 提供 iterator 方法，用来创建一个实现了 Iterator 接口的 iterator 对象：按容器类规定的顺序实现遍历集合。
2. JDK 1.8 引入 foreach 方法遍历集合。效率更高，但不能对元素进行删除操作，否则会抛出异常。

#### [Iterator 接口](https://delaube1.github.io/#/javase/容器/基础容器?id=iterator-接口)

提供了 hasNext、next、remove 三个方法，可以按容器类规定的顺序实现遍历集合。

### [遍历顺序](https://delaube1.github.io/#/javase/容器/基础容器?id=遍历顺序)

#### [List / Queue 接口](https://delaube1.github.io/#/javase/容器/基础容器?id=list-queue-接口)

- **全部方法**：按数组或链表顺序输出。

#### [Map / Set 接口](https://delaube1.github.io/#/javase/容器/基础容器?id=map-set-接口)

- **HashSet/HashMap 类**：在返回数据时没有特别的顺序。
- **LinkedHashSet/LinkedHashMap 类**：默认按插入顺序返回数据，也可以按访问顺序返回。
- **TreeSet/TreeMap 类**：在返回数据时按 key 值从小到大排列，即按照树的中序遍历返回。

### [遍历方法](https://delaube1.github.io/#/javase/容器/基础容器?id=遍历方法)

#### [Collection 接口](https://delaube1.github.io/#/javase/容器/基础容器?id=collection-接口-1)

```java
List<String> list = new ArrayList<>();

// iterator 遍历
Iterator<Integer> iter = list.iterator();
while(iter.hasNext()){              
      int num = iter.next();
      if(num < 0) iter.remove();
}

// 随机遍历（效率更高，但不能进行删除操作）
for (String str : list) {
      System.out.println(str);
}
```

#### [Map 接口](https://delaube1.github.io/#/javase/容器/基础容器?id=map-接口-1)

```java
Map<String,String> map=new HashMap<String,String>();

// iterator 遍历
Iterator<Map.Entry<String, String>> iter = map.entrySet().iterator(); 
while (iter.hasNext()) { 
    Map.Entry<String, String> entry = iter.next(); 
    System.out.println(entry.getKey() + entry.getValue()); 
} 

// 随机遍历（效率更高，但不能进行删除操作）
for (Map.Entry<String, String> entry : map.entrySet()) { 
    System.out.println(entry.getKey() + entry.getValue()); 
} 

// 只遍历 key
for (String key : map.keySet()) { 
    System.out.println(key + map.get(key)); 
} 

// 只遍历 value
for (String value : map.values()) { 
    System.out.println(value); 
}
```

### [遍历失败](https://delaube1.github.io/#/javase/容器/基础容器?id=遍历失败)

在迭代元素的时候不能通过集合的方法修改或删除元素，但可以通过迭代器的 remove 方法删除元素。

- java.util 包下面的所有的集合类都是快速失败的。直接对原容器进行修改，会抛出 ConcurrentModificationException 异常。
- java.util.concurrent 包下面的所有的集合类都是安全失败的。遍历时先对底层集合做拷贝再遍历，因此不会抛出异常。

- [并发容器](https://delaube1.github.io/#/javase/容器/并发容器?id=并发容器)

- - [并发原理](https://delaube1.github.io/#/javase/容器/并发容器?id=并发原理)

  - [List 接口](https://delaube1.github.io/#/javase/容器/并发容器?id=list-接口)

  - - [~~Vector 类（已过时）~~](https://delaube1.github.io/#/javase/容器/并发容器?id=vector-类（已过时）)
    - [CopyOnWriteArrayList 类](https://delaube1.github.io/#/javase/容器/并发容器?id=copyonwritearraylist-类)
    - [ConcurrentLinkedQueue 类](https://delaube1.github.io/#/javase/容器/并发容器?id=concurrentlinkedqueue-类)

  - [BlockingQueue 接口](https://delaube1.github.io/#/javase/容器/并发容器?id=blockingqueue-接口)

  - - [ArrayBlockingQueue 类](https://delaube1.github.io/#/javase/容器/并发容器?id=arrayblockingqueue-类)
    - [LinkedBlockingQueue 类](https://delaube1.github.io/#/javase/容器/并发容器?id=linkedblockingqueue-类)
    - [PriorityBlockingQueue 类](https://delaube1.github.io/#/javase/容器/并发容器?id=priorityblockingqueue-类)

  - [Map 接口](https://delaube1.github.io/#/javase/容器/并发容器?id=map-接口)

  - - [~~HashTable 类（已过时）~~](https://delaube1.github.io/#/javase/容器/并发容器?id=hashtable-类（已过时）)
    - [ConcurrentHashMap 类](https://delaube1.github.io/#/javase/容器/并发容器?id=concurrenthashmap-类)

  - [普通容器转换](https://delaube1.github.io/#/javase/容器/并发容器?id=普通容器转换)

  - - [synchronizedList 方法](https://delaube1.github.io/#/javase/容器/并发容器?id=synchronizedlist-方法)

# [并发容器](https://delaube1.github.io/#/javase/容器/并发容器?id=并发容器)

------

## [并发原理](https://delaube1.github.io/#/javase/容器/并发容器?id=并发原理)

Java 提供的基础容器都是线程不安全的，如果并发条件下多个线程同时对一个容器中的数据进行操作，可能会导致各种意想不到的错误。

因此 Java 又提供了一些并发容器在多线程情况下使用，这些并发容器都位于 java.util.concurrent 包内，使用时需要进行导入。

------

## [List 接口](https://delaube1.github.io/#/javase/容器/并发容器?id=list-接口)

### [~~Vector 类（已过时）~~](https://delaube1.github.io/#/javase/容器/并发容器?id=vector-类（已过时）)

【数组序列】和 ArrayList 类类似，实现了 List 接口。内部使用 Object 数组存储。

Vector 类内部所有方法都是同步(synchronized) 的，因此线程安全。但高并发场景下非常容易阻塞，性能很差。

### [CopyOnWriteArrayList 类](https://delaube1.github.io/#/javase/容器/并发容器?id=copyonwritearraylist-类)

【数组序列】和 ArrayList 类类似，实现了 List 接口。内部使用 Object 数组存储。

CopyOnWriteArrayList 对读取操作不上锁，对写入操作上锁。写入操作通过创建数组的副本来实现，修改的内容写入副本后再替换原来的数据。

不允许同时写，但读操作和写操作不冲突，在多读的场合性能非常好。

### [ConcurrentLinkedQueue 类](https://delaube1.github.io/#/javase/容器/并发容器?id=concurrentlinkedqueue-类)

【链表序列】和 LinkedList 类类似，实现了 List 以及 Deque 接口。内部使用双向链表存储。

ConcurrentLinkedQueue 类非阻塞，通过 CAS 算法实现线程安全，尝试更新数据时会对数据进行比对。高并发场景下如果加锁的代价很高，可以达到很好的性能。

------

## [BlockingQueue 接口](https://delaube1.github.io/#/javase/容器/并发容器?id=blockingqueue-接口)

【阻塞队列】被广泛使用在“生产者-消费者”问题中，其原因是 BlockingQueue 提供了可阻塞的插入和移除的方法。当队列容器已满，生产者线程会被阻塞，直到队列未满；当队列容器为空时，消费者线程会被阻塞，直至队列非空时为止。

### [ArrayBlockingQueue 类](https://delaube1.github.io/#/javase/容器/并发容器?id=arrayblockingqueue-类)

有界队列实现类，底层采用数组来实现。ArrayBlockingQueue 一旦创建，容量不能改变。其并发控制采用可重入锁来控制，不管是插入操作还是读取操作，都需要获取到锁才能进行操作。

### [LinkedBlockingQueue 类](https://delaube1.github.io/#/javase/容器/并发容器?id=linkedblockingqueue-类)

### [PriorityBlockingQueue 类](https://delaube1.github.io/#/javase/容器/并发容器?id=priorityblockingqueue-类)

------

## [Map 接口](https://delaube1.github.io/#/javase/容器/并发容器?id=map-接口)

### [~~HashTable 类（已过时）~~](https://delaube1.github.io/#/javase/容器/并发容器?id=hashtable-类（已过时）)

【哈希表】和 HashMap 类类似，实现了 Map 接口。

HashTable 类内部所有方法都是同步(synchronized) 的，因此线程安全。但由于整个哈希存储区域共享一把锁，高并发场景下非常容易阻塞，性能很差。

### [ConcurrentHashMap 类](https://delaube1.github.io/#/javase/容器/并发容器?id=concurrenthashmap-类)

【哈希表】和 HashMap 类类似，实现了 Map 接口。

并发控制使用 synchronized 和 CAS 来操作，采取分段锁机制。synchronized 对哈希存储区域的每个 key 分别上锁，只锁定当前链表或红黑二叉树的首节点，这样只要不发生哈希冲突就不会产生并发，效率大大提升。

JDK 1.7 中， ConcurrentHashMap 类中包含静态内部类 Segment，继承于 ReentrantLock 类用来充当锁的角色，每个 Segment 对象守护若干个保存键值对的链表，共同构成 ConcurrentHashMap 实例中的数组。在 HashEntry 类中，key，hash 和 next 域都被声明为 final 型，value 域被声明为 volatile 型。由于 HashEntry 的 next 域为 final 型，所以新节点只能在链表的表头处插入。

JDK 1.8 中放弃了 Segment 臃肿的设计，取而代之的是采用Node + CAS + Synchronized来保证并发安全进行实现。

```java
static final class HashEntry<K,V> {
       final K key;                       // 声明 key 为 final 型
       final int hash;                   // 声明 hash 值为 final 型
       volatile V value;                 // 声明 value 为 volatile 型
       final HashEntry<K,V> next;      // 声明 next 为 final 型

       HashEntry(K key, int hash, HashEntry<K,V> next, V value) {
           this.key = key;
           this.hash = hash;
           this.next = next;
           this.value = value;
       }
}
```

------

## [普通容器转换](https://delaube1.github.io/#/javase/容器/并发容器?id=普通容器转换)

### [synchronizedList 方法](https://delaube1.github.io/#/javase/容器/并发容器?id=synchronizedlist-方法)

如果遇到多个线程操作同一个容器的场景，可以通过 Collections 工具类中的 synchronizedList 方法将其转换成线程安全的容器。

方法会被 synchronized 关键字重定义

- [流 Stream](https://delaube1.github.io/#/javase/容器/stream?id=流-stream)

- - [基础概念](https://delaube1.github.io/#/javase/容器/stream?id=基础概念)

  - - [流](https://delaube1.github.io/#/javase/容器/stream?id=流)
    - [Java Stream 类](https://delaube1.github.io/#/javase/容器/stream?id=java-stream-类)
    - [流操作](https://delaube1.github.io/#/javase/容器/stream?id=流操作)

  - [中间操作](https://delaube1.github.io/#/javase/容器/stream?id=中间操作)

  - - [映射 map](https://delaube1.github.io/#/javase/容器/stream?id=映射-map)
    - [过滤 filter](https://delaube1.github.io/#/javase/容器/stream?id=过滤-filter)
    - [筛选 limit/skip](https://delaube1.github.io/#/javase/容器/stream?id=筛选-limitskip)
    - [排序 sorted](https://delaube1.github.io/#/javase/容器/stream?id=排序-sorted)
    - [去重 distinct](https://delaube1.github.io/#/javase/容器/stream?id=去重-distinct)

  - [结束操作](https://delaube1.github.io/#/javase/容器/stream?id=结束操作)

  - - [迭代 forEach](https://delaube1.github.io/#/javase/容器/stream?id=迭代-foreach)
    - [聚合 Collectors](https://delaube1.github.io/#/javase/容器/stream?id=聚合-collectors)
    - [统计 SummaryStatistics](https://delaube1.github.io/#/javase/容器/stream?id=统计-summarystatistics)

# [流 Stream](https://delaube1.github.io/#/javase/容器/stream?id=流-stream)

------

## [基础概念](https://delaube1.github.io/#/javase/容器/stream?id=基础概念)

### [流](https://delaube1.github.io/#/javase/容器/stream?id=流)

流处理是对运动中的数据的处理，在生成或接收数据时直接计算数据。应用程序中分析和查询不断存在，数据不断地流经它们。在从流中接收到事件时，流处理应用程序对该事件作出反应。

如果我们使用传统的循环迭代方式对数据集进行复杂计算，常常会带来两个弊端：

1. 迭代次数多，迭代次数跟函数调用的次数相等。
2. 频繁产生中间结果，存储开销无法接受。

流处理可以立即对事件做出反应，且可以处理比其他数据处理系统大得多的数据量：直接处理事件流，并且只保留数据中有意义的子集。尤其是面对持续生成，本质上是无穷尽的数据集。

### [Java Stream 类](https://delaube1.github.io/#/javase/容器/stream?id=java-stream-类)

JDK 1.8 新增。将要处理的元素集合看作一种流，在管道的节点上进行处理。使代码更简洁易读。

集合接口有两个方法来生成流，数据类型将由 Collection 转化为 Stream 。

- `stream` 方法：为集合创建串行流。
- `parallelStream` 方法：为集合创建并行流。

1. Stream 的遍历方式和结果与 Iterator 无差别（便于转化），其优势在于其原型链的设计使得它可以对遍历处理后的数据进行再处理。
2. parallelStream 提供了流的并行处理，底层使用 Fork/Join 框架，简单理解就是多线程异步任务的一种实现。处理过程中会有多个线程处理元素，具体由 JDK 负责管理。不保证有序性。
3. 串行流和并行流之间可以通过 `parallel` 和 `sequential` 方法相互转化。

```java
Stream<Integer> stream = list.stream();                     // 声明作为流处理
ParellerStream<Integer> pStream = stream.parallel();        // 转化为并行流
```

### [流操作](https://delaube1.github.io/#/javase/容器/stream?id=流操作)

流处理的每个操作阶段都会封装到一个 Sink 接口里，处理数据后再将数据传递给下游的 Sink。

Stream 上的所有操作分为两类：中间操作和结束操作。Stream 是延迟执行的，只有调用到结束操作，才触发整个流水线的执行。如果未定义结束操作，那么流处理什么也不会做。

```java
// 获取空字符串的数量
int count = strings.parallelStream()                       // 声明作为流处理
                   .filter(string -> string.isEmpty())     // 中间操作，过滤空元素
                   .count();                               // 结束操作，计数
```

------

## [中间操作](https://delaube1.github.io/#/javase/容器/stream?id=中间操作)

### [映射 map](https://delaube1.github.io/#/javase/容器/stream?id=映射-map)

`map` 方法用于映射每个元素到对应的结果，其实就是对结果进行转化。

```java
// 获取对应的平方数
List<Integer> numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5);
List<Integer> squaresList = numbers.stream().map( i -> i*i).distinct().collect(Collectors.toList());
```

### [过滤 filter](https://delaube1.github.io/#/javase/容器/stream?id=过滤-filter)

`filter` 方法用于通过设置的条件过滤出元素。

```java
List<String>strings = Arrays.asList("abc", "", "bc", "efg", "abcd","", "jkl");
// 获取空字符串的数量
long count = strings.stream().filter(string -> string.isEmpty()).count();
```

### [筛选 limit/skip](https://delaube1.github.io/#/javase/容器/stream?id=筛选-limitskip)

`limit` 方法用于获取指定数量的流(前 n 个)， `skip` 方法用于去除指定数量的流(前 n 个)。

```java
// 筛选出 11-20 条数据
Random random = new Random();
random.ints().limit(20).skip(10).forEach(System.out::println);
```

### [排序 sorted](https://delaube1.github.io/#/javase/容器/stream?id=排序-sorted)

`sorted` 方法通过 Comparable 接口对流进行排序，也可以自定义。

```java
Random random = new Random();
random.ints().limit(10).sorted().forEach(System.out::println);
```

### [去重 distinct](https://delaube1.github.io/#/javase/容器/stream?id=去重-distinct)

`distinct` 方法通过流元素的 hashCode 和 equals 方法去除重复元素。

```java
Random random = new Random();
random.ints().distinct().forEach(System.out::println);
```

------

## [结束操作](https://delaube1.github.io/#/javase/容器/stream?id=结束操作)

### [迭代 forEach](https://delaube1.github.io/#/javase/容器/stream?id=迭代-foreach)

结束操作： `forEach` 迭代流中的每个数据，即对每个数据进行最后的处理（比如保存到数据库中或打印）。

```java
// 输出 10 个随机数 
Random random = new Random();
random.ints().limit(10).forEach(System.out::println);
```

> 不要用 forEach 方法收集元素！stream 并行执行会损害正确性和效率，使用下方操作。

### [聚合 Collectors](https://delaube1.github.io/#/javase/容器/stream?id=聚合-collectors)

结束操作：`Collectors` 类实现了归约操作，例如将流转换成集合和聚合元素，可用于返回列表或字符串。

```java
// Stream 转化为 List
List<String>strings = Arrays.asList("abc", "", "bc", "efg", "abcd","", "jkl");
List<String> filtered = strings.stream()
                               .filter(string -> !string.isEmpty())
                               .collect(Collectors.toList()); 
System.out.println("筛选列表: " + filtered);

// Stream 转化为 String
String mergedString = strings.stream()
                             .filter(string -> !string.isEmpty())
                             .collect(Collectors.joining(", "));
System.out.println("合并字符串: " + mergedString);
```

### [统计 SummaryStatistics](https://delaube1.github.io/#/javase/容器/stream?id=统计-summarystatistics)

结束操作：收集最终产生的统计结果，它们主要用于 int、double、long 等基本类型上。

```java
List<Integer> numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5);

IntSummaryStatistics stats = numbers.stream()
                                    .mapToInt((x) -> x)
                                    .summaryStatistics();

System.out.println("列表中最大的数 : " + stats.getMax());
System.out.println("列表中最小的数 : " + stats.getMin());
System.out.println("所有数之和 : " + stats.getSum());
System.out.println("平均数 : " + stats.getAverage());
```

- [线程](https://delaube1.github.io/#/javase/并发/线程?id=线程)

- - [线程的基本概念](https://delaube1.github.io/#/javase/并发/线程?id=线程的基本概念)

  - - [并行和并发](https://delaube1.github.io/#/javase/并发/线程?id=并行和并发)

    - [进程和线程](https://delaube1.github.io/#/javase/并发/线程?id=进程和线程)

    - - [进程 Processor](https://delaube1.github.io/#/javase/并发/线程?id=进程-processor)
      - [线程 Thread](https://delaube1.github.io/#/javase/并发/线程?id=线程-thread)

    - [线程的运行状态](https://delaube1.github.io/#/javase/并发/线程?id=线程的运行状态)

    - - [运行](https://delaube1.github.io/#/javase/并发/线程?id=运行)
      - [就绪](https://delaube1.github.io/#/javase/并发/线程?id=就绪)
      - [阻塞](https://delaube1.github.io/#/javase/并发/线程?id=阻塞)
      - [等待](https://delaube1.github.io/#/javase/并发/线程?id=等待)

  - [Thread 类](https://delaube1.github.io/#/javase/并发/线程?id=thread-类)

  - - [线程定义](https://delaube1.github.io/#/javase/并发/线程?id=线程定义)

    - [线程启动](https://delaube1.github.io/#/javase/并发/线程?id=线程启动)

    - - [同时定义和启动线程](https://delaube1.github.io/#/javase/并发/线程?id=同时定义和启动线程)

    - [线程弹出执行](https://delaube1.github.io/#/javase/并发/线程?id=线程弹出执行)

    - [线程暂停执行](https://delaube1.github.io/#/javase/并发/线程?id=线程暂停执行)

    - [线程交互](https://delaube1.github.io/#/javase/并发/线程?id=线程交互)

    - - [线程等待](https://delaube1.github.io/#/javase/并发/线程?id=线程等待)
      - [线程唤醒](https://delaube1.github.io/#/javase/并发/线程?id=线程唤醒)

    - [其他线程优先](https://delaube1.github.io/#/javase/并发/线程?id=其他线程优先)

    - [线程中断](https://delaube1.github.io/#/javase/并发/线程?id=线程中断)

    - - [捕获异常](https://delaube1.github.io/#/javase/并发/线程?id=捕获异常)

# [线程](https://delaube1.github.io/#/javase/并发/线程?id=线程)

------

## [线程的基本概念](https://delaube1.github.io/#/javase/并发/线程?id=线程的基本概念)

### [并行和并发](https://delaube1.github.io/#/javase/并发/线程?id=并行和并发)

- **并行**：多个CPU核心同时工作，处理不同的任务。
- **并发**：多个任务交替使用 CPU 核心工作，以提高 CPU 利用率。

### [进程和线程](https://delaube1.github.io/#/javase/并发/线程?id=进程和线程)

#### [进程 Processor](https://delaube1.github.io/#/javase/并发/线程?id=进程-processor)

程序的一次执行。由操作系统创建并分配资源，执行一个单独的任务。

进程是系统进行资源分配和调度的独立单位，每个进程都有自己的内存空间和系统资源。进程内所有线程共享堆存储空间，保存程序中定义的对象和常量池。

*Windows系统中，每个运行的 Java 程序都是一个独立的进程。*

#### [线程 Thread](https://delaube1.github.io/#/javase/并发/线程?id=线程-thread)

进程内的执行单元，不分配单独的资源，执行一个单独的子任务。

线程是进程内调度和分派的基本单位，共享进程资源。每个线程有自己的独立的栈存储空间，保存线程执行的方法以及基本类型的数据。

*运行的 Java 程序内含至少一个主线程 main ，用户可以在 Java 程序中自定义并调用多个线程。 JVM 垃圾回收线程也是一个独立的线程。*

------

### [线程的运行状态](https://delaube1.github.io/#/javase/并发/线程?id=线程的运行状态)

线程除创建状态 New 和结束状态 Terminate 外，主要有以下几种运行状态：

#### [运行](https://delaube1.github.io/#/javase/并发/线程?id=运行)

(Running) CPU 正在执行线程。

#### [就绪](https://delaube1.github.io/#/javase/并发/线程?id=就绪)

(Runnable) 线程一切就绪，等待 CPU 执行。

*运行/就绪状态 统称为可运行状态 Runnable。 Java 程序中，线程在 运行/就绪状态 之间的切换由 JVM 自动调度，开发者无法获知。线程之间的调度采用分优先级多队列时间片轮转算法。进程在执行完 CPU 时间片切换到就绪状态之前会先保存自己的状态，下次进入运行状态时再重新加载。*

#### [阻塞](https://delaube1.github.io/#/javase/并发/线程?id=阻塞)

(Blocked) 线程因缺少其他资源，比如请求资源被上锁而暂停执行。在获得资源后进入就绪状态。

#### [等待](https://delaube1.github.io/#/javase/并发/线程?id=等待)

(Waitting) 线程接受了等待指令，释放资源暂停执行。在超时/接受唤醒指令后进入就绪状态。

------

## [Thread 类](https://delaube1.github.io/#/javase/并发/线程?id=thread-类)

Thread 类是系统自带的线程类，实现了 Runnable 接口。

### [线程定义](https://delaube1.github.io/#/javase/并发/线程?id=线程定义)

Runnable 接口内唯一声明了 run 方法，由 Thread 类实现。开发者在 run 方法中定义运行时线程将要执行的功能，线程开启后由 JVM 自动调用并执行。如果开发者主动调用 run 方法，只会当作普通方法执行。

开发者可以通过以下两种方式自定义线程类：

1. 继承 Thread 类，重写 run 方法。

```java
public class MyThread extends Thread {
   @Override
   public void run() {
       System.out.println(Thread.currentThread().getName());
   }
}
```

1. 实现 Runnable 接口，实现 run 方法。推荐使用，避免了单继承的局限性。

```java
public class MyThread implements Runnable {
    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName());
    }
}
```

### [线程启动](https://delaube1.github.io/#/javase/并发/线程?id=线程启动)

Thread 类定义了 start 方法。调用 start 方法后，系统会开启一个新线程进入就绪状态：由 JVM 会自动对线程进行调度，在运行时调用并执行线程的 run 方法。一个线程只能启动一次。

1. 如果自定义线程类继承 Thread 类，直接启动。

```java
public class Main {
   public static void main(String[] args) {
       MyThread t1 = new MyThread();
       MyThread t2 = new MyThread("ThreadName");
       t1.start();
       t2.start();
   }
}
```

1. 如果自定义线程类实现 Runnable 接口，则需要借助 Thread 类启动线程。

```java
public class Main {
   public static void main(String[] args) {
       MyThread mythread = new MyThread();
       Thread t1 = new Thread(mythread);                   // 由系统指定默认线程名 Thread-X
       Thread t2 = new Thread(mythread, "ThreadName");     // 开发者自定义线程名 
       t1.start();
       t2.start();
   }
}
```

#### [同时定义和启动线程](https://delaube1.github.io/#/javase/并发/线程?id=同时定义和启动线程)

通过匿名内部类方式，我们可以实现同时定义和启动线程的简洁写法。

```java
public class Main {
    public static void main(String[] args) {
        Thread thread = new Thread(new Runnable(){
            public void run(){
                System.out.println(Thread.currentThread().getName());
            }
        }).start();
    }
}

// Lambda 表达式简写一

public class Main {
    public static void main(String[] args) {
        Thread thread = new Thread(() -> {
            System.out.println(Thread.currentThread().getName());
        }).start();
    }
}

// Lambda 表达式简写二

public class Main {
   public static void main(String[] args) {
       Test test = new test();
       Thread t = new Thread(test::method);         
       t.start();
   }
}

class Test {
   public void method() {
       System.out.println(Thread.currentThread().getName());
   }
}
```

### [线程弹出执行](https://delaube1.github.io/#/javase/并发/线程?id=线程弹出执行)

Thread 类定义了 yield 方法。当前线程执行到 `Thread.yield()` 方法，会停止运行进入就绪状态。但线程切换到就绪状态后，什么时候被 JVM 调度回运行状态开发者无法控制。

```java
public class ThreadDemo {
    public static void main(String[] args) {
       MyThread mythread = new MyThread();
       Thread t1 = new Thread(mythread);              
       Thread t2 = new Thread(mythread);    
       t1.start();
       t2.start();
    }

    static class MyThread implements Runnable {
        @Override
        public void run() {
            int count = 0;
            for (int i = 0; i < 10000; i++) {
                Thread.yield();                    // 切换到就绪状态
                count++;
                System.out.println(count);
            }         
        }
    }
}
```

### [线程暂停执行](https://delaube1.github.io/#/javase/并发/线程?id=线程暂停执行)

Thread 类定义了 sleep 方法。当前线程执行到 `Thread.sleep(1000)` 方法，会停止运行进入阻塞状态，但仍会保持对象锁，其他线程不可访问其资源。直到超时后进入就绪状态。调用 sleep 方法需要捕获或抛出 InterruptException 异常。

```java
public class ThreadDemo {
    public static void main(String[] args) {
       MyThread mythread = new MyThread();
       Thread t1 = new Thread(mythread);              
       Thread t2 = new Thread(mythread);    
       t1.start();
       t2.start();
    }

    static class MyThread implements Runnable {
        @Override
        public void run() {
            int count = 0;
            for (int i = 0; i < 10000; i++) {
                try{
                    Thread.sleep(1000);             // 当前线程暂停 1s
                } catch(InterruptException e){
                    e.printStackTrace();
                }

                count++;
                System.out.println(count);
            }         
        }
    }

}
```

### [线程交互](https://delaube1.github.io/#/javase/并发/线程?id=线程交互)

Object 类定义了 wait 和 notify 方法，通常被用于线程间交互/通信。必须在同步环境下(synchronized)使用，否则会抛出 IllegalMonitorStateException 异常。假定 obj 为同步环境上锁的对象：

#### [线程等待](https://delaube1.github.io/#/javase/并发/线程?id=线程等待)

当前线程执行 `obj.wait()` 方法，线程会停止运行并释放对象锁 obj，其他线程可以访问其资源。同时线程进入 obj 对象的等待池，直到被 notify 方法唤醒进入就绪状态。调用 wait 方法需要捕获或抛出 InterruptException 异常。

wait 方法允许计时等待。当前线程执行 `obj.wait(1000)` 方法，计时结束后线程会被自动唤醒进入就绪状态。

#### [线程唤醒](https://delaube1.github.io/#/javase/并发/线程?id=线程唤醒)

当前线程执行 `obj.notify()` 方法，会随机从 obj 对象等待池中选择一个线程唤醒，使其进入就绪状态。但是 notify 方法不会释放当前进程的对象锁，如果该线程持有 obj 对象的锁，当前线程释放锁后被唤醒的其他线程才能被执行。如果想被唤醒线程先执行，notify 方法后添加 wait 方法释放锁。

当前线程执行 `obj.notifyall()` 方法，会将所有 obj 对象等待池中所有线程唤醒。

```java
public class ThreadDemo {
    public static void main(String[] args) {
        MyThread t = new MyThread("t");
        synchronized(t) {                         // 对 t 设置对象锁
            try {
                t.start();
                System.out.println("1");
                t.wait();                         // 当前线程释放 t 锁，进入 t 对象等待池
                System.out.println("4");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    static class MyThread extends Thread {
        @Override
        public void run() {
            synchronized (this) {                 // 对 t 设置对象锁        
                Thread.sleep(1000);
                System.out.println("2");
                this.notify();                    // 随机唤醒一个 t 对象等待池中的线程
                System.out.println("3");
            }
        }
    }
}
```

### [其他线程优先](https://delaube1.github.io/#/javase/并发/线程?id=其他线程优先)

Thread 类定义了 join 方法，其底层通过调用 wait 方法实现。当前线程执行 `t.join()` 方法，线程会停止运行并释放对象锁，同时线程进入线程 t 对象的等待池，直到被唤醒进入就绪状态。通常用于主线程 main，等到线程 t 终止时自动被唤醒。调用 join 方法需要捕获或抛出 InterruptException 异常。

同样允许计时等待。当前线程执行 `t.join(1000)` 方法，计时结束后线程会被自动唤醒进入就绪状态，无须等待子线程结束时唤醒。

```java
public class ThreadDemo {
    public static void main(String[] args) {
       MyThread mythread = new MyThread();
       Thread t = new Thread(mythread);              
       t.start();
       System.out.println("1");
       t.join();                              // 子线程结束后才被唤醒
       System.out.println("3");
    }

    static class MyThread implements Runnable {
        @Override
        public void run() {
            Thread.sleep(1000);    
            System.out.println("2");
        }         
    }

}
public class ThreadDemo {
    public static void main(String[] args) {
       MyThread mythread = new MyThread();
       Thread t = new Thread(mythread);              
       t.start();
       System.out.println("1");
       t.join(500);                           // 0.5s 后自动被唤醒
       System.out.println("2");
    }

    static class MyThread implements Runnable {
        @Override
        public void run() {
            Thread.sleep(1000);    
            System.out.println("3");
        }         
    }
}
```

如果我们手动给线程 t 加锁，即使计时结束后线程被唤醒进入就绪状态，但仍无法立刻拿到锁进入运行状态。

```java
public class ThreadDemo {
    public static void main(String[] args) {
       MyThread mythread = new MyThread();
       Thread t = new Thread(mythread);              
       t.start();
       System.out.println("1");
       t.join(500);                           // 自动被唤醒后仍要等待线程 t 释放锁
       System.out.println("3");
    }

    static class MyThread implements Runnable {
        @Override
        public void run() {
            synchronized (currentThread()) {
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {}   
                System.out.println("2");
            }
        }         
    }
}
```

### [线程中断](https://delaube1.github.io/#/javase/并发/线程?id=线程中断)

调用 `t.stop()` 方法可以强制终止线程 t 运行，但强制中断线程可能会造成意想不到的问题，已不推荐使用。

目前主要采用设置线程中断标志的方式，向线程发送中止信号。由线程自行终止运行：

- 执行 `t.interrupt()` 方法，将线程 t 中断标志设为 true 。
- 执行 `t.isInterrupted()` 方法，查看线程 t 中断标志。
- 执行 `t.interrupted()` 方法，查看线程 t 中断标志然后将其设为 false 。

```java
public class ThreadDemo {
    public static void main(String[] args) {
       MyThread mythread = new MyThread();
       Thread t = new Thread(mythread);              
       t.start();
       try {
            Thread.sleep(500);
        } catch (InterruptedException e) {}
       t.interrupt();                            // 设置中断标志为 true
    }

    static class MyThread implements Runnable {
        @Override
        public void run() {
            while (true) {
                System.out.print("hello");
                if(this.isInterrupted()){        // 查看中断标志，若为 true 结束循环
                    break;
                }
            }
        }        
    }

}
```

#### [捕获异常](https://delaube1.github.io/#/javase/并发/线程?id=捕获异常)

调用 `t.interrupt()` 方法时如果线程 t 处在阻塞/等待状态，会立即退出阻塞/等待状态，并抛出 InterruptedException 异常。因此在调用 sleep/wait/join 方法时需要捕获 InterruptedException 异常。

开发者经常用 `t.interrupt()` 方法使线程退出阻塞/等待状态，同时也可以在捕获异常时使线程立即终止。

```java
public class ThreadDemo {
    public static void main(String[] args) {
        MyThread mythread = new MyThread();
        Thread t = new Thread(mythread);
        t.start();
        System.out.println("1");
        t.interrupt();                               // 设置中断标志，使线程 t 退出等待状态
        try {
            Thread.sleep(500);
        } catch (InterruptedException e) {}
        System.out.println("3");
    }

    static class MyThread implements Runnable {
        @Override
        public void run() {
            try {
                Thread.sleep(100000);
            } catch (InterruptedException e) {      // 被设置中断标志后会自动抛出异常
                System.out.println("2");
                return;                             // 捕获异常后终止线程
            }
        }
    }
}
```

- [线程安全](https://delaube1.github.io/#/javase/并发/线程安全入门?id=线程安全)

- - [Java 内存模型](https://delaube1.github.io/#/javase/并发/线程安全入门?id=java-内存模型)

  - - [多线程风险](https://delaube1.github.io/#/javase/并发/线程安全入门?id=多线程风险)

    - [行为规范](https://delaube1.github.io/#/javase/并发/线程安全入门?id=行为规范)

    - - [原子性](https://delaube1.github.io/#/javase/并发/线程安全入门?id=原子性)
      - [可见性](https://delaube1.github.io/#/javase/并发/线程安全入门?id=可见性)
      - [有序性](https://delaube1.github.io/#/javase/并发/线程安全入门?id=有序性)

  - [线程锁](https://delaube1.github.io/#/javase/并发/线程安全入门?id=线程锁)

  - - [互斥锁和自旋锁](https://delaube1.github.io/#/javase/并发/线程安全入门?id=互斥锁和自旋锁)
    - [悲观锁和乐观锁](https://delaube1.github.io/#/javase/并发/线程安全入门?id=悲观锁和乐观锁)
    - [公平锁和非公平锁](https://delaube1.github.io/#/javase/并发/线程安全入门?id=公平锁和非公平锁)
    - [可重入锁](https://delaube1.github.io/#/javase/并发/线程安全入门?id=可重入锁)

  - [底层实现](https://delaube1.github.io/#/javase/并发/线程安全入门?id=底层实现)

  - - [volatile 关键字](https://delaube1.github.io/#/javase/并发/线程安全入门?id=volatile-关键字)

    - [synchronized 关键字](https://delaube1.github.io/#/javase/并发/线程安全入门?id=synchronized-关键字)

    - - [同步对象](https://delaube1.github.io/#/javase/并发/线程安全入门?id=同步对象)
      - [同步方法](https://delaube1.github.io/#/javase/并发/线程安全入门?id=同步方法)
      - [同步代码块](https://delaube1.github.io/#/javase/并发/线程安全入门?id=同步代码块)

    - [两者的区别](https://delaube1.github.io/#/javase/并发/线程安全入门?id=两者的区别)

  - [ReentrantLock 锁](https://delaube1.github.io/#/javase/并发/线程安全入门?id=reentrantlock-锁)

  - - [实现等待中断](https://delaube1.github.io/#/javase/并发/线程安全入门?id=实现等待中断)
    - [实现公平锁](https://delaube1.github.io/#/javase/并发/线程安全入门?id=实现公平锁)
    - [选择性通知](https://delaube1.github.io/#/javase/并发/线程安全入门?id=选择性通知)

  - [Atomic 原子类](https://delaube1.github.io/#/javase/并发/线程安全入门?id=atomic-原子类)

  - [ThreadLocal 线程本地对象](https://delaube1.github.io/#/javase/并发/线程安全入门?id=threadlocal-线程本地对象)

# [线程安全](https://delaube1.github.io/#/javase/并发/线程安全入门?id=线程安全)

------

## [Java 内存模型](https://delaube1.github.io/#/javase/并发/线程安全入门?id=java-内存模型)

### [多线程风险](https://delaube1.github.io/#/javase/并发/线程安全入门?id=多线程风险)

在 Java 程序中，存储数据的内存空间分为共享内存和本地内存。线程在读写主存的共享变量时，会先将该变量拷贝一份副本到自己的本地内存，然后在自己的本地内存中对该变量进行操作，完成操作之后再将结果同步至主内存。

| 类型     | 存储介质                                     | 数据                       | 特征                     |
| -------- | -------------------------------------------- | -------------------------- | ------------------------ |
| 共享内存 | 主内存                                       | 存放变量                   | 多线程共享               |
| 本地内存 | CPU 高速缓存、缓冲区、寄存器以及其它硬件优化 | 临时存放线程使用的变量副本 | 使用期间其它线程无法访问 |

- 优势：由于 CPU 执行速度明先快于内存读写速度，将运算需要的数据拷贝到 CPU 高速缓存中运算，可以大大加快程序运行速度。
- 劣势：主内存数据和本地内存的不同步，导致多个线程同时操作主内存里的同一个变量时，变量数据可能会遭到破坏。

```java
public class ThreadDemo {
    public static void main(String[] args) {
        MyThread t = new MyThread();
        Thread t1 = new Thread(t);
        Thread t2 = new Thread(t);
        t1.start();
        t2.start();
    }
}

class MyThread implements Runnable {
    private int x = 0;                            // 对象中的数据由线程共享
    @Override
    public void run() {
        for (int i = 0; i < 10000; i++) {
            x++;
        }
        System.out.println("final x: " + x);     // 最后输出的数据不一定为 20000
    }
}
```

### [行为规范](https://delaube1.github.io/#/javase/并发/线程安全入门?id=行为规范)

JMM 定义了共享内存系统中多线程程序读写操作行为的规范，用来保证共享内存的原子性、可见性、有序性。

![JMM](https://delaube1.github.io/javase/%E5%B9%B6%E5%8F%91/img/JMM.jpg)

#### [原子性](https://delaube1.github.io/#/javase/并发/线程安全入门?id=原子性)

**原子性是指一个操作，要么全部执行并且执行过程不会被打断，要么就都不执行。**

- Java 语言本身只保证了基本类型变量的读取和赋值是原子性操作。
- 简单操作的原子性可以通过 Atomic 原子类实现。
- 通过 synchronized 和 ReenTrantLock 等锁结构可以保证更大范围的原子性。

#### [可见性](https://delaube1.github.io/#/javase/并发/线程安全入门?id=可见性)

**可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。**

- Java 语言会尽可能保证主内存数据和本地内存同步，但仍可能出现不可见问题。
- 通常用 volatile 关键字来保证可见性。
- 通过 synchronized 和 ReenTrantLock 等锁结构在释放锁之前会将对变量的修改刷新到主存当中，也能够保证可见性。

#### [有序性](https://delaube1.github.io/#/javase/并发/线程安全入门?id=有序性)

**有序性是指程序执行的顺序按照代码的先后顺序执行。**

- Java 内存模型具备先天的有序性。但 Java 允许编译器和处理器对指令进行重排序，可能影响多线程并发执行时的有序性。
- 通过 synchronized 和 ReenTrantLock 等锁结构可以保证有序性。
- volatile 关键字可以禁止 JVM 的指令重排，也可以保证有序性。

## [线程锁](https://delaube1.github.io/#/javase/并发/线程安全入门?id=线程锁)

### [互斥锁和自旋锁](https://delaube1.github.io/#/javase/并发/线程安全入门?id=互斥锁和自旋锁)

- **互斥锁**

阻塞锁。当线程需要获取的锁已经被其他线程占用时，该线程会被直接挂起。直到其他线程释放锁，由操作系统激活线程。

适用于锁使用者保持锁时间比较长的情况，线程挂起后不再消耗 CPU 资源。

- **自旋锁**

非阻塞锁。当线程需要获取的锁已经被其他线程占用时，该线程会不断地消耗 CPU 的时间去试图获取锁。

适用于锁使用者保持锁时间比较短的情况，没有用户态和内核态调度、上下文切换的开销和损耗。

### [悲观锁和乐观锁](https://delaube1.github.io/#/javase/并发/线程安全入门?id=悲观锁和乐观锁)

- **悲观锁**

每次读写资源时都会给资源上锁，其他线程想获取该资源时会被阻塞，直到其释放锁。

适用于写频繁的应用场景，写资源请求不会被一直驳回。synchronized 和 ReentrantLock 等独占锁都是悲观锁。

- **乐观锁**

读资源时不会给资源上锁，多个线程可以同时读取资源。写资源时会比对数据检查其他线程有没有更新过该资源，如果未更新就写入资源并更新版本号，否则写资源请求被驳回，重新读取并写资源。

适用于读频繁的应用场景，多线程同时读取能有效提高吞吐量。CAS 算法和版本号机制都是乐观锁，悲观锁的抢占也会利用 CAS 算法。

### [公平锁和非公平锁](https://delaube1.github.io/#/javase/并发/线程安全入门?id=公平锁和非公平锁)

- **公平锁**

加入到队列中等待唤醒，先到者先拿到锁。

公平锁不会出现线程饥饿，迟迟无法获取锁的情况。ReentrantLock 可以实现公平锁。

- **非公平锁**

当线程要获取锁时通过两次 CAS 操作去抢锁，如果没抢到加入到队列中等待唤醒。

非公平锁的性能更好。synchronized 是非公平锁，ReentrantLock 默认情况下也是非公平锁。

### [可重入锁](https://delaube1.github.io/#/javase/并发/线程安全入门?id=可重入锁)

允许一个线程对同一对象多次上锁。由 JVM 记录对象被线程加锁次数，只有当线程释放掉所有锁（加锁次数为0）时，其他线程才获准进入。

synchronized 和 ReentrantLock 等锁结构都是可重入锁。

------

## [底层实现](https://delaube1.github.io/#/javase/并发/线程安全入门?id=底层实现)

### [volatile 关键字](https://delaube1.github.io/#/javase/并发/线程安全入门?id=volatile-关键字)

**修饰成员变量，每次被线程访问时，强迫从主存中读写该成员变量的值。**

volatile 关键字只能保证可见性，不能保证原子性。多个线程同时操作主内存里的同一个变量时，变量数据仍有可能会遭到破坏。

- 线程执行过程中如果 CPU 一直满载运转，就会默认使用本地内存中的值，而没有空闲读取主存同步数据。
- 线程执行过程中一旦 CPU 获得空闲，JVM 也会自动同步主存数据，尽可能保证可见性。

```java
public class ThreadDemo {
    public static void main(String[] args) throws InterruptedException {
        MyThread t = new MyThread();
        t.start();
        try { 
            Thread.sleep(1000); 
        } catch(InterruptedException e) {}
        t.setRun(false);      
    }
}

class MyThread extends Thread {
    // 添加 volatile 关键字，强制同步主存数据。
    // 删除 volatile 关键字，子线程将始终读取本地内存中 true 副本：陷入死循环。
    private volatile boolean run = true;             
    public void setRun(boolean run) { this.run = run; }
    @Override
    public void run() {
        while (this.run == true) {
            int a = 2;
            int b = 3;
            int c = a + b;
            // System.out.print("CPU rest");      打印输出时 CPU 获得空闲，自动同步主存数据。
        }
        System.out.print("end");   
        return;
    }
}
```

### [synchronized 关键字](https://delaube1.github.io/#/javase/并发/线程安全入门?id=synchronized-关键字)

**修饰方法或代码块。被线程访问时由线程抢占锁，直到执行完毕后自动释放锁。其他线程没有获得锁将无法访问上锁内容。保证了指定内容在同一时刻只有一个线程能访问。**

1. 修饰 static 方法实质是给当前类上锁：这个类的所有 synchronized static 方法共享一个锁。
2. 修饰实例方法实质是给对象上锁：这个对象内所有的 synchronized 实例方法共享一个锁。

每一个对象都有且仅有一个与之对应的 monitor 对象。synchronized 关键字修饰方法时会对方法添加标志位，当线程执行到某个方法时，JVM会去检查该方法的访问标志是否被设置，如果设置了线程会先获取这个对象所对应的 monitor 对象，再执行方法体，方法执行完后释放 monitor 。

同步代码块则是在同步代码块前插入 monitorenter ，在同步代码块结束后插入 monitorexit 。

```java
public class ThreadDemo {
    public static void main(String[] args) {
        ThreadDemo test = new ThreadDemo();
        new Thread(test::m1).start();
        new Thread(test::m2).start();   
    }

    public synchronized void m1() {
        System.out.println("1");
        try { 
            Thread.sleep(1000); 
        } catch(InterruptedException e) {}
        System.out.println("2");
    }

    public synchronized void m2() {
        System.out.println("3");
        try { 
            Thread.sleep(500); 
        } catch(InterruptedException e) {}
        System.out.println("4");
    }
}
```

#### [同步对象](https://delaube1.github.io/#/javase/并发/线程安全入门?id=同步对象)

创建两个不同的对象就拥有两把不同的锁，不同对象的 synchronized 实例方法互不影响。

```java
public class ThreadDemo {
    public static void main(String[] args) {
        ThreadDemo test1 = new ThreadDemo();
        ThreadDemo test2 = new ThreadDemo();
        new Thread(test1::m1).start();
        new Thread(test2::m2).start(); 
    }

    public synchronized void m1() {
        System.out.println("1");
        try { Thread.sleep(1500); } catch(InterruptedException e) {}
        System.out.println("4");
    }

    public synchronized void m2() {
        try { Thread.sleep(500); } catch(InterruptedException e) {}
        System.out.println("2");
        try { Thread.sleep(500); } catch(InterruptedException e) {}
        System.out.println("3");
    }
}
```

#### [同步方法](https://delaube1.github.io/#/javase/并发/线程安全入门?id=同步方法)

其他线程无法获取该对象锁，就不能访问该对象的所有 synchronized 实例方法，但仍可以访问其他方法。 synchronized 实例方法中调取的数据仍可能被其他方法修改。

*在实际开发过程中，我们常常对写操作加锁，但对读操作不加锁，提升系统的并发性能。但可能会导致脏读问题。*

```java
public class ThreadDemo {
    public static void main(String[] args) {
        ThreadDemo test = new ThreadDemo();
        new Thread(test::m1).start();
        new Thread(test::m2).start(); 
    }

    boolean data = false;

    public synchronized void m1() {
        System.out.println(data);            // false
        try { 
            Thread.sleep(1000); 
        } catch(InterruptedException e) {}
        System.out.println(data);             // true
    }

    public void m2() throws {
        try { 
            Thread.sleep(500); 
        } catch(InterruptedException e) {}
        this.data = true;
    }
}
```

#### [同步代码块](https://delaube1.github.io/#/javase/并发/线程安全入门?id=同步代码块)

如果我们需要同步的代码只有一小部分，就没有必要对整个方法进行同步操作，我们只需要同步的代码块进行包裹。

修饰代码块，需要指定被上锁的对象或者类。每次线程进入 synchronized 代码块时就会要求当前线程持有该对象锁，如果当前有其他线程正持有该对象锁，那么新到的线程就必须等待，这样也就保证了每次只有一个线程执行操作。我们通常使用 this 对象或者当前类的 class 对象作为锁。

*不要以字符串对象作为锁的对象。字符串常量在常量池里被锁定，可能会导致意想不到的阻塞。*

```java
public class ThreadDemo {
    public static void main(String[] args) {
        ThreadDemo test = new ThreadDemo();
        new Thread(test::m1).start();
        new Thread(test::m2).start();   
    }

    public void m1() {
        synchronized(this) {
            System.out.println("1");
            try { 
                Thread.sleep(1000); 
            } catch(InterruptedException e) {}
            System.out.println("2");
        }  
    }

    public synchronized void m2() {
        synchronized(this) {
            System.out.println("3");
            try { 
                Thread.sleep(500); 
            } catch(InterruptedException e) {}
            System.out.println("4");
        }
    }
}
```

线程执行代码出现异常时也会自动释放所有锁，因此在 synchronized 内部处理异常一定要非常小心。如果不想释放锁，使用 try-catch 语句捕获异常。

### [两者的区别](https://delaube1.github.io/#/javase/并发/线程安全入门?id=两者的区别)

1. volatile 关键字用于修饰变量，synchronized 关键字用于修饰方法以及代码块。
2. volatile 关键字是数据同步的轻量级实现，性能比 synchronized 关键字更好。
3. volatile 关键字被多线程访问不会发生阻塞，synchronized 关键字可能发生阻塞。
4. volatile 关键字能保证数据的可见性，但不能保证数据的原子性。synchronized 关键字两者都能保证。

```java
// 双重锁结构实现单例模式

public class Singleton {  
    private volatile static Singleton singleton;  
    private Singleton (){}  
    public static Singleton getSingleton() {  
        if (singleton == null) {  
            synchronized (Singleton.class) {    
                if (singleton == null) {  
                    singleton = new Singleton();  
                }  
            }  
        }  
        return singleton;  
    }  
}
```

------

## [ReentrantLock 锁](https://delaube1.github.io/#/javase/并发/线程安全入门?id=reentrantlock-锁)

实现 Lock 接口，使用时需导入 `import java.util.concurrent.locks.*;`。

实现功能和 synchronized 关键字类似。但 synchronized 关键字是在 JVM 层面实现的，而 ReenTrantLock 是在 JDK 层面实现的。需要手动调用 lock 和 unlock 方法配合 try/finally 语句块来完成。

```java
public class ReentrantLockTest {
    // 创建锁对象
    static Lock lock = new ReentrantLock();

    public static void main(String[] args) throws InterruptedException {
        for(int i = 0; i < 5; i++){
            new Thread(new MyThread()).start();
        }
    }

    static class MyThread implements Runnable {
        @Override
        public void run() {                                   
            try {
                // 加锁，通常在 try 语句里完成
                lock.lock();
                Thread.sleep(500);
                System.out.println(Thread.currentThread().getName() + "excute");
            } catch (InterruptedException e) {}
            finally{
                // 解锁，必须在 finally 语句里完成
                lock.unlock();    
            }                      
            }
        }
    }
}
```

*ReenTrantLock 比 synchronized 增加了一些高级功能，主要有以下三点：*

### [实现等待中断](https://delaube1.github.io/#/javase/并发/线程安全入门?id=实现等待中断)

调用 lockInterruptibly 方法上锁，线程中断标志置为 true 时会抛出 InterruptedException 异常并释放锁。防止线程因为无法获得锁而一直等待，常用来从外部破坏线程死锁。

```java
public class ThreadDemo {
    // 创建锁对象
    static Lock lock = new ReentrantLock();

    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(new MyThread(),"thread1");
        Thread t2 = new Thread(new MyThread(),"thread2");
        t1.start();
        t2.start();
        Thread.sleep(500);
        // 提前中断线程
        t2.interrupt();                                      
    }

    static class MyThread implements Runnable {
        @Override
        public void run() {
            System.out.println(Thread.currentThread().getName() + "begin");
            try {
                // 加可中断锁
                lock.lockInterruptibly();                    
                Thread.sleep(2000);
            } catch (InterruptedException e) {
                System.out.println(Thread.currentThread().getName() + "out");
            } finally{
                try{
                    lock.unlock();
                } catch(IllegalMonitorStateException e) {}  
                System.out.println(Thread.currentThread().getName() + "end");
            }
        }
    }
}
```

调用 tryLock 方法上锁，可以从线程内部破坏死锁，可以更好地解决死锁问题。

- 传入时间参数设定等待锁的时间，超时没有获得锁则中止。
- 无参则返回锁申请的结果：true表示获取锁成功，false表示获取锁失败。

```java
public class ThreadDemo {
    // 创建锁对象
    static Lock lock = new ReentrantLock();

    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(new MyThread(),"thread1");
        Thread t2 = new Thread(new MyThread(),"thread2");
        t1.start();
        t2.start();                                  
    }

    static class MyThread implements Runnable {
        @Override
        public void run() {
            System.out.println(Thread.currentThread().getName() + "begin");
            try {
                // 加锁失败直接退出
                if(!lock.tryLock()) {                         
                    System.out.println(Thread.currentThread().getName() + "out");
                    return;
                }                  
                Thread.sleep(2000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally{
                try{
                    lock.unlock();
                } catch(IllegalMonitorStateException e) {}
                System.out.println(Thread.currentThread().getName() + "end");
            }
        }
    }
}
```

### [实现公平锁](https://delaube1.github.io/#/javase/并发/线程安全入门?id=实现公平锁)

允许先等待的线程先获取锁，防止线程因无法获得锁而一直等待。但由于性能优势，默认情况下仍使用非公平锁。在构造锁对象时添加参数 true 即可实现。

```java
import java.util.concurrent.locks.*;

public class ReentrantLockTest {
    // 创建锁对象，且声明为公平锁
    static Lock lock = new ReentrantLock(true);

    public static void main(String[] args) throws InterruptedException {
        for(int i = 0; i < 5; i++){
            new Thread(new MyThread()).start();
        }
    }

    static class MyThread implements Runnable {
        @Override
        public void run() {
            lock.lock();                                     
            try {
                Thread.sleep(500);
                System.out.println(Thread.currentThread().getName() + "excute");
            } catch (InterruptedException e) {}
            lock.unlock();                                 
            }
        }
    }
}
```

### [选择性通知](https://delaube1.github.io/#/javase/并发/线程安全入门?id=选择性通知)

ReentrantLock 对象可以创建一个或多个 Condition 对象，实现线程间的等待通知机制。比 synchronized 关键字 使用 wait/notify 方法更为简便和易用。

线程获得 Lock 锁之后便可调用 Condition 接口的 await 方法释放锁并等待,直到有其他线程调用 Condition 的 signal 方法唤醒线程。通过设置多个 condition 对象，多个线程等待不同的 condition 对象，可以实现选择性地叫醒线程。

```java
public class ThreadDemo {

    static ReentrantLock lock = new ReentrantLock();
    static Condition condition = lock.newCondition();

    public static void main(String[] args) throws InterruptedException {
        lock.lock();
        new Thread(new MyThread()).start();
        System.out.println("主线程等待通知");
        try {
            condition.await();
        } finally {
            lock.unlock();
        }
        System.out.println("主线程恢复运行");
    }

    static class MyThread implements Runnable {
        @Override
        public void run() {
            lock.lock();
            try {
                condition.signal();
                System.out.println("子线程通知");
            } finally {
                lock.unlock();
            }
        }
    }
}
```

------

## [Atomic 原子类](https://delaube1.github.io/#/javase/并发/线程安全入门?id=atomic-原子类)

原子对象的单个方法具有原子性，通过 CAS 算法和自旋操作实现，并发效率高。使用时需导入 `import java.util.concurrent.atomic.*`。

```java
public class ThreadDemo {

    public static void main(String[] args) {
        MyThread t = new MyThread();
        Thread t1 = new Thread(t);
        Thread t2 = new Thread(t);
        t1.start();
        t2.start();
    }
}

class MyThread implements Runnable {
    AtomicInteger count = new AtomicInteger(0);       // 定义整型地原子类
    @Override
    public void run() {
        for (int i = 0; i < 10000; i++) {
            count.incrementAndGet();                  // 原子性自增操作
        }
        System.out.println("final x: " + count);      // 最后输出的数据为 20000
    }
}
```

------

## [ThreadLocal 线程本地对象](https://delaube1.github.io/#/javase/并发/线程安全入门?id=threadlocal-线程本地对象)

ThreadLocal 类会对每一个线程创建一个副本，用来保存其私有的数据，其他线程无法访问。简单方便且并发性好，在开发框架中被大量使用，比如 session 管理。

**ThreadLocal 方法**

```java
ThreadLocal threadLocal = new ThreadLocal();        // 构造 ThreadLocal
ThreadLocal<T> threadLocal = new ThreadLocal<>();   // 支持泛型

threadLocal.get();                      // 获取当前线程中保存的变量副本
threadLocal.set(10);                    // 设置当前线程中变量的副本
threadLocal.remove();                   // 移除当前线程中变量的副本
```

**ThreadLocal 示例**

```java
// 两个线程从同一个 MyThread 对象取值，但结果不同。
public class ThreadLocalExample {
    public static void main(String[] args) {
        MyThread t = new MyThread();
        Thread thread1 = new Thread(t);
        Thread thread2 = new Thread(t);
        thread1.start();
        thread2.start();
    }
}

class MyThread implements Runnable {

    private ThreadLocal threadLocal = new ThreadLocal();

    @Override
    public void run() {
        threadLocal.set((int) (Math.random() * 100D));
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {}
        System.out.println(threadLocal.get());
    }
}
```

- [线程安全](https://delaube1.github.io/#/javase/并发/线程安全进阶?id=线程安全)

- - [AbstractQueuedSynchronizer 类](https://delaube1.github.io/#/javase/并发/线程安全进阶?id=abstractqueuedsynchronizer-类)

  - - [AQS 存储状态](https://delaube1.github.io/#/javase/并发/线程安全进阶?id=aqs-存储状态)
    - [资源共享方式](https://delaube1.github.io/#/javase/并发/线程安全进阶?id=资源共享方式)
    - [自定义同步器](https://delaube1.github.io/#/javase/并发/线程安全进阶?id=自定义同步器)

  - [ReentrantReadWriteLock 锁](https://delaube1.github.io/#/javase/并发/线程安全进阶?id=reentrantreadwritelock-锁)

  - [Semaphore 信号量](https://delaube1.github.io/#/javase/并发/线程安全进阶?id=semaphore-信号量)

  - [CountDownLatch 倒计时器](https://delaube1.github.io/#/javase/并发/线程安全进阶?id=countdownlatch-倒计时器)

  - [CyclicBarrier 循环栅栏](https://delaube1.github.io/#/javase/并发/线程安全进阶?id=cyclicbarrier-循环栅栏)

# [线程安全](https://delaube1.github.io/#/javase/并发/线程安全进阶?id=线程安全)

https://blog.csdn.net/mulinsen77/article/details/84583716

## [AbstractQueuedSynchronizer 类](https://delaube1.github.io/#/javase/并发/线程安全进阶?id=abstractqueuedsynchronizer-类)

又名 AQS 框架，位于 java.util.concurrent.locks 包内。用来构建锁和同步器的框架，使用 AQS 能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的 ReentrantLock，Semaphore 等。

AQS 核心思想是通过以下方式，建立一套线程阻塞等待以及被唤醒时锁分配的机制。

- 如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。
- 如果被请求的共享资源被占用，就将暂时获取不到锁的线程封装成一个结点，加入到一个虚拟的双向队列 CLH 中。

*CLH 不存在真实的队列，仅存在结点之间的关联关系。*

![CLH](https://delaube1.github.io/javase/%E5%B9%B6%E5%8F%91/img/CLH.png)

### [AQS 存储状态](https://delaube1.github.io/#/javase/并发/线程安全进阶?id=aqs-存储状态)

AQS 负责维护：

1. 一个 volatile int 成员变量 state
2. 一个 FIFO 线程等待队列

成员变量 state 表示资源状态，通过 getState/setState 方法存取。

线程抢占资源时会通过 CAS 操作去尝试修改 state ，成功则获取锁成功，失败则进入等待队列等待被唤醒。

### [资源共享方式](https://delaube1.github.io/#/javase/并发/线程安全进阶?id=资源共享方式)

AQS 定义两种资源共享方式

- **Exclusive（独占）**

只有一个线程能执行，如 ReentrantLock。

state初始化为0，表示未锁定状态。加一后锁定。

- **Share（共享）**

多个线程可同时执行，如 Semaphore/CountDownLatch。Semaphore、CountDownLatCh、 CyclicBarrier、ReadWriteLock 。

返回 state 负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。

### [自定义同步器](https://delaube1.github.io/#/javase/并发/线程安全进阶?id=自定义同步器)

同步器的设计是基于模板方法模式的，如果需要自定义同步器一般的方式是这样（模板方法模式很经典的一个应用）：

同步类在实现时一般都将自定义同步器（sync）定义为内部类，供自己使用；而同步类自己（Mutex）则实现某个接口，对外服务。

使用者继承 AbstractQueuedSynchronizer 并重写指定的方法。（这些重写方法很简单，无非是对于共享资源 state 的获取和释放） 将 AQS 组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。

isHeldExclusively()：该线程是否正在独占资源。只有用到condition才需要去实现它。 tryAcquire(int)：独占方式。尝试获取资源，成功则返回true，失败则返回false。 tryRelease(int)：独占方式。尝试释放资源，成功则返回true，失败则返回false。 tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。 tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。

```java
class Mutex implements Lock, java.io.Serializable {
    // 自定义同步器
    private static class Sync extends AbstractQueuedSynchronizer {
        // 判断是否锁定状态
        protected boolean isHeldExclusively() {
            return getState() == 1;
        }

        // 尝试获取资源，立即返回。成功则返回true，否则false。
        public boolean tryAcquire(int acquires) {
            assert acquires == 1; // 这里限定只能为1个量
            if (compareAndSetState(0, 1)) {//state为0才设置为1，不可重入！
                setExclusiveOwnerThread(Thread.currentThread());//设置为当前线程独占资源
                return true;
            }
            return false;
        }

        // 尝试释放资源，立即返回。成功则为true，否则false。
        protected boolean tryRelease(int releases) {
            assert releases == 1; // 限定为1个量
            if (getState() == 0)//既然来释放，那肯定就是已占有状态了。只是为了保险，多层判断！
                throw new IllegalMonitorStateException();
            setExclusiveOwnerThread(null);
            setState(0);//释放资源，放弃占有状态
            return true;
        }
    }

    // 真正同步类的实现都依赖继承于AQS的自定义同步器！
    private final Sync sync = new Sync();

    //lock<-->acquire。两者语义一样：获取资源，即便等待，直到成功才返回。
    public void lock() {
        sync.acquire(1);
    }

    //tryLock<-->tryAcquire。两者语义一样：尝试获取资源，要求立即返回。成功则为true，失败则为false。
    public boolean tryLock() {
        return sync.tryAcquire(1);
    }

    //unlock<-->release。两者语文一样：释放资源。
    public void unlock() {
        sync.release(1);
    }

    //锁是否占有状态
    public boolean isLocked() {
        return sync.isHeldExclusively();
    }
}
```

------

## [ReentrantReadWriteLock 锁](https://delaube1.github.io/#/javase/并发/线程安全进阶?id=reentrantreadwritelock-锁)

Java 的并发包提供了读写锁 ReentrantReadWriteLock ，其拥有两个锁：读锁-共享锁；写锁-排他锁。如果其他线程没有持有写锁，线程就能获得读锁。而只有其他线程没有持有任何锁，线程才能获得写锁。这样在没有写操作的时候，允许多个线程同时读一个资源，提高并发效率。

一个线程要想同时持有写锁和读锁，必须先获取写锁再获取读锁；写锁可以降级为读锁；读锁不能升级为写锁。

## [Semaphore 信号量](https://delaube1.github.io/#/javase/并发/线程安全进阶?id=semaphore-信号量)

Semaphore 类是一个同步工具类，需要进行导入：`import java.util.concurrent.Semaphore`。

synchronized 和 ReentrantLock 一次只允许一个线程访问某个资源，如果指定多个线程同时访问某个资源需要钱使用 Semaphore 类。线程执行时调用 acquire 方法申请信号量，如果剩余信号量不足则必须等待其他线程执行完毕后调用 release 方法释放信号量。

**Semaphore 方法**

```java
Semaphore semaphore = new Semaphore(0);       
Semaphore semaphore = new Semaphore(20, true);  

// Semaphore 构造方法设定了初始信号量，可以为 0。默认为非公平锁，设定属性 true 则为公平锁。

semaphore.acquire();              // 线程获取一个信号量
semaphore.acquire(5);             // 线程获取五个信号量

semaphore.release();              // 线程释放一个信号量
semaphore.release(5);             // 线程释放五个信号量

semaphore.availablePermits();     // 读取剩余信号量
```

**Semaphore 示例**

```java
public class SemaphoreExample1 {

  public static void main(String[] args) throws InterruptedException {
    ExecutorService threadPool = Executors.newFixedThreadPool(300);
    // 设置 20 个信号量
    final Semaphore semaphore = new Semaphore(20);
    // final Semaphore semaphore = new Semaphore(20, true);  公平锁

    for (int i = 0; i < 500; i++) {
      final int threadnum = i;
      threadPool.execute(() -> {
        try {
          semaphore.acquire();             // 获取一个信号量
          test(threadnum);
          semaphore.release();             // 释放一个信号量
        } catch (InterruptedException e) {
          e.printStackTrace();
        }

      });
    }
    threadPool.shutdown();
    System.out.println("finish");
  }

  public static void test(int threadnum) throws InterruptedException {
    Thread.sleep(1000);
    System.out.println("threadnum:" + threadnum);
    Thread.sleep(1000);
  }
}
```

------

## [CountDownLatch 倒计时器](https://delaube1.github.io/#/javase/并发/线程安全进阶?id=countdownlatch-倒计时器)

CountDownLatch 类是一个同步工具类，需要进行导入：`import java.util.concurrent.CountDownLatch`。

其通过 await 方法设置一个屏障，线程到达后被阻塞。直到其他线程调用 countDown 方法达到 N 次后才允许向后执行。 CountDownLatch 类是一次性的，计数器值只能在构造方法中初始化一次，不能被重复使用。常用来协同多个线程之间的执行顺序，比如主线程需要等待多个组件加载完毕之后再继续执行。

**CountDownLatch 方法**

```java
CountDownLatch latch = new CountDownLatch(5);

// CountDownLatch 构造方法设定了门闩个数。

latch.countDown();                // 解锁门闩，门闩个数减一
latch.await();                    // 线程等待门闩，个数为 0 后向后执行
```

**CountDownLatch 示例**

```java
import java.util.concurrent.CountDownLatch;

public class ThreadDemo {

    final static CountDownLatch latch = new CountDownLatch(5);

    public static void main(String[] args) throws InterruptedException {
        for(int i = 0; i < 5; i++) {
            new MyThread().start();
        }
        latch.await();
        System.out.println("主线程继续执行");
    }

    static class MyThread extends Thread {
        @Override
        public void run() {
            try {
                System.out.println(getName() + "打开门闩");
            } finally {
                latch.countDown();
            }
        }
    }
}
```

------

## [CyclicBarrier 循环栅栏](https://delaube1.github.io/#/javase/并发/线程安全进阶?id=cyclicbarrier-循环栅栏)

CyclicBarrier 类也是一个同步工具类，需要进行导入：`import java.util.concurrent.CyclicBarrier`。

其通过 await 方法设置一个屏障，线程到达后被阻塞。只有当 N 个线程都到达屏障后才允许这些线程向后执行。和 CountDownLatch 不同，CyclicBarrier 可循环利用。常用于多线程计算数据，最后合并计算结果的场景。

**CyclicBarrier 方法**

```java
CyclicBarrier barrier = CyclicBarrier(10); 
CyclicBarrier barrier = CyclicBarrier(10, ()-> System.out.println("open"));

// CyclicBarrier 构造方法设定了参与线程的个数 N，也可以选择设定在第 N 个线程到达屏障时执行方法。

barrier.await();                             // 线程必须等到 N 个线程才能向后执行
barrier.await(20, TimeUnit.SECONDS);         // 线程等待规定时间后无论如何都会向后执行
```

**CyclicBarrier 示例**

```java
import java.util.concurrent.CyclicBarrier;

public class CyclicBarrierDemo {  
    public static void main(String[] args) {  
        for(int i = 0; i < 10; i++) {
            new MyThread().start();
        }
    } 
}

class MyThread extends Thread {
    static CyclicBarrier barrier = new CyclicBarrier(5, new Runnable() {
        @Override
        public void run() {
            System.out.println("栅栏开启");
        }
    });

    @Override
    public void run() {
        try {
            Thread.sleep(1000);
            System.out.println(getName() + " 到达栅栏");
            barrier.await();
            System.out.println(getName() + " 冲破栅栏");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

- [线程池](https://delaube1.github.io/#/javase/并发/线程池?id=线程池)

- - [线程池基本概念](https://delaube1.github.io/#/javase/并发/线程池?id=线程池基本概念)

  - - [线程池](https://delaube1.github.io/#/javase/并发/线程池?id=线程池-1)
    - [核心线程池](https://delaube1.github.io/#/javase/并发/线程池?id=核心线程池)
    - [任务队列](https://delaube1.github.io/#/javase/并发/线程池?id=任务队列)
    - [最大线程池](https://delaube1.github.io/#/javase/并发/线程池?id=最大线程池)
    - [拒绝策略](https://delaube1.github.io/#/javase/并发/线程池?id=拒绝策略)

  - [ThreadPoolExecutor 类](https://delaube1.github.io/#/javase/并发/线程池?id=threadpoolexecutor-类)

  - - [创建线程池](https://delaube1.github.io/#/javase/并发/线程池?id=创建线程池)

    - [获取线程池信息](https://delaube1.github.io/#/javase/并发/线程池?id=获取线程池信息)

    - [提交任务](https://delaube1.github.io/#/javase/并发/线程池?id=提交任务)

    - - [Runnable 接口](https://delaube1.github.io/#/javase/并发/线程池?id=runnable-接口)
      - [Callable 接口](https://delaube1.github.io/#/javase/并发/线程池?id=callable-接口)

    - [关闭线程池](https://delaube1.github.io/#/javase/并发/线程池?id=关闭线程池)

  - [~~Executors 类（不常用）~~](https://delaube1.github.io/#/javase/并发/线程池?id=executors-类（不常用）)

# [线程池](https://delaube1.github.io/#/javase/并发/线程池?id=线程池)

------

## [线程池基本概念](https://delaube1.github.io/#/javase/并发/线程池?id=线程池基本概念)

### [线程池](https://delaube1.github.io/#/javase/并发/线程池?id=线程池-1)

线程池本质上是一种对象池，用于管理线程资源。在任务执行前，需要从线程池中拿出线程来执行。在任务执行完成之后，把线程放回线程池。实际开发中，线程资源一般通过线程池提供，比如处理数据库连接、接收网络请求。

1. 线程的创建更加规范，可以合理控制开辟线程的数量。
2. 不必频繁地创建和销毁线程，优化了资源的开销。

### [核心线程池](https://delaube1.github.io/#/javase/并发/线程池?id=核心线程池)

**(corePool) 通常状况下，线程池最多能创建的线程数。**

当有新任务等待处理时，线程池会首先判断核心线程池是否已满，如果没满则创建线程执行任务。即使有其他核心线程空闲也会创建新的核心线程来执行。

### [任务队列](https://delaube1.github.io/#/javase/并发/线程池?id=任务队列)

**(BlockQueue) 线程池中等待被线程执行的任务队列。**

如果核心线程池已满，线程池会判断队列是否已满。如果队列没满，就会将任务放在队列中等待执行。

- ArrayBlockingQueue // 基于数组实现的阻塞队列，有界。
- LinkedBlockingQueue // 基于链表实现的阻塞队列，可以无界。
- SynchronousQueue // 不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作。
- PriorityBlockingQueue // 带优先级的阻塞队列，无界。

### [最大线程池](https://delaube1.github.io/#/javase/并发/线程池?id=最大线程池)

**(maximumPool) 任务量很大时，线程池最多能创建的线程数。**

如果队列已满，说明当前任务量已经非常大，仅靠核心线程池内的线程数量已无法处理。线程池会判断最大线程池是否已满，如果没满则创建更多线程，从等待队列首部取得任务并执行。

### [拒绝策略](https://delaube1.github.io/#/javase/并发/线程池?id=拒绝策略)

**(RejectedExecutionHandler) 线程池拒绝过量任务的方式。**

如果最大线程池已满，表示当前服务器已无法处理这么多任务。任务会按照既定的拒绝策略被处理。

- CallerRunsPolicy // 在调用者线程执行。
- AbortPolicy // 直接抛出 RejectedExecutionException 异常。
- DiscardPolicy // （常用）任务直接丢弃，不做任何处理。
- DiscardOldestPolicy // 丢弃队列里最旧的那个任务，再尝试执行当前任务。

------

## [ThreadPoolExecutor 类](https://delaube1.github.io/#/javase/并发/线程池?id=threadpoolexecutor-类)

实现了 ExecutorService 接口，是 java 开发常用的线程池类。位于 java.util.concurrent 包内，使用时需要进行导入。

### [创建线程池](https://delaube1.github.io/#/javase/并发/线程池?id=创建线程池)

1. ThreadPoolExecutor 类在创建线程池时需要输入以下参数：

```java
int corePoolSize = 2;                                                // 核心线程池大小
int maximumPoolSize = 4;                                             // 最大线程池大小
long keepAliveTime = 10;                                             // 空闲线程多久被销毁，0 表示永远不会
TimeUnit unit = TimeUnit.SECONDS;                                    // keepAliveTime 的单位
BlockingQueue<Runnable> workQueue = new ArrayBlockingQueue<>(2);     // 任务队列
ThreadFactory threadFactory = new NameTreadFactory();                // 线程工厂接口，一般默认。
RejectedExecutionHandler handler = new MyIgnorePolicy();             // 拒绝策略，一般默认。

ThreadPoolExecutor service = new ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, 
unit, workQueue, threadFactory, handler);
```

1. ThreadPoolExecutor 类还可以重写以下方法（默认为空实现）：

```java
ExecutorService service = new ThreadPoolExecutor(1, 1, 1, TimeUnit.SECONDS, new ArrayBlockingQueue<>(1)) {
    // 任务执行前被调用
    @Override 
    protected void beforeExecute(Thread t, Runnable r) {
        System.out.println("beforeExecute is called");
    }
    // 任务执行后被调用
    @Override 
    protected void afterExecute(Runnable r, Throwable t) {
        System.out.println("afterExecute is called");
    }
    // 线程池结束后被调用
    @Override
    protected void terminated() {
        System.out.println("terminated is called");
    }
};
```

### [获取线程池信息](https://delaube1.github.io/#/javase/并发/线程池?id=获取线程池信息)

```java
service.getTaskCount();                 // 获取已经执行或正在执行的任务数
service.getCompletedTaskCount();        // 获取已经执行的任务数
service.getLargestPoolSize();           // 获取线程池曾经创建过的最大线程数
service.getPoolSize();                  // 获取线程池线程数
service.getActiveCount();               // 获取活跃线程数（正在执行任务的线程数）
```

### [提交任务](https://delaube1.github.io/#/javase/并发/线程池?id=提交任务)

可以向线程池提交的任务有两种：Runnable 接口和 Callable 接口。

#### [Runnable 接口](https://delaube1.github.io/#/javase/并发/线程池?id=runnable-接口)

内部定义了 run 方法，没有返回值，不允许抛出异常。通过 execute 方法向线程池提交。

```java
service.execute(new Runnable(){             
    System.out.println("new thread");
});
```

#### [Callable 接口](https://delaube1.github.io/#/javase/并发/线程池?id=callable-接口)

内部定义了 call 方法，允许有返回值，允许抛出异常。通过 submit 方法向线程池提交，返回一个 Future 对象。

可以通过调用 Future 对象的 get 方法获得数据，在返回结果前 get 方法会阻塞。

```java
Future<Integer> f = service.submit(new Callable(){            
    System.out.println("new thread");
    return 1;
});
System.out.println(f.get());
```

### [关闭线程池](https://delaube1.github.io/#/javase/并发/线程池?id=关闭线程池)

```java
service.shutdown();      // 线程池不再接受新的任务，线程池中已有任务执行完成后终止。
service.shutdownNow();   // 线程池不再接受新的任务并对所有线程执行 interrupt 操作，清空队列并终止。

boolean b = service.isShutdown();      // 返回线程池是否关闭：不再接受新任务。
boolean b = service.isTerminated();    // 返回线程池是否终止
```

**ThreadPoolExecutor 类示例**

```java
public class ThreadPool {
    private static ExecutorService pool;
    public static void main( String[] args )
    {
        //自定义线程工厂
        pool = new ThreadPoolExecutor(2, 4, 1000, TimeUnit.MILLISECONDS, new ArrayBlockingQueue<Runnable>(5),
                new ThreadFactory() {
            public Thread newThread(Runnable r) {
                System.out.println("线程"+r.hashCode()+"创建");
                //线程命名
                Thread th = new Thread(r,"threadPool"+r.hashCode());
                return th;
            }
        }, new ThreadPoolExecutor.CallerRunsPolicy());

        for(int i=0;i<10;i++) {
            pool.execute(new ThreadTask());
        }    
    }
}

public class ThreadTask implements Runnable{    
    public void run() {
        //输出执行线程的名称
        System.out.println("ThreadName:"+Thread.currentThread().getName());
    }
}
```

------

## [~~Executors 类（不常用）~~](https://delaube1.github.io/#/javase/并发/线程池?id=executors-类（不常用）)

继承 ThreadPoolExecutor 类的线程池工厂类：提供 4 种工厂方法创建线程池。但该方法既不灵活也不安全，实际开发中很少使用。

```java
// 单个线程的线程池
ExecutorService service = Executors.newSingleThreadExecutor();
// 指定数量的线程池
ExecutorService service = Executors.newFixedThreadExecutor(10); 
// 大小不限的线程池，60s 不使用会自动回收空闲线程。
ExecutorService service = Executors.newCacheThreadExecutor();
// 大小不限的线程池，可定时执行任务。
ExecutorService service = Executors.newScheduleThreadExecutor();
```

**Executors 类示例**

```java
public class ThreadPoolTest {
    public static void main(String[] args) {
        ExecutorService executor = Executors.newFixedThreadPool(5);
        for (int i = 0; i < 10; i++) {
            executor.submit(() -> {
                System.out.println("thread id is: " + Thread.currentThread().getId());
                try {
                    Thread.sleep(1000L);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            });
        }
    }
}
```

- [JVM](https://delaube1.github.io/#/javase/JVM/JVM介绍?id=jvm)

- - [JDK / JRE / JVM 的关系](https://delaube1.github.io/#/javase/JVM/JVM介绍?id=jdk-jre-jvm-的关系)

  - - [JDK 开发工具包](https://delaube1.github.io/#/javase/JVM/JVM介绍?id=jdk-开发工具包)
    - [JRE 运行环境](https://delaube1.github.io/#/javase/JVM/JVM介绍?id=jre-运行环境)
    - [JVM 虚拟机](https://delaube1.github.io/#/javase/JVM/JVM介绍?id=jvm-虚拟机)

  - [Java 运行原理](https://delaube1.github.io/#/javase/JVM/JVM介绍?id=java-运行原理)

  - - [基本概念](https://delaube1.github.io/#/javase/JVM/JVM介绍?id=基本概念)
    - [Java 运行原理](https://delaube1.github.io/#/javase/JVM/JVM介绍?id=java-运行原理-1)

  - [类加载](https://delaube1.github.io/#/javase/JVM/JVM介绍?id=类加载)

  - - [加载](https://delaube1.github.io/#/javase/JVM/JVM介绍?id=加载)
    - [链接](https://delaube1.github.io/#/javase/JVM/JVM介绍?id=链接)
    - [初始化](https://delaube1.github.io/#/javase/JVM/JVM介绍?id=初始化)

# [JVM](https://delaube1.github.io/#/javase/JVM/JVM介绍?id=jvm)

------

## [JDK / JRE / JVM 的关系](https://delaube1.github.io/#/javase/JVM/JVM介绍?id=jdk-jre-jvm-的关系)

### [JDK 开发工具包](https://delaube1.github.io/#/javase/JVM/JVM介绍?id=jdk-开发工具包)

(java development kit) **支持开发和运行 Java 程序。**

JDK 包含 JRE 以及各种 Java 开发工具（如编译器 javac 、调试器 jdb 等）。

### [JRE 运行环境](https://delaube1.github.io/#/javase/JVM/JVM介绍?id=jre-运行环境)

(java runtime environment) **能够运行已编译的 Java 程序。**

JRE 包含 JVM 以及运行时所需调用的基础类库（如 java.lang 包、 java.util 包等）。

### [JVM 虚拟机](https://delaube1.github.io/#/javase/JVM/JVM介绍?id=jvm-虚拟机)

(java virtual machine) **运行 Java 程序的工作环境。**

Java 程序在虚拟机上运行而不是直接在操作系统上运行，从软件层面屏蔽了底层硬件指令的细节。虚拟机会根据操作系统自动将字节码文件转化成相应的机器码，使 Java 字节码文件能够在多种平台上不加修改地运行。

*HotSpot 虚拟机 是 SunJDK 和 OpenJDK 中所带的虚拟机，也是目前使用范围最广的 Java 虚拟机。*

------

## [Java 运行原理](https://delaube1.github.io/#/javase/JVM/JVM介绍?id=java-运行原理)

### [基本概念](https://delaube1.github.io/#/javase/JVM/JVM介绍?id=基本概念)

**解释和编译**

- **解释**：源文件经过编译器编译成为脚本文件，由解释器逐行解释并执行。灵活性更好。
- **编译**：源文件经过编译器编译成为可执行文件，由计算机直接去执行。性能更好。

**静态编译和动态编译**

- **静态编译**：编译时确定类型，绑定对象。性能更好。
- **动态编译**：运行时确定类型，绑定对象。能更好地支持多态，灵活性强。

### [Java 运行原理](https://delaube1.github.io/#/javase/JVM/JVM介绍?id=java-运行原理-1)

***Java 是编译和解释并行的语言，采取动态编译，支持反射机制。\***

1. 源文件(.java) 经过编译器编译成为 字节码文件(.class) ，通过类加载器搬运到 JVM 中逐行解释并执行。
2. 即时编译器(JIT) 在编译时会识别反复执行的热点代码（超过 10000 次）并保存机器码，复用时可直接由 JVM 执行。

**优势**：以虚拟机作为中介，字节码文件可以在所有操作平台上通用。即一次编译、到处运行。

**劣势**：但这也导致了 Java 语言性能不如 C/C++ 等编译语言。

------

## [类加载](https://delaube1.github.io/#/javase/JVM/JVM介绍?id=类加载)

在 Java 程序里如果使用某个尚未加载到内存中的类，JVM 会通过加载、链接、初始化 3 个步骤来对该类进行初始化。

![类](https://delaube1.github.io/javase/JVM/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.png)

> 创建类的实例，访问类的静态变量，或者调用类的静态方法都会导致类的初始化。但要注意对于 final 常量，如果在编译时就可以确定该变量的值，编译器会在编译时直接把这个变量替换成它的值，因此即使程序使用该静态变量，也不会导致该类的初始化。

### [加载](https://delaube1.github.io/#/javase/JVM/JVM介绍?id=加载)

**类的加载由类加载器完成。类加载器会读取类的字节码文件，并为之创建一个 java.lang.Class 对象。**

类加载器使用双亲委派模型，类加载器具备一种带有优先级的层次关系：

- 根类加载器：负责加载 Java 的核心类，原生代码实现，并不继承自 java.lang.ClassLoader 类。
- 扩展类加载器：负责加载 JRE 扩展目录中的类。由 Java 语言实现，没有父类加载器。
- 系统类加载器：负责加载 CLASSPATH 路径中的类。由 Java 语言实现，父类加载器为扩展类加载器。
- 用户类加载器：开发者通过继承 ClassLoader 基类来创建的类加载器。由 Java 语言实现，默认父类加载器为系统类加载器。

任何类加载器在接到加载类的请求时，都会将加载任务委托给父类加载器，最终委派给处于模型最顶端的根类加载器进行加载。只有父类加载器无法完成此加载任务时，才自己去加载。如果均无法载入类，则抛出 ClassNotFountException 异常。

1. 通过这种层级关系可以避免类的重复加载。
2. 其次可以防止核心 API 库被随意篡改，用户即使编写了 java.lang.Object 的同名类，也永远无法被加载运行。

【在双亲委派模型中，由父加载类加载的类，下层加载器是不能加载的。用户在 classpath 路径下自定义的java.*包内的类会抛出异常：SecurityException: Prohibited package name】

### [链接](https://delaube1.github.io/#/javase/JVM/JVM介绍?id=链接)

**当类被加载并生成 Class 对象后，连接阶段负责把类的二进制数据合并到 JRE 中。**

- 验证：验证阶段用于检验被加载的类是否有正确的内部结构，并和其他类协调一致。
- 准备：类准备阶段负责为类的静态变量分配内存，并赋予类型的默认值。
- 解析：将类的二进制数据中的符号引用替换成直接引用，指向具体的内存空间。

*Java 是相对 C++ 语言是安全的语言，验证过程用于确保 Class 文件的字节流符合当前虚拟机要求，不会危害虚拟机自身安全。其主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。*

### [初始化](https://delaube1.github.io/#/javase/JVM/JVM介绍?id=初始化)

**为类的静态变量赋予程序设定的初始值。**

- [JVM](https://delaube1.github.io/#/javase/JVM/JVM内存空间?id=jvm)

- - [内存空间](https://delaube1.github.io/#/javase/JVM/JVM内存空间?id=内存空间)

  - - [方法区](https://delaube1.github.io/#/javase/JVM/JVM内存空间?id=方法区)

    - [堆区](https://delaube1.github.io/#/javase/JVM/JVM内存空间?id=堆区)

    - - [常量池](https://delaube1.github.io/#/javase/JVM/JVM内存空间?id=常量池)

    - [栈区](https://delaube1.github.io/#/javase/JVM/JVM内存空间?id=栈区)

    - [程序计数器](https://delaube1.github.io/#/javase/JVM/JVM内存空间?id=程序计数器)

  - [对象的内存分配](https://delaube1.github.io/#/javase/JVM/JVM内存空间?id=对象的内存分配)

  - - [分配空间](https://delaube1.github.io/#/javase/JVM/JVM内存空间?id=分配空间)
    - [分配过程](https://delaube1.github.io/#/javase/JVM/JVM内存空间?id=分配过程)
    - [分配方式](https://delaube1.github.io/#/javase/JVM/JVM内存空间?id=分配方式)

  - [常量池内存分配](https://delaube1.github.io/#/javase/JVM/JVM内存空间?id=常量池内存分配)

  - - [String 类](https://delaube1.github.io/#/javase/JVM/JVM内存空间?id=string-类)
    - [包装类型](https://delaube1.github.io/#/javase/JVM/JVM内存空间?id=包装类型)

  - [内存过载](https://delaube1.github.io/#/javase/JVM/JVM内存空间?id=内存过载)

# [JVM](https://delaube1.github.io/#/javase/JVM/JVM内存空间?id=jvm)

Java 程序中的内存分配和回收都由 JVM 管理，不支持程序员直接对内存地址进行操作。不容易出现内存泄漏和内存溢出问题。

------

## [内存空间](https://delaube1.github.io/#/javase/JVM/JVM内存空间?id=内存空间)

进程是分配资源的基本单位。除方法区外，所有数据均存放在给进程分配的内存块中。

Java 程序的内存空间主要分为以下几个区域：

![img](https://delaube1.github.io/javase/JVM/%E5%86%85%E5%AD%98.png)

### [方法区](https://delaube1.github.io/#/javase/JVM/JVM内存空间?id=方法区)

(Method Area) 存放 **Java 程序的二进制代码，即类的信息**。

在虚拟机启动时直接存入系统内存中，大小只受系统内存的限制。

### [堆区](https://delaube1.github.io/#/javase/JVM/JVM内存空间?id=堆区)

(Heap) 存放进程创建的**对象实例和数组**。

由线程共享，在虚拟机启动时为进程创建，是占用内存最大的区域。

#### [常量池](https://delaube1.github.io/#/javase/JVM/JVM内存空间?id=常量池)

存放 **final 常量、static 变量和方法，以及 String 和部分包装类型的对象（一经赋值不再改变）**。

> JDK 1.7 后 JVM 将常量池从方法区中移出，改为在堆中开辟空间存放。

### [栈区](https://delaube1.github.io/#/javase/JVM/JVM内存空间?id=栈区)

(Stack) 存放线程执行 Java 方法调用的内存数据。线程每执行一个方法都会创建一个栈帧放入栈区，在方法执行结束后弹出。栈帧中储存局部变量表、操作数栈、动态链接、方法出口信息。其中局部变量表存放**线程和方法的参数、方法中定义的基础类型变量和对象引用**。

由线程私有。生命周期随着线程的创建而创建，随着线程的结束而死亡。

*栈区分为虚拟机栈（执行 java 方法）和本地方法栈（执行 native 方法，底层用 C 实现），但在 HotSpot 虚拟机中两者合二为一。*

### [程序计数器](https://delaube1.github.io/#/javase/JVM/JVM内存空间?id=程序计数器)

用来记录线程的运行状态、管理线程的运行。

1. 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。
2. 在多线程的情况下程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够继续运行。

由线程私有。生命周期随着线程的创建而创建，随着线程的结束而死亡。

------

## [对象的内存分配](https://delaube1.github.io/#/javase/JVM/JVM内存空间?id=对象的内存分配)

### [分配空间](https://delaube1.github.io/#/javase/JVM/JVM内存空间?id=分配空间)

Hotspot 虚拟机中，对象在内存中分为 3 块区域：对象头、实例数据和对齐填充。

- 对象头负责记录对象信息，包括对象运行数据（哈希码、GC 分代年龄、锁状态标志等）和 类型指针（对象所属的类）。
- 对象起止地址必须是 8 字节整数倍，空余部分将使用对齐填充来补全。

### [分配过程](https://delaube1.github.io/#/javase/JVM/JVM内存空间?id=分配过程)

在 Java 中创建对象，需要经过以下过程：

**Step 1. 类加载检查**

```
JVM 接收到 new 指令，首先检查该类是否在常量池中，然后检查该类是否已被加载、解析和初始化。

如果没有则先加载类，类加载器会将类的字节码文件放入 JVM 解析。
```

**Step 2. 分配内存**

```
类加载后，会从 Java 堆中划分一块固定大小的内存区域分配给对象。
```

**Step 3. 半初始化**

```
内存分配完成后，虚拟机将对象的实例数据都半初始化为默认值。此时对象已经可用。
```

**Step 4. 设置对象头**

```
初始化内存空间后，虚拟机要对对象进行必要的设置，把信息存放在对象头中。
```

**Step 5.初始化对象**

```
新的对象已经产生，但所有的字段都为默认值。接下执行 init 方法，将对象的实例数据赋值。
```

**Step 6. 建立关联**

```
将对象引用指向创建的对象。该对象可以通过引用被使用。
```

*在创建对象的过程中可能会发生指令重排序。如果尚未完全初始化就建立了关联，其他线程读取该对象可能会读取到默认值。*

### [分配方式](https://delaube1.github.io/#/javase/JVM/JVM内存空间?id=分配方式)

内存划分有以下两种分配方式：

- 指针碰撞：（内存规整时） 已使用内存和未使用内存用指针隔开，需要分配内存时将指针移动一定位置。
- 空闲列表：（内存不规整时）虚拟机维护一个列表记录空闲内存块，需要分配内存时选择合适的内存块。

Java 堆是否规整，取决于垃圾收集算法是否整理内存。

------

## [常量池内存分配](https://delaube1.github.io/#/javase/JVM/JVM内存空间?id=常量池内存分配)

### [String 类](https://delaube1.github.io/#/javase/JVM/JVM内存空间?id=string-类)

String 对象创建后一经赋值不再改变，有以下两种创建方式：

1. 直接赋值：如果常量池没有，则在常量池新建对象。否则直接使用常量池中已有对象，**引用指向常量池。**
2. 构造方法：如果常量池没有，则在常量池新建对象。无论如何一定会在堆区创建对象，**引用指向堆区。**

```java
String str1 = "string";                       // 引用指向常量池
String str2 = "str" + "ing";                  // 引用指向常量池

String str3 = new String("string");           // 引用指向堆区
String str4 = str1 + str2;                    // 引用指向堆区

System.out.println(str1 == str2);             // true
System.out.println(str1 == str3);             // false
```

### [包装类型](https://delaube1.github.io/#/javase/JVM/JVM内存空间?id=包装类型)

JVM 将部分常用的包装类型数据提前缓存在常量池中，用户创建该类对象时直接在常量池取用，而不用真正新建对象。

- **布尔包装类 Boolean**：将全部缓存数据保存在常量池中。
- **字符包装类 Character**：将 ASCII 字符(0-127) 数据缓存保存在常量池中。如果是汉字等其他字符仍然会创建对象。
- **整型包装类 Byte/Short/Integer/Long**：将数值 [-128，127] 内的数据缓存保存在常量池中。但是超出此范围仍然会去创建新的对象。
- **浮点数类型包装类 Float/Double**： 没有实现常量池技术。

------

## [内存过载](https://delaube1.github.io/#/javase/JVM/JVM内存空间?id=内存过载)

随着 Java 程序的使用，所占用和分配的内存将会越来越大。如果 JVM 已无法分配足够的内存，将会抛出 OutOfMemoryError 导致程序崩溃。

同时为了更合理地使用内存，Java 会由虚拟机对堆区内存空间自动进行垃圾回收。

- [虚拟机](https://delaube1.github.io/#/javase/JVM/JVM垃圾回收?id=虚拟机)

- - [垃圾回收](https://delaube1.github.io/#/javase/JVM/JVM垃圾回收?id=垃圾回收)

  - - [分区回收](https://delaube1.github.io/#/javase/JVM/JVM垃圾回收?id=分区回收)
    - [初次分配对象](https://delaube1.github.io/#/javase/JVM/JVM垃圾回收?id=初次分配对象)
    - [长期存活对象](https://delaube1.github.io/#/javase/JVM/JVM垃圾回收?id=长期存活对象)
    - [大对象](https://delaube1.github.io/#/javase/JVM/JVM垃圾回收?id=大对象)

# [虚拟机](https://delaube1.github.io/#/javase/JVM/JVM垃圾回收?id=虚拟机)

------

## [垃圾回收](https://delaube1.github.io/#/javase/JVM/JVM垃圾回收?id=垃圾回收)

Java 的自动内存管理主要是针对对象内存的回收和对象内存的分配，堆区是垃圾收集器管理的主要区域。

开发者使用 System.gc() 方法可以提醒 JVM 进行垃圾回收，但不能强制。

### [分区回收](https://delaube1.github.io/#/javase/JVM/JVM垃圾回收?id=分区回收)

现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代。进一步划分的目的是更好地回收内存，或者更快地分配内存。

- 新生代 GC (Minor GC) ：新生代垃圾回收非常频繁，回收速度也比较快。
- 老年代 GC (Major GC) ：老年代垃圾回收次数较少，回收速度也明显更慢。

![img](https://delaube1.github.io/javase/JVM/%E5%A0%86.png)

### [初次分配对象](https://delaube1.github.io/#/javase/JVM/JVM垃圾回收?id=初次分配对象)

新生代分为 eden 区和 survive 区， 其中 eden 区占用内存空间更大。

大多数情况下，对象在新生代 eden 区分配。当 eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。

### [长期存活对象](https://delaube1.github.io/#/javase/JVM/JVM垃圾回收?id=长期存活对象)

虚拟机给每个对象设置一个年龄计数器。如果对象经过一次 Minor GC 后仍然能够存活，将从 eden 移动到 survive 空间中。对象每熬过一次 Minor GC，年龄就增加 1 岁。当它的年龄增加到一定程度（默认为 15 岁），就会晋升到老年代。

survive 区分为 from 区和 to 区两块大小相等的内存空间。Minor GC 执行时，会将 eden 区和 from 区中的存活对象复制到 to 区，清除 eden 区和 from 区内存。再把这些存活对象从 to 区移动回 from 区。

当老年代也没有足够空间进行分配时，虚拟机将发起一次 Major GC。

### [大对象](https://delaube1.github.io/#/javase/JVM/JVM垃圾回收?id=大对象)

需要大量连续内存空间的对象（如字符串、数组）直接进入老年代，可以避免为大对象分配内存时由于分配担保机制带来的复制而降低效率。

- [指令重排序](https://delaube1.github.io/#/javase/JVM/JVM指令重排序?id=指令重排序)

- - [指令概念](https://delaube1.github.io/#/javase/JVM/JVM指令重排序?id=指令概念)

  - [指令重排序](https://delaube1.github.io/#/javase/JVM/JVM指令重排序?id=指令重排序-1)

  - - [指令重排序分类](https://delaube1.github.io/#/javase/JVM/JVM指令重排序?id=指令重排序分类)
    - [指令重排序原则](https://delaube1.github.io/#/javase/JVM/JVM指令重排序?id=指令重排序原则)

  - [防止指令重排序](https://delaube1.github.io/#/javase/JVM/JVM指令重排序?id=防止指令重排序)

# [指令重排序](https://delaube1.github.io/#/javase/JVM/JVM指令重排序?id=指令重排序)

------

## [指令概念](https://delaube1.github.io/#/javase/JVM/JVM指令重排序?id=指令概念)

指令是指示计算机执行某种操作的命令，如：数据传送指令、算术运算指令、位运算指令、程序流程控制指令、串操作指令、处理器控制指令。指令不同于我们所写的代码，一行代码按照操作的逻辑可以分成多条指令。

举个例子：int a = 1; 这段代码大致可以分为两条指令：1.加载常量1；2.将常量1赋值给变量a。

## [指令重排序](https://delaube1.github.io/#/javase/JVM/JVM指令重排序?id=指令重排序-1)

只要程序的最终结果与它顺序化情况的结果相等，那么指令的执行顺序可以与代码逻辑顺序不一致，这个过程就叫做指令的重排序。

指令重排序的意义：使指令更加符合 CPU 的执行特性，最大限度的发挥机器的性能，提高程序的执行效率。

### [指令重排序分类](https://delaube1.github.io/#/javase/JVM/JVM指令重排序?id=指令重排序分类)

指令重排序主要分为三种，在这里主要讨论 JVM 中的指令重排序。

1. 编译器重排序：JVM 中完成
2. 指令级并行重排序
3. 处理器重排序：CPU 中完成

### [指令重排序原则](https://delaube1.github.io/#/javase/JVM/JVM指令重排序?id=指令重排序原则)

如果程序中操作A在操作B之前，那么线程中操作A将在操作B之前执行。（只对指令内部重排序，不在指令间重排序）

- **As-If-Serial语义**

不管怎么进行指令重排序，单线程内程序的执行结果不能被改变。

编译器和处理器对存在依赖关系的操作都不会对其进行重排序。只有不存在依赖关系的操作有可能进行重排序。

**Happens-Before原则**

保证正确同步的多线程程序的执行结果不被改变。

对于被同步的操作，如果操作 A 先于操作 B，那么 A 操作的执行结果将对 B 操作可见，而且 A 操作的执行顺序排在 B 操作之前。

管理锁定规则：一个unlock操作happen—before后面（时间上的先后顺序）对同一个锁的lock操作。 （如果线程1解锁了monitor a，接着线程2锁定了a，那么，线程1解锁a之前的写操作都对线程2可见（线程1和线程2可以是同一个线程））

## [防止指令重排序](https://delaube1.github.io/#/javase/JVM/JVM指令重排序?id=防止指令重排序)

volatile关键字通过“内存屏障”来防止指令被重排序。

为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。

Java内存模型采取保守策略（见缝就插）

在每个volatile写操作的前面插入一个StoreStore屏障。 在每个volatile写操作的后面插入一个StoreLoad屏障。 在每个volatile读操作的后面插入一个LoadLoad屏障。 在每个volatile读操作的后面插入一个LoadStore屏障。

Synchronized 把多线程执行环境改变为单线程执行环境，无需关心指令重排序（单线程执行结果不会改变）。

- [I/O](https://delaube1.github.io/#/javase/IO/IO?id=io)

- - [序列化](https://delaube1.github.io/#/javase/IO/IO?id=序列化)

  - - [对象持久化](https://delaube1.github.io/#/javase/IO/IO?id=对象持久化)
    - [Serializable 接口](https://delaube1.github.io/#/javase/IO/IO?id=serializable-接口)

  - [标准输入/输出](https://delaube1.github.io/#/javase/IO/IO?id=标准输入输出)

  - - [标准输入流 System.in](https://delaube1.github.io/#/javase/IO/IO?id=标准输入流-systemin)
    - [标准输出流 System.out](https://delaube1.github.io/#/javase/IO/IO?id=标准输出流-systemout)

  - [流输入输出](https://delaube1.github.io/#/javase/IO/IO?id=流输入输出)

  - - [字节流](https://delaube1.github.io/#/javase/IO/IO?id=字节流)

    - - [InputStream/OutputStream 类](https://delaube1.github.io/#/javase/IO/IO?id=inputstreamoutputstream-类)

    - [字符流](https://delaube1.github.io/#/javase/IO/IO?id=字符流)

    - - [Reader/Writer 类](https://delaube1.github.io/#/javase/IO/IO?id=readerwriter-类)
      - [InputStreamReader 类](https://delaube1.github.io/#/javase/IO/IO?id=inputstreamreader-类)
      - [OutputStreamWriter 类](https://delaube1.github.io/#/javase/IO/IO?id=outputstreamwriter-类)

    - [文件流](https://delaube1.github.io/#/javase/IO/IO?id=文件流)

    - - [File 类](https://delaube1.github.io/#/javase/IO/IO?id=file-类)
      - [FileInputStream/FileReader 类](https://delaube1.github.io/#/javase/IO/IO?id=fileinputstreamfilereader-类)
      - [FileOutputStream/FileWriter 类](https://delaube1.github.io/#/javase/IO/IO?id=fileoutputstreamfilewriter-类)

    - [缓冲流](https://delaube1.github.io/#/javase/IO/IO?id=缓冲流)

    - - [BufferedInputStream/BufferedReader 类](https://delaube1.github.io/#/javase/IO/IO?id=bufferedinputstreambufferedreader-类)
      - [BufferedOutputStream/BufferedWriter 类](https://delaube1.github.io/#/javase/IO/IO?id=bufferedoutputstreambufferedwriter-类)

  - [扫描器](https://delaube1.github.io/#/javase/IO/IO?id=扫描器)

  - - [Scanner 类](https://delaube1.github.io/#/javase/IO/IO?id=scanner-类)

# [I/O](https://delaube1.github.io/#/javase/IO/IO?id=io)

------

## [序列化](https://delaube1.github.io/#/javase/IO/IO?id=序列化)

### [对象持久化](https://delaube1.github.io/#/javase/IO/IO?id=对象持久化)

在 Java 程序中所创建的对象都保存在内存中，一旦 JVM 停止运行，这些对象都将会消失。因此以下两种情况必须通过序列化实现：

1. 需要把对象持久化保存在文件中，在 JVM 重启后能够继续使用。
2. 通过网络传送对象信息，在多个 JVM 间共享对象。

### [Serializable 接口](https://delaube1.github.io/#/javase/IO/IO?id=serializable-接口)

在类中声明实现 Serializable 接口，表示允许 Java 程序对这个类的对象序列化：JVM 会将对象的成员变量保存为一组字节，这些字节可以再被 JVM 组装成对象。对象序列化只保存的对象的成员变量，且不会关注类中的静态变量。

1. **transient 字段**：默认序列化机制就会被忽略。
2. **private 字段**：序列化后不会被保护，任何 JVM 都可读取。

```java
//person类的读入读出
//对于 class Person implements Serializable

        ObjectOutputStream oout = new ObjectOutputStream(new FileOutputStream(file));
        Person person = new Person("John", 101, Gender.MALE);
        oout.writeObject(person);
        oout.close();

        ObjectInputStream oin = new ObjectInputStream(new FileInputStream(file));
        Object newPerson = oin.readObject(); // 没有强制转换到Person类型
        oin.close();
```

------

## [标准输入/输出](https://delaube1.github.io/#/javase/IO/IO?id=标准输入输出)

### [标准输入流 System.in](https://delaube1.github.io/#/javase/IO/IO?id=标准输入流-systemin)

读取标准输入设备数据（键盘），每次输入将以换行符结束。数据类型为 InputStream。

```java
char c = (char)System.in.read();   // 读取单个输入字符，返回其 ASCII 值(int)

byte[] b = new byte[20];
System.in.read(b);                 // 读取输入定长字符组，返回字符个数(int)
```

### [标准输出流 System.out](https://delaube1.github.io/#/javase/IO/IO?id=标准输出流-systemout)

向标准输出设备输出数据（控制台）。数据类型为 PrintStream。

```java
System.out.print("hello");                         // 输出数据
System.out.println("hello");                       // 输出数据并换行
```

**格式化输出**

通过 printf 方法可以输出指定格式数据：其中 `%d` 表示整型数字， `%f` 表示浮点型数字， `%%` 表示百分号。

在百分号后加入特殊符号，可以指定数据的显示类型。

| 符号 | 作用                   | 示例             | 效果  |
| ---- | ---------------------- | ---------------- | ----- |
| +    | 为正数或者负数添加符号 | ("%+d",99)       | +99   |
| 2    | 位数（默认右对齐）     | ("%4d", 99)      | __99  |
| −    | 左对齐                 | ("%-4d", 99)     | 99__  |
| 0    | 数字前补0              | ("%04d", 9999)   | 0099  |
| ,    | 以“,”对数字分组        | ("%,d", 9999)    | 9,999 |
| .2   | 小数点后精确位数       | ("%5.2f", 9.999) | _9.99 |

```java
System.out.printf("The number is %+,9.3f", PI);  // 输出指定格式数据
```

------

## [流输入输出](https://delaube1.github.io/#/javase/IO/IO?id=流输入输出)

java.io 文件夹内提供了 Java 程序中 I/O 操作使用的类，使用时需要进行导入。

### [字节流](https://delaube1.github.io/#/javase/IO/IO?id=字节流)

#### [InputStream/OutputStream 类](https://delaube1.github.io/#/javase/IO/IO?id=inputstreamoutputstream-类)

以字节为单位进行读取的数据流。常用来处理二进制数据的输入输出，如键盘输入、网络通信。但字节流不能正确显示 Unicode 字符。

**输入流**

```java
InputStream in = new InputStream(socket.getIntputStream());        // 创建输入对象

int len = in.available();                                          // 读取输入对象长度

char c = (char)in.read();                                          // 读取输入字节

byte[] b = new byte[len];                                          // 连续读取输入字节
in.read(b);

in.close();                                                        // 关闭输入对象
```

**输出流**

```java
OutputStream out = new OutputStream(socket.getOutputStream());     // 创建输出对象

byte[] b = {1,2,3};                                                // 导入输出字节          
out.write(b);

out.flush();                                                       // 刷新输出对象，输出字节

out.close();                                                       // 关闭输出对象，输出字节
```

### [字符流](https://delaube1.github.io/#/javase/IO/IO?id=字符流)

#### [Reader/Writer 类](https://delaube1.github.io/#/javase/IO/IO?id=readerwriter-类)

以字符为单位进行读取的数据流。只能用于处理文本数据。且所有文本数据，即经过 Unicode 编码的数据都必须以字符流的形式呈现。

我们在 Java 程序中处理数据往往需要用到字符流，但在通信中却需要使用字节流。这就需要进行数据格式转化。

#### [InputStreamReader 类](https://delaube1.github.io/#/javase/IO/IO?id=inputstreamreader-类)

Reader 类子类。将字节流数据转换成字符流，常用于读取控制台输入或读取网络通信。可指定编码方式，否则使用 IDE 默认编码方式。

```java
// 读取键盘输入
InputStreamReader in = new InputStreamReader(System.in);
// 读取套接字通信，并指定编码格式
InputStreamReader in = new InputStreamReader(socket.getInputStream(), "UTF-8");
```

#### [OutputStreamWriter 类](https://delaube1.github.io/#/javase/IO/IO?id=outputstreamwriter-类)

Writer 类子类。将字符流数据转换成字节流，常用于发送网络通信。

```java
// 数据转化为字节流发送
OutputStreamWriter out = new OutputStreamWriter(socket.getOutputStream());
```

### [文件流](https://delaube1.github.io/#/javase/IO/IO?id=文件流)

#### [File 类](https://delaube1.github.io/#/javase/IO/IO?id=file-类)

用于文件或者目录的描述信息，默认加载当前目录。

```java
File f1 = new File("FileTest.txt");                // 读取当前目录文件
File f2 = new File("D://file//FileTest.txt");      // 读取指定目录文件
```

#### [FileInputStream/FileReader 类](https://delaube1.github.io/#/javase/IO/IO?id=fileinputstreamfilereader-类)

FileInputStream 类读取字节流文件信息，FileReader 类读取字符流文件信息。

```java
public class TestFileReader {
    public static void ReadFile(String textName) {
        int c = 0;
        try {
            // 连接文件
            FileReader fr = new FileReader("D:\\Workspaces" + textName);
            // 执行操作
            while ((c = fr.read()) != -1) {
                System.out.print((char)c);
            }
            fr.close();
        } catch (FileNotFoundException e) {
            System.out.println("找不到指定文件");
        } catch (IOException e) {
            System.out.println("文件读取错误");
        }
    }
}
```

#### [FileOutputStream/FileWriter 类](https://delaube1.github.io/#/javase/IO/IO?id=fileoutputstreamfilewriter-类)

FileOutputStream 写入字节流文件信息，FileWriter 类写入字符流文件信息。

```java
public class TestFileWriter {
    public static void ReadFile(String textName) {
        int c = 0;
        try {
            // 追加模式，写入文本信息会添加到文本尾部
            FileWriter fw = new FileWriter(textName);            
            // 覆盖模式，写入文本信息会覆盖原有数据
            FileWriter fw2 = new FileWriter("data.txt", false);
            // 执行操作
            fw.write("Hello world！欢迎来到 java 世界\n");                 
            fw.append("我是下一行");                            
            fw.flush();                                       
            System.out.println("文件编码为" + fw.getEncoding());
            fw.close();                    
        } catch (FileNotFoundException e) {
            System.out.println("找不到指定文件");
        } catch (IOException e) {
            System.out.println("文件写入错误");
        }
    }
}
```

### [缓冲流](https://delaube1.github.io/#/javase/IO/IO?id=缓冲流)

#### [BufferedInputStream/BufferedReader 类](https://delaube1.github.io/#/javase/IO/IO?id=bufferedinputstreambufferedreader-类)

BufferedInputStream 类将输入字节数据暂存到缓冲区数组，BufferedReader 类将输入字符流数据暂存到缓冲区数组。

JVM 在缓冲区数组满后一次性获取缓冲区内的数据，减少了对 CPU 的频繁请求。

#### [BufferedOutputStream/BufferedWriter 类](https://delaube1.github.io/#/javase/IO/IO?id=bufferedoutputstreambufferedwriter-类)

BufferedOutputStream 类将输出字节数据暂存到缓冲区数组，BufferedWriter 类将输出字符流数据暂存到缓冲区数组。

JVM 在刷新时一次性将缓冲区内的数据输出到外部设备，减少了对 CPU 的频繁请求。

```java
class TestBuffer{
    public static void bufferUse() throws IOException {
        // 通过缓冲区读取键盘输入
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        // 通过缓冲区输出到文件
        BufferedWriter bw = new BufferedWriter(new FileWriter("output.txt"));
        // 执行操作
        String line = null;
        while((line = br.readLine()) != null){     // readLine 缓冲流特有方法，一次性读取一行
            if("over".equals(line)){
                break;
            }
            bw.write(line);
            bw.newLine();                          // newLine 缓冲流特有方法，写入换行符
            bw.flush();
        }
        bw.close();
        br.close();
    }
}
```

------

## [扫描器](https://delaube1.github.io/#/javase/IO/IO?id=扫描器)

### [Scanner 类](https://delaube1.github.io/#/javase/IO/IO?id=scanner-类)

包装输入并自动分割数据，调用 next 方法捕获，可以自动转换数据类型。位于 java.util 包内，使用时需进行导入。

```java
Scanner sc = new Scanner(System.in);                             // 读取键盘输入，返回 String 数据类型                  
Scanner sc = new Scanner(new FileInputStream("example.txt"));     // 读取文件信息，返回 String 数据类型

sc.hasNextInt();

int n = sc.nextInt();                                            // 截取数据并自动转化数据类型
String str = sc.nextLine();                                      // 取出行内全部数据

sc.close();                                                      // 关闭 Scanner 类
```

- [NIO](https://delaube1.github.io/#/javase/IO/NIO?id=nio)

- - [基本概念](https://delaube1.github.io/#/javase/IO/NIO?id=基本概念)

  - - [IO 模型](https://delaube1.github.io/#/javase/IO/NIO?id=io-模型)
    - [NIO 模式](https://delaube1.github.io/#/javase/IO/NIO?id=nio-模式)
    - [Netty](https://delaube1.github.io/#/javase/IO/NIO?id=netty)

  - [Netty](https://delaube1.github.io/#/javase/IO/NIO?id=netty-1)

  - - [Netty 框架](https://delaube1.github.io/#/javase/IO/NIO?id=netty-框架)

# [NIO](https://delaube1.github.io/#/javase/IO/NIO?id=nio)

------

## [基本概念](https://delaube1.github.io/#/javase/IO/NIO?id=基本概念)

### [IO 模型](https://delaube1.github.io/#/javase/IO/NIO?id=io-模型)

- **BIO 同步阻塞**

在服务器和客户端通信的过程中，服务器线程会一直等待请求结果返回，无法处理其他请求。

- **NIO 同步非阻塞**

在服务器和客户端通信的过程中，服务器线程可以先处理其他请求，定时检查结果是否返回。

- **AIO 异步非阻塞**

在服务器和客户端通信的过程中，服务器线程可以先处理其他请求，客户端会主动通知服务器返回了结果。

### [NIO 模式](https://delaube1.github.io/#/javase/IO/NIO?id=nio-模式)

BIO 通信通常使用线程池机制实现伪异步：每建立一个连接就创建一个线程，在执行读写操作时该线程将被阻塞，直到数据流读写完成。在高并发情况下会有大量线程被创建并阻塞、CPU 将频繁切换线程，非常消耗计算机资源。

因此 JDK 1.4 引入了 NIO 模型，相关类存储在 java.nio 文件夹内，使用时需要进行导入。NIO 模型中，在执行读写操作时数据会先存入缓冲区，该线程可以先处理其他连接，一定时间后再对缓冲区读取或写出。

- **Buffer**：【缓冲区】暂存将要写入或者要读出的数据。
- **Channel**：【全双工通道】对缓冲区数据读写，在通道内部支持同时读写。
- **Selector**：【选择器】用于单线程同时管理多个通道，选择器会对多个客户进行轮询，使一个线程可以同时处理多个请求。

JDK 1.7 引入了 AIO 模型，相关类存储在 java.aio 文件夹内。但在 Linux 底层 AIO 实现本质仍为轮询，所以 AIO 相比于 NIO 的性能提升非常有限。目前主流的 IO 模式仍为 NIO 。

### [Netty](https://delaube1.github.io/#/javase/IO/NIO?id=netty)

Java 提供的 NIO 编程非常复杂，开发工作量和难度巨大。且可能会产生空轮询，导致 CPU 占用率 100% 。

于是我们引入了 Netty 开源框架封装 NIO 通信，是目前主流的使用方式。用于开发高性能高并发的 IO 程序。

------

## [Netty](https://delaube1.github.io/#/javase/IO/NIO?id=netty-1)

### [Netty 框架](https://delaube1.github.io/#/javase/IO/NIO?id=netty-框架)

但 NIO 编程复杂自行实现 bug 极多，目前主流的 NIO 通信使用 Netty 开源框架。

```java
public class NettyOioServer {

    public void server(int port) throws Exception {
        final ByteBuf buf = Unpooled.unreleasableBuffer(
                Unpooled.copiedBuffer("Hi!\r\n", Charset.forName("UTF-8")));
        EventLoopGroup group = new OioEventLoopGroup();
        try {
            ServerBootstrap b = new ServerBootstrap();        // 负责连接的池

            b.group(group)                                    //2
             .channel(OioServerSocketChannel.class)
             .localAddress(new InetSocketAddress(port))
             .childHandler(new ChannelInitializer<SocketChannel>() {    // 初始化
                 @Override
                 public void initChannel(SocketChannel ch) 
                     throws Exception {
                     ch.pipeline().addLast(new ChannelInboundHandlerAdapter() {            //4
                         @Override
                         public void channelActive(ChannelHandlerContext ctx) throws Exception {
                             ctx.writeAndFlush(buf.duplicate()).addListener(ChannelFutureListener.CLOSE);//5
                         }
                     });
                 }
             });
            ChannelFuture f = b.bind().sync();  //6
            f.channel().closeFuture().sync();
        } finally {
            group.shutdownGracefully().sync();        //7
        }
    }
}
```