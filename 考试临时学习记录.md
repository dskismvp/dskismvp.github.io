预测:pdf面试题    ,java  ,mysql ,mybatis,  注解,简答题,编程题

```xml
<!--    开启二级缓存
    映射语句文件中所有的select的语句的结果将会被缓存
    映射语句文件中的所有insert,update,和delete语句会刷新缓存
    缓存会使用最近最少算法(LRU) 算法来清除不需要的缓存
    缓存不定时刷新(也就是没有刷新间隔问题)
    缓存会保存列表或对象的1024个引用
    缓存会被视为读/写缓存.这意味着获得到的对象并不是共享的,可以昂区的调用和修改,而不干扰其他调用者或
    线程所做的潜在修改
    <cacher eviction ="LRU"  缓存回收策略
                               1.LRU最近最少使用
                               2.FIFO 先进先出
                               3.SOUT 软引用
                               4.WEAK 硬引用
    flushInterval="60000" 刷新间隔
    size="1024"  引用数组
    readOnly="true" 只读
    type="" 自定义缓存的全类名>

        设置缓存
        1.全局缓存设置
        2.配置使用二级缓存
        3.pojo需要实现序列化接口

-->
```

```xml
<mapper namespace="cn.etg.mybatisdynamic.mapper.TeacherMapper">

<!--    动态sql模拟switch-->
    <select id="findByCondition" resultType="cn.etg.mybatisdynamic.pojo.entity.Teacher">
        select  * from teacher
        <where>
            <choose>
                <when test="id!=null">id=#{id}</when>
                <when test="name!=null">name=#{name}</when>
                <when test="gender!=null">gender=#{gender}</when>
                <when test="job!=null">job=#{job}</when>
                <when test="gender!=null">gender=#{gender}</when>
               <otherwise>
                   subject_id=2
               </otherwise>
            </choose>
        </where>

    </select>
    <select id="findByTeacher" resultType="cn.etg.mybatisdynamic.pojo.entity.Teacher">

        select * from teacher
        <foreach collection="ids" item="item_id" separator=","  open=" where id in (" close=")">
            #{item_id}
        </foreach>

    </select>
    <select id="findByTeachers" resultType="cn.etg.mybatisdynamic.pojo.entity.Teacher">
        select * from teacher
        <foreach collection="ids" item="item_id" separator="," open=" where id in (" close=")">
            #{item_id}
        </foreach>
    </select>
</mapper>
```

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="cn.etg.passport.mapper.AdminMapper">
   <insert id="batchInsert" useGeneratedKeys="true" keyProperty="id">
        insert into  ams_admin_role (admin_id,role_id)  values
      <foreach collection="array" separator="," item="item_ar" >
         (#{item_ar.adminId},#{item_ar.roleId})
      </foreach>
   </insert>

   <resultMap id="adminLoginInfoVo" type="cn.etg.commons.pojo.vo.AdminLoginInfoVo">
      <id property="id" column="id"></id>
      <result property="username" column="username"></result>
      <result property="password" column="password"></result>
      <result property="enable" column="enable"></result>
      <collection property="permissions" ofType="String">
          <result column="value"></result>
      </collection>
   </resultMap>

   <select id="getLoginInfoByUserName" resultMap="adminLoginInfoVo">

      SELECT aa.id id, aa.username username, aa.password password, aa.enable enable, ap.value value
      from   ams_admin           aa
                JOIN   ams_admin_role      aar
                on     aa.id=aar.admin_id
                JOIN   ams_role            ar
                ON     ar.id=aar.role_id
                JOIN   ams_role_permission arp
                ON     arp.role_id=ar.id
                JOIN   ams_permission      ap
                ON         ap.id=arp.permission_id
      WHERE  aa.username=#{username};
   </select>


</mapper>
```

```xml
<mapper namespace="cn.etg.mybatissql.mapper.TeacherMapper">

    <resultMap id="teacher" type="cn.etg.mybatissql.pojo.entity.Teacher">
        <id property="id" column="id"></id>
        <result property="name" column="name"></result>
        <result property="gender" column="gender"></result>
        <result property="job" column="job"></result>
        <result property="subjectId" column="subject_id"></result>
    </resultMap>

    <select id="selectById" resultMap="teacher">
        select  * from teacher where id=#{id}
    </select>
<!--    查询字段的别名VO和javabean的属性对应,才能使用resultType-->
    <select id="selectTeacherAndSubject" resultType="cn.etg.mybatissql.pojo.vo.TeacherSubjectVo">
        SELECT t.name name ,s.name subjectName,t.gender gender ,t.job job
                        from teacher t
                        join  subject s
                        on t.subject_id=s.id
    </select>

    <resultMap id="teasubvo" type="cn.etg.mybatissql.pojo.vo.TeaSubVo">
        <id property="id" column="id" ></id>
        <result column="name" property="name"></result>
        <result column="gender" property="gender"></result>
        <result column="job" property="job"></result>
        <association property="subject" javaType="cn.etg.mybatissql.pojo.entity.Subject">
            <id property="id" column="id"></id>
            <result property="name" column="subjectName"></result>
        </association>
    </resultMap>

    <select id="selectTeaAndSubject" resultMap="teasubvo">
        SELECT t.id id, t.name name ,s.name subjectName,t.gender gender ,t.job job
                        from teacher t
                        join  subject s
                        on t.subject_id=s.id
    </select>




    <resultMap id="stuclass" type="cn.etg.mybatissql.pojo.vo.StudentAndClassItemVo">
        <id property="id" column="id" ></id>
        <result column="name" property="name"></result>
        <collection property="students" ofType="cn.etg.mybatissql.pojo.entity.Student">
            <id property="id" column="id"></id>
            <result property="name" column="name"></result>
            <result property="age" column="age"></result>
            <result property="gender" column="gender"></result>
        </collection>
    </resultMap>
    <select id="selectStuAndClass" resultMap="stuclass">
        select c.id id, c.name name,  s.name  name,s.age age,s.gender gender
                        from  student s
                        join  class c
                        on  s.id=c.stu_id
                        where  c.name=#{classname}
    </select>


    <select id="selectStuClass" resultType="cn.etg.mybatissql.pojo.vo.StudentClassItemVo">
        select  c.name cname,  s.name  sname,s.age age,s.gender gender
                        from  student s
                        join  class c
                        on  s.id=c.stu_id
        where  c.name=#{classname}
    </select>

    <resultMap id="clst" type="cn.etg.mybatissql.pojo.vo.ClassListStuTeaVo">
        <id column="id" property="id"></id>
        <result column="cname" property="cname"></result>

        <collection property="students" ofType="cn.etg.mybatissql.pojo.entity.Student">
            <id property="id" column="sid"></id>
            <result property="name" column="sname"></result>
            <result property="age" column="sage"></result>
            <result property="gender" column="sgender"></result>
        </collection>
        <collection property="teachers" ofType="cn.etg.mybatissql.pojo.entity.Teacher">
            <id property="id" column="tid"></id>
            <result property="name" column="tname"></result>
            <result property="job" column="job"></result>
            <result property="gender" column="tgender"></result>
            <result property="subjectId" column="subid"></result>
        </collection>

    </resultMap>


    <select id="selectCLSTV" resultMap="clst">
        select c.name cname ,s.name sname ,s.age sage, s.gender sgender,t.name tname ,t.gender tgender,t.job job,t.subject_id subid,s.id sid,t.id tid
                        from class c
                        join  student s
                        on c.stu_id=s.id
                        join teacher t
                        on c.teach_id=t.id
    </select>


</mapper>
```

```xml
<mapper namespace="cn.etg.mybatisdynamic.mapper.StudentMapper">
<!--    批量插入

        ("tom",12,"女"),
        ("tom",12,"女")
-->
    <insert id="insert">
        insert into student (name,age,gender) values
        <foreach collection="students" separator="," item="item_stu" >
            (#{item_stu.name},#{item_stu.age},#{item_stu.gender})
        </foreach>


    </insert>

    <!--    动态sql-->
   <select id="findByCondition" resultType="cn.etg.mybatisdynamic.pojo.entity.Student">
       select  *
        from student

        <where>

              <if test="id!=null">
             and   id=#{id}
              </if>

           <if test="name!=null">
               and  name=#{name}
           </if>
          <if test="age!=null">
              and  age=#{age}
          </if>
        <if test="gender!=null">
            and  gender=#{gender}
        </if>

        </where>
    </select>
<!--    trim去空白
        prefix 给拼接串的整个字符串添加一个前缀
        suffixOverrides: 去掉整个字符串后面多余的字符 支持(|)符号
-->
    <select id="findByConditions" resultType="cn.etg.mybatisdynamic.pojo.entity.Student">
        select * from student
        <trim prefix="where" suffixOverrides="AND | OR">
                <if test="id!=null">
                    id=#{id} and
                </if>
            <if test="name!=null">
                name=#{name} and
            </if>
            <if test="gender!=null">
                gender=#{gender} and
            </if>

        </trim>
    </select>

    <update id="updateByCondition" >

        update student
        <set>
            <if test="name !=null">name = #{name},</if>
            <if test="age!=null">age=#{age},</if>
            <if test="gender!=null"> gender=#{gender}</if>
        </set>
        where id=#{id}
    </update>
    <update id="updateByConditions">
        update student
        <trim prefix="set" suffixOverrides=",">
            <if test="name !=null">name = #{name},</if>
            <if test="age!=null">age=#{age},</if>
            <if test="gender!=null"> gender=#{gender},</if>
        </trim>
        where id=#{id}

    </update>

</mapper>
```

```xml
<mapper namespace="cn.etg.mapper.StudentDao">
<!-- id是方法名 resultType返回结果的全序列名-->
    <select id="selectAll" resultType="cn.etg.entity.Student">
        select * from student
    </select>

    <insert id="add"  >
        insert into student (name,age,gender) value (#{name},#{age},#{gender})
    </insert>
    <insert id="insert">
        <selectKey keyProperty="id" resultType="int" keyColumn="id" order="AFTER">
            select LAST_INSERT_ID();
        </selectKey>
        insert into student(name,age,gender)value(#{name},#{age},#{gender})
    </insert>
<!--主键回填-->
    <select id="selectById" resultType="cn.etg.entity.Student">
        select * from student where id=#{id}
    </select>

    <update id="update" >
        update  student set age=#{age} where id=#{id}
    </update>

    <delete id="del">
        delete from student where id=#{id}
    </delete>

    <select id="selectByNameLike" resultType="cn.etg.entity.Student">
        select  * from student where name like #{str}
    </select>

    <select id="selectByNameLike1" resultType="cn.etg.entity.Student">
        select  * from student where name like '${str}%'
    </select>

    <select id="selectByPage" resultType="cn.etg.entity.Student">
        select  * from student limit #{arg0},#{arg1}
    </select>

    <select id="selectByPage1"  resultType="cn.etg.entity.Student">
        select  * from student limit #{pageStart},#{pageSize}

    </select>
    <select id="selectByPage2" resultType="cn.etg.entity.Student" parameterType="cn.etg.entity.PageInfo">
        select  * from student limit #{pageStart},#{pageSize}
    </select>
    <select id="selectByPage3" resultType="cn.etg.entity.Student" >
        select  * from student limit #{pageInfo.pageStart},#{pageInfo.pageSize}
    </select>
    <select id="selectByPage4" resultType="cn.etg.entity.Student" parameterType="java.util.Map">
        select  * from student limit #{pageStart},#{pageSize}
    </select>
    <select id="countStudent" resultType="java.lang.Integer">
        select count(*) from student
    </select>

</mapper>
```

```java
@Test
public  void  insertTest() throws IOException {

    SqlSession sqlSession = getSqlSession();
    StudentDao mapper = getStuDao(sqlSession);
    Student student = new Student("zz", 18, "n");
    int insert = mapper.insert(student);
    sqlSession.commit();
    System.out.println(insert);
    close(sqlSession);
}
```

```java
@Test
public  void divideTest4() throws IOException {
    InputStream resourceAsStream = Resources.getResourceAsStream("SqlMapConfig.xml");
    SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder();
    SqlSessionFactory factory = builder.build(resourceAsStream);
    SqlSession sqlSession = factory.openSession();
    StudentDao mapper = sqlSession.getMapper(StudentDao.class);

    Map<String,Integer> pageInfo = new HashMap<>();
    pageInfo.put("pageStart",3);
    pageInfo.put("pageSize",3);
    List<Student> students = mapper.selectByPage4(pageInfo);
    students.forEach(System.out::println);
    sqlSession.close();
    resourceAsStream.close();
}
```

```xml
<settings>
    <setting name="cacheEnabled" value="true"/>
</settings>
```

```xml
<!--    开启缓存-->
    <cache/>
```

```yaml
mybatis:
  mapper-locations: classpath:/mappers/**/*.xml
```

```java
@MapperScan("cn.etg.mybatiscache.mapper")
```

```xml
<resultMap id="listPP" type="cn.etg.homework.pojo.vo.UserDeptRoleVo">
        <result property="userName" column="userName"></result>
        <result property="nickName" column="userName"></result>
        <result property="status" column="status"></result>
        <result property="deptName" column="deptName"></result>
        <collection property="roles" ofType="cn.etg.homework.pojo.entity.Role">
                <result property="roleName" column="roleName"></result>

        </collection>
</resultMap>


<select id="list" resultMap="listPP">
        select  u.user_name userName,u.nick_name userName,u.`status` status,d.dept_name deptName,rr.role_name roleName
        from sys_user u
        join sys_dept d
        on  u.dept_id=d.dept_id
        join sys_user_role r
        on  r.role_id=u.user_id
        join sys_role rr
        on rr.role_id=r.role_id

</select>

<select id="findById" resultMap="listPP">
        select  u.user_name userName,u.nick_name userName,u.`status` status,d.dept_name deptName,rr.role_name roleName
        from sys_user u
        join sys_dept d
        on  u.dept_id=d.dept_id
        join sys_user_role r
        on  r.role_id=u.user_id
        join sys_role rr
        on rr.role_id=r.role_id
        where u.user_id=#{id}
</select>
<insert id="add">
        insert into sys_user (dept_id,user_name,nick_name,status) value (#{deptId},#{userName},#{nickName},#{status})
    </insert>

    <delete id="del">
        delete from sys_user where user_id=#{id}
    </delete>
```

```yaml
spring:
  redis:
    host: localhost
    database: 0
    port: 6379
    password:
    connect-timeout: 3000ms
    lettuce:
      pool:
        max-active: 8
        max-idle: 8
        min-idle: 0
        max-wait: -1ms
```

```java
package cn.etg.bootreds.demo.config;

import cn.etg.bootreds.demo.service.RedisService;
import cn.etg.bootreds.demo.service.impl.RedisServiceImpl;
import com.fasterxml.jackson.annotation.JsonAutoDetect;
import com.fasterxml.jackson.annotation.PropertyAccessor;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.jsontype.impl.LaissezFaireSubTypeValidator;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;
import org.springframework.data.redis.serializer.RedisSerializer;
import org.springframework.data.redis.serializer.StringRedisSerializer;
import org.springframework.data.redis.support.collections.RedisCollectionFactoryBean;

/**
 * @Author ShaoKangDong
 * @ClassName RedisConfig
 * @Date 2023-12-04-9:23
 * @PackageName cn.etg.bootreds.demo.config
 * @Description
 */
@Configuration
public class RedisConfig {

    @Bean
    public RedisTemplate<String,Object> redisTemplate(RedisConnectionFactory redisConnectionFactory){
        RedisSerializer<Object> serializer=redisSerializer();
        RedisTemplate<String,Object> redisTemplate=new RedisTemplate<>();
        redisTemplate.setConnectionFactory(redisConnectionFactory);
        redisTemplate.setKeySerializer(new StringRedisSerializer());
        redisTemplate.setValueSerializer(serializer);
        redisTemplate.setHashKeySerializer(new StringRedisSerializer());
        redisTemplate.setHashValueSerializer(serializer);
        redisTemplate.afterPropertiesSet();
        return  redisTemplate;
    }
    @Bean
    public RedisSerializer<Object> redisSerializer(){
        Jackson2JsonRedisSerializer<Object> serializer=new Jackson2JsonRedisSerializer<Object>(Object.class);
        ObjectMapper objectMapper=new ObjectMapper();
        objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
        objectMapper.activateDefaultTyping(LaissezFaireSubTypeValidator.instance,ObjectMapper.DefaultTyping.NON_FINAL);
        serializer.setObjectMapper(objectMapper);
        return serializer;
    }

    @Bean
    public RedisService redisService(){
        return new RedisServiceImpl();
    }
}
```

```java
package cn.etg.bootreds.demo.service.impl;

import cn.etg.bootreds.demo.service.RedisService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.TimeUnit;

/**
 * @Author ShaoKangDong
 * @ClassName RedisServiceImpl
 * @Date 2023-12-04-10:01
 * @PackageName cn.etg.bootreds.demo.service.impl
 * @Description
 */
public class RedisServiceImpl implements RedisService {

    @Autowired
    private RedisTemplate<String,Object> redisTemplate;

    @Override
    public void set(String key, Object value, long time) {
        redisTemplate.opsForValue().set(key,value,time, TimeUnit.SECONDS);
    }

    @Override
    public void set(String key, Object object) {
        redisTemplate.opsForValue().set(key,object);
    }

    @Override
    public Object get(String key) {
        return  redisTemplate.opsForValue().get(key);
    }

    @Override
    public Boolean del(String key) {

        return redisTemplate.delete(key);
    }

    @Override
    public Set<String> keys() {

        return redisTemplate.keys("*");
    }

    @Override
    public Boolean expire(String key, long time) {

        return redisTemplate.expire(key,time,TimeUnit.SECONDS);
    }

    @Override
    public Long getExpire(String key) {

        return redisTemplate.getExpire(key);
    }

    @Override
    public Boolean hashKey(String key) {
        return redisTemplate.hasKey(key);
    }

    @Override
    public Long incr(String key, long delta) {
        return redisTemplate.opsForValue().increment(key,delta);
    }

    @Override
    public Long decr(String key, long delta) {
        return redisTemplate.opsForValue().decrement(key,delta);
    }

    @Override
    public void hSet(String key, String field, Object value) {
        redisTemplate.opsForHash().put(key,field,value);
    }

    @Override
    public Object hGet(String key, String field) {
        return redisTemplate.opsForHash().get(key,field);
    }

    @Override
    public Map<Object, Object> hGetAll(String key) {
        return redisTemplate.opsForHash().entries(key);
    }

    @Override
    public Boolean hSetAll(String key, Map<String, Object> map, long time) {
        redisTemplate.opsForHash().putAll(key,map);
        return expire(key,time);
    }

    @Override
    public void hDel(String key, Object... hashKey) {
         redisTemplate.opsForHash().delete(key,hashKey);
    }

    @Override
    public Set<Object> sMembers(String key) {
        return redisTemplate.opsForSet().members(key);
    }

    @Override
    public Long sAdd(String key, long time, Object... value) {
        return redisTemplate.opsForSet().add(key,time,value);
    }

    @Override
    public Boolean sIsMember(String key, Object value) {
        return redisTemplate.opsForSet().isMember(key,value);
    }

    @Override
    public Long sSize(String key) {
        return redisTemplate.opsForSet().size(key);
    }

    @Override
    public Long sMove(String key, Object... value) {
        return redisTemplate.opsForSet().remove(key,value);
    }

    @Override
    public List<Object> lRange(String key, long start, long end) {
        return redisTemplate.opsForList().range(key,start,end);
    }

    @Override
    public Long lSize(String key) {
        return redisTemplate.opsForList().size(key);
    }

    @Override
    public Object lIndex(String key, Long index) {
        return redisTemplate.opsForList().index(key,index);
    }

    @Override
    public Long lPush(String key, long time, Object value) {
        Long index= redisTemplate.opsForList().leftPush(key,value);
        expire(key,time);
        return index;

    }

    @Override
    public Long lPushAll(String key, Object... value) {
        return redisTemplate.opsForList().leftPushAll(key,value);
    }

    @Override
    public Long lRemove(String key, long count, Object value) {
        return redisTemplate.opsForList().remove(key,count,value);
    }
}
```

```java
package cn.etg.bootreds.demo.service;

import com.sun.org.apache.xpath.internal.operations.Bool;
import io.micrometer.core.instrument.step.StepRegistryConfig;

import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 * @Author ShaoKangDong
 * @ClassName RedisService
 * @Date 2023-12-04-10:01
 * @PackageName cn.etg.bootreds.demo.service
 * @Description
 */
public interface RedisService {
    void set(String key,Object value,long time);
    void set(String key,Object object);
    Object  get (String key);
    Boolean del(String key);
    //参看所有key
    Set<String> keys();
    Boolean expire(String key ,long time);
    Long getExpire(String key);
    Boolean hashKey(String key);
    //自增
    Long incr(String key,long delta);
    Long decr(String ket ,long delta);
    //设置hashSet
    void hSet(String key ,String field ,Object value);
    Object hGet(String key ,String field);
    Map<Object,Object> hGetAll(String key);
    Boolean hSetAll(String key ,Map<String,Object> map,long time);
    void hDel(String key,Object...hashKey);
    Set<Object> sMembers(String key);
    //可变参数相对于==>Object[] values
    //只能放在结尾
    Long sAdd(String key,long time,Object...value);
    Boolean sIsMember(String key,Object value);
    Long sSize(String key);
    Long sMove(String key ,Object...value);
    //list操作
    List<Object> lRange(String key,long start,long end);
    Long lSize(String key);
    Object lIndex(String key,Long index);
    Long lPush(String key,long time,Object value);
    Long lPushAll(String key ,Object...value);
    Long lRemove(String key,long count ,Object value);
}
```

```java
@Component
@ConfigurationProperties(prefix = "jdbc")
public class JDBCConfig {


    private     String driver  ;
    private String url   ;
    private String username;
    private String password;

    public String getDriver() {
        return driver;
    }

    public void setDriver(String driver) {
        this.driver = driver;
    }

    public String getUrl() {
        return url;
    }

    public void setUrl(String url) {
        this.url = url;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    @Override
    public String toString() {
        return "JDBCConfig{" +
                "driver='" + driver + '\'' +
                ", url='" + url + '\'' +
                ", username='" + username + '\'' +
                ", password='" + password + '\'' +
                '}';
    }
}
```

```yaml
jdbc:
  driver: sqlServer.driver
  url: jdbc:mysql://pro
  username: admin
  password: 123456

```

```yaml
spring:
  profiles:
    active: pro
```

```java
//数据库连接工具类
public class DBUtil {

    public  static Connection getConn(String dbname){
        Connection conn=null;
        String url="jdbc:mysql://localhost:3306/"+dbname+"?characterEncoding=utf8&useSSL=false&serverTimezone=Asia/Shanghai&rewriteBatchedStatements=true";
        try {
            Class.forName("com.mysql.cj.jdbc.Driver");
            conn = DriverManager.getConnection(url, "root", "ROOT");

        }catch (SQLException|ClassNotFoundException e){
            e.printStackTrace();
        }
        return conn;

    }


}
```

```java
import java.sql.*;

/**
 * JDBC java数据库连接       java DataBase Connectivvity
 *
 * JDBC 是java官方提供的一套结构,用于连接DBMS并进行行相关操作
 * 核心接口:
 * Connection 表示数据库连接
 * Statement        用来执行sql语句的语句对象
 * PreparedStatement    用来执行预编译sql语句的语句对象
 * ResultSet       用来表示查询结果集
 *
 * 不同的DBMS 提供上都会提供一套具体的实体类,并打包为jar,那么这个jar包被我们称为
 * 是连接该DBMS的驱动(Driver)
 *
 */
public class JDBCDemo {


    public static void main(String[] args) {
        try {
            //不同的上课数据库Driver的内容不同
            //1加载驱动
            Class.forName("com.mysql.cj.jdbc.Driver");
            //2.与数据库建立连接
            String url="jdbc:mysql://localhost:3306/db0?characterEncoding=utf8&useSSL=false&serverTimezone=Asia/Shanghai&rewriteBatchedStatements=true";

            Connection connection = DriverManager.getConnection(url,"root","ROOT");
            //测试连接
            System.out.println(connection);

            //通过连接数据库,创建用于执行sql语句的语句对象
            //3DDL语句
            String sql="create table userinfo (id int(10) primary key auto_increment, username varchar(30) ,password varchar(30),nickname varchar(30) ,age int(3)  )";

            //Statement   提供多种执行sql的方法
            /**
             * boolean execute(String sql)
             * 用于向数据库执行的sql语句,该方法可以执行任何类型的sql
             * 但实际上执行DML,DQL都有专门的方法,因此该execute通常用来执行DDL
             *
             * 该方法返回一个booolean值,执行该sql后是否产生查询结果集
             *
             */
            //获得Statement执行sql方法
            Statement statement = connection.createStatement();
            //4执行DDL语句
            statement.execute(sql);
            System.out.println("创建表userinfo完毕");
            //5关闭连接
            connection.close();

        } catch (SQLException | ClassNotFoundException e) {
            e.printStackTrace();
        }finally {

        }
    }

}
```

```java
try{
    Class.forName("com.mysql.cj.jdbc.Driver");
    String url="jdbc:mysql://localhost:3306/db0?characterEncoding=utf8&useSSL=false&serverTimezone=Asia/Shanghai&rewriteBatchedStatements=true";
    Connection connection = DriverManager.getConnection(url, "root", "ROOT");
    Statement statement = connection.createStatement();
    String sql="insert into userinfo (username,password,nickname,age) value  ('Bob','123456','bb',18)";
   //executeUpdate用来执行增加修改删除语句

    //通过控制台输入姓名密码昵称年龄

    String password,niackname,age,name;
    Scanner sc=new Scanner(System.in);
    System.out.println("请输入名字");
    name=sc.next();
    System.out.println("请输入密码");
    password=sc.next();
    System.out.println("请输入昵称");
    niackname=sc.next();
    System.out.println("请输入年龄");
    age=sc.next();

    String sql1="insert into userinfo (username,password,nickname,age) value ( '"+name+"','"+password+"','"+niackname+"','"+age+"')";

    int i1 = statement.executeUpdate(sql1);
    System.out.println("i1:"+i1);

    //int i=statement.executeUpdate(sql);
    //i代表影响的条数
    //statement.execute(sql);
    int i=statement.executeUpdate(sql);
    System.out.println("插入完毕");
    System.out.println(i);
    connection.close();

}catch (Exception e){
    e.printStackTrace();
}
```

```java
public static void main(String[] args) {
    Connection connection =null;
    //修改某个用户的密码
    try {
        Class.forName("com.mysql.cj.jdbc.Driver");
        String url="jdbc:mysql://localhost:3306/db0?characterEncoding=utf8&useSSL=false&serverTimezone=Asia/Shanghai&rewriteBatchedStatements=true";
        connection = DriverManager.getConnection(url, "root", "ROOT");
        Statement statement = connection.createStatement();
        String sql="update userinfo set password=1298 where id=2";
        int i = statement.executeUpdate(sql);
        System.out.println("更新完毕");
        System.out.println(i);



    } catch (Exception e) {
        e.printStackTrace();
    }finally {
        try {
            connection.close();
        } catch (SQLException throwables) {
            throwables.printStackTrace();
        }
    }

}
```

```java
public static void main(String[] args) {
    //查询所有 控制台打印输出结果
    Connection connection=DBUtil.getConn("db0");

    try {
        Statement statement = connection.createStatement();
        String sql="select * from userinfo";
        //查询语句使用executeQuery方法返回ResultSet
        ResultSet resultSet = statement.executeQuery(sql);
       while (resultSet.next()){
           String username = resultSet.getString("username");
           String password = resultSet.getString("password");
           String nickname = resultSet.getString("nickname");

           int age = resultSet.getInt("age");
           System.out.println(username+","+password+","+nickname+","+age);
       }

    } catch (SQLException e) {
        e.printStackTrace();
    }finally {

    }

}
```

```java
Statement statement = connection.createStatement();
String sql=" select t.name as tname,t.gender as gender,c.name as cname,c.floor as floor\n" +
        "     from teacher t\n" +
        "     join class c\n" +
        "     on c.teacher_id=t.id\n" +
        "     where t.name=\"张久军\"";
ResultSet resultSet = statement.executeQuery(sql);

while (resultSet.next()){

    String sname = resultSet.getString("tname");
    String sgender = resultSet.getString("gender");
    String cname = resultSet.getString("cname");
    String cfoor = resultSet.getString("floor");
    System.out.println(sname+","+sgender+","+cname+","+cfoor);


}
connection.close();
```

```java
try(
        Connection connection=DBUtil.getConn("db0");
        ){
    Statement statement = connection.createStatement();
    Scanner sc=new Scanner(System.in);
    System.out.println("请输入用户名");
    String name=sc.next();
    System.out.println("请输入密码");
    String password=sc.next();
    //SQL注入攻击
    String sql="select nickname\n" +
            "     from userinfo\n" +
            "     where username='"+name+"' and password='"+password+"' or '1'='1'";
    ResultSet resultSet = statement.executeQuery(sql);

    if(resultSet.next()){
        String nickname=resultSet.getString("nickname");
        System.out.println("登录成功,欢迎您"+nickname);
    }else{
        System.out.println("登录失败,用户名或密码不正确");
    }



}catch (Exception e){
    e.printStackTrace();
}
```

```java
public static void main(String[] args) {
    String sql="select * from userinfo where username=? and password=?";
    try (
            Connection connection=DBUtil.getConn("db0")
            ){
        //创建预编译sql语句对象,先要将预编译sql发送给数据库要求器理解语义
        PreparedStatement preparedStatement = connection.prepareStatement(sql);
        Scanner sc=new Scanner(System.in);
        System.out.println("请输入用户名");
        String name=sc.next();
        System.out.println("请输入密码");
        String password=sc.next();
        //执行该sql前要指明预编译sql中"?"的值是什么?
        //?是什么数据类型的值,这里调用对应的set方法
        /**
         * 例如
         * ?表示整数,调用ps.setInt()
         * ?表示字符串 ps.setString(
         * 方法的第一个参数表示预编译ssl中的第几个?
         * ?从左到右,从上到下开始并且从1开始,1表示第一个问号
         *
         *
         *
         */
        preparedStatement.setString(1,name);
        preparedStatement.setString(2,password);
        ResultSet resultSet = preparedStatement.executeQuery();

        if(resultSet.next()){
            String nickname = resultSet.getString("nickname");
            System.out.println("登录成功,欢迎您"+nickname);
        }else{
            System.out.println("登录失败,用户名或密码不正确");
        }

    }catch (Exception e){
         e.printStackTrace();
    }


}
```

```java
public static void main(String[] args) {

    Scanner sc=new Scanner(System.in);
    System.out.println("开始注册");
    System.out.println("输入姓名");
    String name =sc.next();
    System.out.println("输入密码");
    String password=sc.next();
    System.out.println("输入昵称");
    String nickname=sc.next();
    System.out.println("输入年龄");
    int age = sc.nextInt();


    try (Connection conn=DBUtil.getConn("db0")){
        String sql = " insert into userinfo (username , password, nickname, age) value (?,?,?,?)";
        PreparedStatement preparedStatement = conn.prepareStatement(sql);
        preparedStatement.setString(1,name);
        preparedStatement.setString(2,password);
        preparedStatement.setString(3,nickname);
        preparedStatement.setInt(4,age);
        int i = preparedStatement.executeUpdate();
        if(i>0){
            System.out.println("注册成功");
        }else{
            System.out.println("注册失败");
        }

    }catch (SQLException e){
        e.printStackTrace();
    }




}
```

```java
public static void main(String[] args) {
    Scanner sc=new Scanner(System.in);
    System.out.println("请输入年级");
    int grade = sc.nextInt();
    System.out.println("请输入班级");
    int cls=sc.nextInt();
    String name= grade+"年级"+cls+"班";
    String sql="select id,floor from class where name=?";
    try (Connection conn=DBUtil.getConn("dbsmg")){
        PreparedStatement preparedStatement = conn.prepareStatement(sql);
        preparedStatement.setString(1,name);
        ResultSet resultSet = preparedStatement.executeQuery();
        if(resultSet.next()){
            int id = resultSet.getInt("id");
            int floor = resultSet.getInt("floor");
            System.out.println("班级id:"+id+" 楼 层:"+floor);
        }else{
            System.out.println("您输入的班级不存在");
        }
    }catch (SQLException e){
        e.printStackTrace();
    }

}
```

```java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)//注解的生命周期
public @interface MyAnno {
    public String value();
}
```

```java
public class AnnoDemo {

    public static void main(String[] args) throws Exception {

        //创建User类对象
        Class uu=User.class;
        //uu.newInstance();
        Method mm=uu.getMethod("show");
        //验证这个方法上面是否有注解
        boolean b=mm.isAnnotationPresent(MyAnno.class);
        System.out.println(b);
        MyAnno anno= mm.getAnnotation(MyAnno.class);
        System.out.println(anno.value());


    }

}

class User{
    public User(){}
    @MyAnno("my annotation")
    public void show(){
        System.out.println("hello");
    }


}
```

```java
  //创建集合对象
        Collection coll=new ArrayList();
        //boolean add(E e);元素添加到集合中,成功返回true
        coll.add("one");
//判断集合是否为空
System.out.println(coll.isEmpty());
//清空集合
coll.clear();
  boolean b= coll.contains(p);
        System.out.println(b);
        //移除和p相同的元素 remove( Object o)
        coll.remove(p);
```

```java
//创建
Collection c1=new HashSet();
c1.add("java");
c1.add("c");
c1.add("c++");
System.out.println(c1);
Collection c2 =new ArrayList();
c2.add("android");
c2.add("java");
c2.add("ios");
System.out.println(c2);
/*
boolean addAll(Collection c)
将给定的集合中的所有元素添加到当前集合中,当前集合若发生改变返回true
 */

boolean b= c1.addAll(c2);
```

```java
Collection c3=new ArrayList();
c3.add("ios");
c3.add("c++");
c3.add("php");
System.out.println(c3);
/**
 * booelean containAll(Collection c)
 * 判断当前集合是否包含给定集合所有元素
 */

boolean f=c1.containsAll(c3);
 c1.removeAll(c3);
```

```java
  Collection c=new ArrayList();
Iterator iterator = c.iterator();
while (iterator.hasNext()){
    String s=(String) iterator.next();
    System.out.println(s);
}
```

```java
LocalDate localDate= LocalDate.now();
System.out.println(localDate);
//获取指定时间
LocalDate of = LocalDate.of(2019, 10, 5);
System.out.println(of);

//获得年月日
int year=localDate.getYear();
Month m= localDate.getMonth();
int day=localDate.getDayOfMonth();
DayOfWeek dayOfWeek = localDate.getDayOfWeek();

System.out.println(year+"-"+m+"-"+day+"-"+dayOfWeek);

int year1=localDate.get(ChronoField.YEAR);
int month2=localDate.get(ChronoField.MONTH_OF_YEAR);
int dayw1=localDate.get(ChronoField.DAY_OF_WEEK);
int day1=localDate.get(ChronoField.DAY_OF_MONTH);

System.out.println(year1+"-"+month2+"-"+day1+"-"+dayw1);
```

```java
public class BRDemo {
    public static void main(String[] args) throws IOException {
        //创建文件输入流读取当前源代码文件
        //"./src/io/er/PWDemo2.java"
        //进入流链接,最终连接到BufferedReader
        //String  readLine() 按行读的方法
        //读取每一行字符串并输入到控制台

//        FileInputStream fis=new FileInputStream("./src/io/er/PWDemo2.java");
//        InputStreamReader isr=new InputStreamReader(fis);
//        BufferedReader br=new BufferedReader(isr);

        BufferedReader br=new BufferedReader(new InputStreamReader(new FileInputStream("./src/io/er/PWDemo2.java")));

        String line=null;
//        do{
//            line= br.readLine();
//            System.out.println(line);
//        }while(line!=null);
        while((line= br.readLine())!=null){
            System.out.println(line);
        }

        br.close();
    }
```

```java
public static void main(String[] args) throws IOException {
    InputStreamReader isr=new InputStreamReader(new FileInputStream("ows.txt"), StandardCharsets.UTF_8);
    int d=0;

    StringBuilder builder=new StringBuilder();
    while ((d=isr.read())!=-1){
        builder.append((char)d);
    }
    isr.close();
    System.out.println(builder.toString());


}
```

```java
public static void main(String[] args) throws IOException {
    //向文件ows.txt中写入数据
    OutputStreamWriter osw=new OutputStreamWriter(new FileOutputStream("ows.txt"));

    osw.write("夜空中最亮的星,照亮我前行");
    osw.write("夜空中最亮的星,照亮我前行");
    System.out.println("写入完毕");
    osw.close();

}
```

```java
public static void main(String[] args) throws FileNotFoundException {
    PrintWriter pw=new PrintWriter("pw.txt");
    pw.println("我祈祷拥有一颗透明的心灵,和会流泪的眼睛");
    pw.println("给我再去相信的勇气,越过黄昏去拥抱你");
    System.out.println("写出完毕");
    pw.close();
}
```

```java
public static void main(String[] args) throws FileNotFoundException {
    //流连接
    FileOutputStream fos =new FileOutputStream("pw2.txt");
    OutputStreamWriter ows =new OutputStreamWriter(fos, StandardCharsets.UTF_8);
    BufferedWriter bw =new BufferedWriter(ows);
    PrintWriter pw=new PrintWriter(bw,true);


    pw.println("你听着你昨天我们熟悉的街,");
    pw.println("把你准备好的台词全年一边");
    pw.close();



}
```

```java
public class PWDemo2 {
    public static void main(String[] args) throws FileNotFoundException {
        FileOutputStream fos=new FileOutputStream("note.txt");
        OutputStreamWriter osw=new OutputStreamWriter(fos, StandardCharsets.UTF_8);
        PrintWriter pw=new PrintWriter(osw,true);
        Scanner sc =new Scanner(System.in);
        String out=null;
        do{
            out=sc.nextLine();
            pw.println(out);
        }while(!out.equals("exit"));
        pw.close();
        System.out.println("记录成功");
    }
```

```java
public static void main(String[] args) throws IOException {
    //File访问当前项目目录下的demo.txt
    File file =new File("demo.txt");

    if(!file.exists()){
        //创建文件
        file.createNewFile();
        System.out.println("创建完毕");
    }
    String fileName =file.getName();
    System.out.println(fileName);
    //文件大小
    System.out.println(file.getAbsolutePath());

    long len= file.length();
    System.out.println(len);

    //验证可读可写
    System.out.println(file.canRead());
    System.out.println(file.canWrite());
    System.out.println(file.canExecute());

    //是否为隐藏文件
    System.out.println(file.isHidden());
    //获得文件的绝对路径
    System.out.println(file.getAbsolutePath());

    //获得路径
    System.out.println(file.getPath());


}
```

```java
File file=new File("test.txt");
if(file.exists()){
    System.out.println("文件已存在");
}else{
    file.createNewFile();
    System.out.println("文件创建成功");
}

 File file=new File("test.txt");
        if(file.exists()){
            file.delete();
            System.out.println("删除成功");
        }else{
            System.out.println("文件不存在");
        }


  File dir=new  File("demo");
        if(dir.exists()){
            System.out.println("文件夹已存在");
        }else{
            dir.mkdir();
            System.out.println("文件夹已创建");
        }
        //创建多层文件夹
        File dirs =new File("./a/b/c");
        dirs.mkdirs();


       //删除文件夹
        //删除空的文件夹
        File dir =new File("demo");
        dir.delete();
        System.out.println("删除目录");
```

```java
public static void main(String[] args) {
    //访问一个文件夹的所有子项
    //.表示当前文件夹 等同于./
    File dir =new File(".");
    if(dir.isDirectory()){
        File[] files=dir.listFiles();
        System.out.println("当前目录包含"+files.length+"个子项");
        //遍历子项
        for (int i = 0; i < files.length; i++) {
            File fs=files[i];
            System.out.println(fs.getName());

        }

    }

}
```

```java
public static void main(String[] args) {
    //获得当前文件夹
    File file=new File(".");
    //匿名内部类为参数
    File [] dirs= file.listFiles(new FileFilter() {
        @Override
        public boolean accept(File pathname) {
            return pathname.getName().endsWith("txt");
        }
    });
    File [] dirs1=file.listFiles(a->a.getName().endsWith("txt"));
    for(File d:dirs){
        System.out.println(d.getName());
    }
    for(File d:dirs1){
        System.out.println(d.getName());
    }
}
```

```java
public static void main(String[] args) throws IOException {
    FileOutputStream fos =new FileOutputStream("bos.txt");
    BufferedOutputStream bos =new BufferedOutputStream(fos);

    String line="明月几时有,把酒问青天";
    //字符串转字节数组,字符集使用utf-8
    byte[] a=line.getBytes(StandardCharsets.UTF_8);

    bos.write(a);
    /**
     * 强制将缓冲流的缓存取内部维护的字节数组
     * 将已缓冲的字节一次性写出
     */

    //bos.flush();
    bos.close();
}
```

```java
public static void main(String[] args) throws IOException {

    FileInputStream fis=new FileInputStream("imgs/a.png");
    FileOutputStream fos = new FileOutputStream("imgs/a-copy1.png");
    int b=-1;
    long start=System.currentTimeMillis();
    while((b=fis.read())!=-1){
        fos.write(b);
    }
    long end=System.currentTimeMillis();
    fis.close();
    fos.close();
    System.out.println("复制完毕"+(end-start)+"ms");
```

```java
public static void main(String[] args) throws IOException {
   // File file=new File("imgs/a.png");
    FileInputStream fis=new FileInputStream("imgs/a.png");
    FileOutputStream fos =new FileOutputStream("imgs/a-sx1.png");
    //int z=(int)file.length();
    byte [] b=new byte[1024*10];

    int d=-1;

    long start=System.currentTimeMillis();
    while((d=fis.read(b))!=-1){
        fos.write(b,0,d);
    }
    long end=System.currentTimeMillis();
    fos.close();
    fis.close();
    System.out.println("复制完毕"+(end-start)+"ms");



}
```

```java
public static void main(String[] args) throws IOException, ClassNotFoundException {
    //ois读取文件
    ObjectInputStream ois=new ObjectInputStream(new FileInputStream("person.obj"));

    Person o=(Person) ois.readObject();

    System.out.println(o);
    ois.close();

}
```

```java
public static void main(String[] args) throws IOException {

    //创建序列化对象Person
    String name="刘德华";
    int age=55;
    String gender="男";
    String [] otherInfo={"帅","有才华","能歌善舞"};

    Person person=new Person(name,age,gender,otherInfo);
    //写入到person.obj中
    //使用对象流
    ObjectOutputStream oos=new ObjectOutputStream(new FileOutputStream("person.obj"));
    /**
     * 对象输出提供序列化的方法
     * void writeObject(Object object);
     * 将给定的对象转化为一组可以保存或传输的字节然后通过连接的流将字节写出
     *
     * 序列化对象要求该对象的类必须是实现Serializable
     * 如果写出的对象对象的类型没有实现Serializable,那么writeObject会抛出
     * java.io.NotSerializableExcption.
     */
    oos.writeObject(person);
    System.out.println("写入完毕");
    oos.close();


}
```

```java
public static void main(String[] args) throws IOException {
    File file=new File("a.txt");
    long len=file.length();
    FileInputStream fis=new FileInputStream(file);
    byte[] data =new byte[(int)len];
    int read = fis.read(data);
    String line=new String(data);
    System.out.println(line);

}
```

```java
public static void main(String[] args) throws IOException {
    //文件写入字节流
    FileOutputStream fos=new FileOutputStream("a1.txt");
    //创建字符串
    String line ="我本♥照明月,奈何明月照沟渠";
    //字符串转为字节数组
    byte[] data=line.getBytes(StandardCharsets.UTF_8);
    //写到文件中
    fos.write(data);

    //输出写入完毕
    System.out.println("写入成功");
    //关闭流

    fos.close();


}
```

```java
public static void main(String[] args) {
    Thread th=new Thread(()-> System.out.println(1));
    th.start();
}
```

```java
//遍历1,按照key遍历 ,Set keySet()
Set<String> keySet = map.keySet();

for(String ks:keySet){
    System.out.println(ks+":"+map.get(ks));
}
//遍历 2 按照value 遍历 Collection values()
Collection<Integer> values = map.values();
Iterator<Integer> it = values.iterator();

while (it.hasNext()){
    System.out.print(it.next());
}
System.out.println();
//EntrySet
Set<Map.Entry<String, Integer>> entries = map.entrySet();

for(Map.Entry<String, Integer> es:entries){
    String kk= es.getKey();
    Integer value=es.getValue();
    System.out.print(kk+":"+value);
}
System.out.println();
//lambda表达式
map.forEach(
        (k,v)-> System.out.print(k+":"+v)
);
```

```java
list.add("five");
list.set(0,"six");
list.get(i);
//将第二个位置之后添加8
        a.add(2,8);
 a.remove(a.size()-1);

```

```java
public static void main(String[] args) {
    List<Integer> list = new ArrayList();

    for(int i=0;i<10;i++){
        list.add(i);
    }
    System.out.println(list);
    //获得集合中 3-7部分

    List<Integer> subList =list.subList(3,8);  //[)  等到了子集合  就是个复本
    System.out.println(list);
    System.out.println(subList);

    //给子集中每个元素X2
    for(int i=0;i<subList.size();i++){
        subList.set(i,subList.get(i)*2);

    }

    System.out.println(subList);//对副本操作会影响原来集合里面的值

    System.out.println(list);
    /*
    [6, 8, 10, 12, 14]
    [0, 1, 2, 6, 8, 10, 12, 14, 8, 9]
     */

    //删除2-8的部分
    List<Integer> s1= list.subList(2,9); //[)
    System.out.println(s1);
    s1.clear();                 //清除副本,原来的集合对应的位置的元素也会被清除掉

    System.out.println(list);


}
```

```java
//LinkedList特有方法
linkedList.addFirst(0);
linkedList.addLast(5);
```

```java
Integer[] arr=list.toArray(new Integer[list.size()]);
```

```java
public static void main(String[] args) {
    //数组和集合转换数组要用引用类型
    Integer [] arr={1,2,3,4};
    List<Integer> ai=Arrays.asList(arr);
    //输出数组
    //Arrays.toString(数组);

    System.out.println(Arrays.toString(arr));
    //对该集合修改原数组也会发生改变
    ai.set(1,9);
    System.out.println(ai);
    System.out.println(Arrays.toString(arr));

   // ai.add(10);
    //会报错,原因 ,UnsupportedOperationException
    //数组是定长的,此时集合也是定长的了,对集合的增加和删除操作是不支持的
    System.out.println(ai);
    //可以将转换集合插入到新的集合中进行集合操作;
    List<Integer> list =new ArrayList<>();
    list.addAll(ai);
    System.out.println(list);
    list.add(12);
    System.out.println(list);


}
```

```java
public static void main(String[] args) {
    //创建List对象
    //1-100内随机数10个赋值给list集合
    //输出集合
    //使用Collections 类的sort 方法进行排序
    //输出集合
    List<Integer> list =new ArrayList();
    Random rand =new Random();
    for(int i=0;i<10;i++){
        //int a= (int) (Math.random()*100+1);
        //list.add(a);
        list.add(rand.nextInt(99)+1);
    }
    System.out.println(list);
    //自然排序 从小到大
    Collections.sort(list);
    System.out.println(list);
    //从大到小排序是集合反转
    Collections.reverse(list);
    System.out.println(list);


}
```

```java
boolean b2 = map2.containsValue(null);
```

```java
//删除map的元素
map2.remove("HTML");
```

```java
 public static void main(String[] args) {
        //lambda 表达式完成接口
        Converter fun=s -> Integer.parseInt(s);
         userConverter(fun);
         //方法引用
         userConverter(Integer::parseInt);

    }
    public static  void  userConverter(Converter c){
        int num =c.convert("666");
        System.out.println(num);
    }
}

interface  Converter{
    int convert(String s);
}
```

```java
public class ReferenceDemo2 {
    public static void main(String[] args) {
        //
        usePrinter(s-> System.out.println(s.toUpperCase()));
        PrintString s=new PrintString();
        usePrinter(s::printUpper);
    }
    private static void usePrinter(Printer p){
        p.printerUpperCase("helloworld");
    }
}
class  PrintString{
    public void printUpper(String s){
        String result =s.toUpperCase();
        System.out.println(result);
    }
}
interface  Printer{
    void printerUpperCase(String s);
}
```

```java
public class RegerenceDemo3 {
    public static void main(String[] args) {

        useStudentBuilder((s,a)->new Student(s,a));
        useStudentBuilder(Student::new);

    }
    private static void useStudentBuilder(StudentBuilder stu){
        Student student=stu.builder("tom",40);
        System.out.println(student.getName()+","+student.getAge());
    }

}
interface StudentBuilder{
    Student builder(String name,int age);
}
```

```java
//获得类对象
Class cls=Student.class;
//2.获得类对象的3种方式
Class cls1= student.getClass();
```

```java
public static void main(String[] args) {
    Student student=new Student();
    //获得类对象
    Class cls=Student.class;
    //2.获得类对象的3种方式
    Class cls1= student.getClass();
    Class<?> cls2;
    //3.
    try {
        cls2 = Class.forName("reflect.Student");
        Student o1=(Student) cls2.newInstance();
    } catch (ClassNotFoundException | InstantiationException | IllegalAccessException e) {
        e.printStackTrace();
    }
    //反射创建对象
    try {
        //newInstance()方法调用空参构造
        Student stu=(Student) cls.newInstance();
        Student o =(Student) cls1.newInstance();

    } catch (InstantiationException e) {
        e.printStackTrace();
    } catch (IllegalAccessException e) {
        e.printStackTrace();
    }





}
```

```java
   public static void main(String[] args) throws NoSuchMethodException {
        //创建Student的类对象
            Class<Student> cls=Student.class;
    
            //获得所有构造
            Constructor[] cons= cls.getConstructors();
            for(Constructor s:cons){
                System.out.println(s);
            }
            try {
                //有参构造
                Constructor<Student> constructor = cls.getConstructor(String.class, int.class);
                try {
                    Student student = constructor.newInstance("jimi", 20);
                    System.out.println(student);
                } catch (InstantiationException e) {
                    e.printStackTrace();
                } catch (IllegalAccessException e) {
                    e.printStackTrace();
                } catch (InvocationTargetException e) {
                e.printStackTrace();
            }


        } catch (NoSuchMethodException e) {
            e.printStackTrace();
        }

//        try {
        //无参构造
//            Student student = cls.newInstance();
//
//        } catch (InstantiationException e) {
//            e.printStackTrace();
//        } catch (IllegalAccessException e) {
//            e.printStackTrace();
//        }


        Constructor<?>[] declaredConstructors = cls.getDeclaredConstructors();
        for(Constructor s:declaredConstructors){
            System.out.println(s);
        }

        Constructor dc=cls.getDeclaredConstructor(String.class);
        //暴力访问,访问私有权限
        dc.setAccessible(true);
        try {
            Student student1= (Student) dc.newInstance("mark");
            System.out.println(student1);
        } catch (InstantiationException e) {
            e.printStackTrace();
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        } catch (InvocationTargetException e) {
            e.printStackTrace();
        }
                                        
    }           
```

```java
public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException {
    //创建Student对象
    Class<Student> cls=Student.class;
    try {
        Student student = cls.newInstance();
        System.out.println(student);
    } catch (InstantiationException e) {
        e.printStackTrace();
    } catch (IllegalAccessException e) {
        e.printStackTrace();
    }

    Student stu =new Student();
    Class<? extends Student> aClass = stu.getClass();

    //创建通全参构造反射实例化
    Student student ;
    try {
        Method[]  methods=cls.getMethods();
        for(Method method:methods){
            System.out.println(method);
        }
        Constructor<Student> constructor = (Constructor<Student>) aClass.getConstructor(String.class, int.class);
       student =constructor.newInstance("jimi",10);
       // System.out.println(student);
        Method getInfo = cls.getMethod("getInfo");
        //
        getInfo.invoke(student);
    } catch (NoSuchMethodException e) {
        e.printStackTrace();
    } catch (InvocationTargetException e) {
        e.printStackTrace();
    } catch (InstantiationException e) {
        e.printStackTrace();
    } catch (IllegalAccessException e) {
        e.printStackTrace();
    }

    //反射调用方法



    Class<Student> stuu=Student.class;
    Constructor<Student> con= stuu.getConstructor(String.class,int.class);
    Student student1 = con.newInstance("pink", 1);
    Method mm= stuu.getMethod("setName", String.class);
    mm.invoke(student1,"cart");
    System.out.println(student1);

    Method getName=stuu.getMethod("getName",null);
    String name=(String) getName.invoke(student1);
    System.out.println(name);


    Method show=stuu.getDeclaredMethod("show",int.class,int.class);
    show.setAccessible(true);
    int ji=(int)show.invoke(student1,1,2);
    System.out.println(ji);


}
```

```java
boolean flag=mail.matches(regex);
 String [] z =str.split("#+");
   str=str.replaceAll("#+","abc");
    String[] strs= str.split(regex);
```

```java
public static void main(String[] args) {

    String str="好好学习java";
    //创建StringBuilder对象
    StringBuilder str2 =new StringBuilder();
    StringBuilder str1 =new StringBuilder(str);
    System.out.println(str1);
    /**
     * 好好学习java
     * 好好学习jav,为找个好工作!
     *
     */
    str1.append(",为找个好工作!");
    System.out.println(str1);

    String stt=str1.toString();
    System.out.println(stt);
    /**
     *
     * 好好学习java,为找个好工作!
     *好好学习java,为改变自己!
     */

    str1.replace(9,16,"为改变自己!");

    System.out.println(str1.toString());
    System.out.println(str1);

    /**
     * 好好学习java,为改变自己!
     * 为改变自己!
     *
     */
    str1.delete(0,9);
    System.out.println(str1);
    /**
     *
     * 为改变自己!
     *活着,为改变自己!
     */
    str=str1.insert(0,"活着`").toString();

    System.out.println(str);



}
```

```java
str="thinking in java";

int index=str.indexOf("in");
System.out.println(index);

index = str.indexOf("in",3);
System.out.println(index);

index =str.lastIndexOf("in");
System.out.println(index);//9

//获得to的字符串
//substring(int short,int end)含start不含end
String line="welcome to dalian";
String sub=line.substring(8,10);
System.out.println(sub);
```

```java
public static void main(String[] args) {
    Thread rose=new Thread("rose"){
        @Override
        public void run() {
            for (int i = 0; i < 5; i++) {
                System.out.println(getName()+"let me go");
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {

                }
            }
            System.out.println(getName()+":aaaaaaaaaAAAAAAA");
            System.out.println("噗通");
        }
    };

    Thread jack = new Thread("jack"){
        @Override
        public void run() {
            while (true){
                System.out.println(getName()+":you jump ! i jump !");
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {

                }
            }


        }
    };
    rose.start();
    jack.setDaemon(true);//设置守护线程必须在线程启动前进行
    jack.start();


}
```

```java
Thread th=new Thread(){
    @Override
    public void run() {
        for (int i = 0; i <1000 ; i++) {
            System.out.println("max");
        }
    }
};
```

```java
Thread lin=new Thread("刘永健"){
    @Override
    public void run() {
        System.out.println(getName()+":睡一会");
        try {
            Thread.sleep(5000000);
        } catch (InterruptedException e) {
            System.out.println(getName()+":干嘛呢");
        }
        System.out.println(getName()+"醒了");
    }
};

Thread huang=new Thread("黄月英"){
    @Override
    public void run() {
        System.out.println(getName()+":大锤80,小锤40,开始砸墙");
        for (int i = 0; i < 5; i++) {
            System.out.println(getName()+":80!");
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        System.out.println("咣当!!!");
        System.out.println(getName()+"大哥,搞定");
        lin.interrupt();
    }
};
lin.start();
huang.start();
```

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
    <bean id="user" class="cn.etg.ioc.entity.User">
        <!--注入属性  -->
        <property name="name" value="tom"></property>

    </bean>
</beans>
```

```java
public class BeanPost implements BeanPostProcessor {
    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
        System.out.println("3之前,bean后置处理器,在初始化之前执行"+beanName+":"+bean);
        return bean;
    }

    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
        System.out.println("3之后,bean后置处理器,在初始化之后执行"+beanName+":"+bean);
        return bean;
    }
}
```

```java
public class IocContainer {
    public  static Map<String,Object> map=new HashMap();
    //getbean方法
    static {
        //读取配置文件
        InputStream in=IocContainer.class.getClassLoader().getResourceAsStream("bean.properties");
        Properties properties=new Properties();
        try {
            properties.load(in);
        }catch (IOException e){
            e.printStackTrace();
        }
        //遍历配置文件中的配置信息
        Enumeration<Object> keys = properties.keys();
        while (keys.hasMoreElements()){
            String key = keys.nextElement().toString();
            String value = properties.getProperty(key);
            System.out.println(key+":"+value);
            try {

                Object instance = Class.forName(value).newInstance();
                map.put(key,instance);
            } catch (InstantiationException e) {
                e.printStackTrace();
            } catch (IllegalAccessException e) {
                e.printStackTrace();
            } catch (ClassNotFoundException e) {
                e.printStackTrace();
            }

        }
    }
    public static Object getBean(String id){
        return map.get(id);
    }
}
```

```java
/**
 * Resource来自于java,自动装配注解 默认是byName注入
 */
@Resource
```

```java
/**
 * 自动装配注解
 * 使用的是byType方式实现的自动装配
 */
@Autowired
private TeacherDao dao;
```

```java
/**@Autowired 和@Qualifier配合使用
 * Qualifier作用是通过名字指定注解
 *
 * @
 */
@Autowired
@Qualifier("stuDao")
private StuDao sdao;
```

```java
public class SpringTest {
    public static void main(String[] args) {
        ApplicationContext ac=new AnnotationConfigApplicationContext(SpringConfig.class);
        TeacherService ts=ac.getBean(TeacherServiceImpl.class);
        ts.insertTeacher(1,"wang","教务");

        ts.insertStudent(1,"tom",18,"男");

    }
}
```

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!--autowired byName 指的是setter注入-->
    <bean id="student" class="cn.etg.entity.Student" autowire="byType">
            <constructor-arg index="0"  value="1" />
            <constructor-arg index="1"  value="张三" />
            <constructor-arg index="2"  value="18" />

    </bean>
    <!--autowired  byType 指的是构造注入-->
    <bean id="teacher" class="cn.etg.entity.Teacher" autowire="byType">
        <constructor-arg index="0"  value="1" />
        <constructor-arg index="1"  value="张一" />
        <constructor-arg index="2"  value="男" />
        <constructor-arg index="3"  value="老师" />
    </bean>
    <bean id="user" class="cn.etg.entity.User" autowire="byName">
        <property name="id" value="1">
        </property>
        <property name="homeWork">
            <list>
                <value>张三</value>
                <value>李四</value>
            </list>
        </property>
        <property name="teachers">
            <list>
                <ref bean="teacher"></ref>
            </list>
        </property>
        <property name="map">
            <map>
                <entry key="001" value="90"></entry>
                <entry key="002" value="88"></entry>
            </map>
        </property>
        <property name="map1">
            <map>
                <entry key-ref="teacher" value-ref="student"></entry>

            </map>
        </property>
        <property name="subject">
            <set>
                <value>物理</value>
                <value>化学</value>
            </set>
        </property>
        <property name="students1">
            <set>
                <ref bean="student"></ref>
            </set>
        </property>
        <property name="students">
            <array>
                <ref bean="student"></ref>
            </array>
        </property>
        <property name="properties">
            <props>
                <prop key="1906">28</prop>
                <prop key="1907">20</prop>
                <prop key="1908">21</prop>
            </props>
        </property>

    </bean>
</beans>
```





```xml
创建线程的几种方式是什么？
通过继承 Thread 类创建线程类。
实现 Runnable 接口创建线程类。
通过 Callable 和 Future 接口创建线程


什么是死锁，产生死锁的四个条件
（1） 互斥条件：一个资源每次只能被一个进程使用。
（2） 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不
放。
（3） 不剥夺条件꞉进程已获得的资源，在末使用完之前，不能强行剥夺。
（4） 循环等待条件꞉若干进程之间形成一种头尾相接的循环等待资源关系。
这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要
上述条件之一不满足，就不会发生死锁


Java通过Executors(JUC)提供四种线程池，分别为：
newCachedThreadPool 创建一个可缓存线程池，如果线程池长度超过处理需要，
可灵活 回收空闲线程，若无可回收，则新建线程。
newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程
会在队 列中等待。
newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。
newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线
程来执 行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。


线程池参数有哪些？
corePoolSize 核心线程大小。
maximumPoolSize 线程池最大线程数量。
keepAliveTime 空闲线程存活时间。
unit 空间线程存活时间单位。
workQueue 工作队列。
threadFactory 线程工厂。
handler 拒绝策略。


IO
什么是节点流,什么是过滤流，并且说出常用的节点流和过滤流？
节点流：可以从或向一个特定的地方（节点）读写数据，直接跟数据源相接。
FileInputStream FileOutputStrean
ByteArrayInputStream ByteArrayOutputStream
过滤流：是对一个已存在的流的的基础上进行功能扩展。
BufferedImputStrean BufferedOutputStream
InputStreamReader OutputStreamWriter
ObjectInputStream ObjectOutputStream


什么叫对象序列化，什么是反序列化，实现对象序列化需要做哪些工作？
序列化：把对象转化为可传输的字节序列过程称为序列化。
反序列化：把字节序列还原为对象的过程称为反序列化。
其实序列化最终的目的是为了对象数据存储，或者进行网络传输
java 实现序列化很简单，只需要被序列化对象类实现Serializable 接口，然后使用
对象流进行序列化和反序列化。
使用ObjectOutputStream 进行对象序列化
使用ObjectInputStream 进行对象反序列化



HTTP请求结构？HTTP请求头中有什么？
一个HTTP请求报文由四个部分组成：请求行、请求头部、空行、请求数据
2.请求头
1.Accept：浏览器可接受的mime类型。
2.Accept-Charset：浏览器可接受的字符集。
3.Accept-Encoding：浏览器能够进行解码的方式。
4.Content-Length：表示请求消息的长度。
5.Host： 客户端告诉服务器，想访问的主机名。
6.Cookie：客户端可以向服务器带数据，只是非常重要的信息之一。


GET和POST的区别
GET方式是通过请求行传递用户所输入的内容，其内容会全部显示的浏览器的地
址栏中；
GET提交具有长度限制
GET是从服务器上获取数据
GET请求没有HTTP消息体
POST提交将用户所输入数据放到HTTP消息体中发送到服务器端
POST没有提交长度限制
POST是向服务器传送数据



慢速SQL优化
1、WHERE 子句中：where 表之间的连接必须写在其他 Where 条件之前，那些可以
过滤掉最大数量记录的条件必须写在 Where 子句的末尾.HAVING 最后。
2、用 EXISTS 替代 IN、用 NOT EXISTS 替代 NOT IN。
3、避免在索引列上使用计算
4、避免在索引列上使用 IS NULL 和 IS NOT NULL
5、对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的
列上建立索引。
6、应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索
引而进行全表扫描
7、应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引
而进行全表扫描



JDBC的使用步骤？
1. 注册驱动（有些新版本驱动会自动注册）
2. 创建连接
3. 创建Statement对象
4. 执行SQL
5. 处理SQL结果
6. 关闭连接


在JDBC 编程中处理事务的步骤？
1. 设置自动提交为false
2. 执行事务处理SQL
3. 如果没有异常，就提交事务
4. 如果有异常，就回退事务
5. 在finally中关闭连接

什么是事务？
保证在一个事务中多次操作要么全都成功,要么全都失败


事务可能发生问题？隔离级别有哪些
脏读：一个事务读到了另一个事务未提交的数据.
不可重复读：一个事务读到了另一个事务已经提交(update)的数据。引发另一个
事务，在事务中的多次查询结果不一致。
虚读 /幻读：一个事务读到了另一个事务已经提交(insert)的数据。导致另一个事
务，在事务中多次查询的结果不一致。


事务的四大特性是什么
A：原子性（Atomicity）原子性是指事务是一个不可分割的工作单位，事务中的操
作要么都发生，要么都不发生。
C：一致性（Consistency）事务前后数据的完整性必须保持一致。
I：隔离性（Isolation）事务的隔离性是指多个用户并发访问数据库时，一个用户
的事务不能被其它用户的事务所干扰，多个并发事务之间数据要相互隔离。
D：持久性（Durability）持久性是指一个事务一旦被提交，它对数据库中数据的
改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响


分库分表分片的策略有哪些？
数据切分（Sharding），简单的来说，就是通过某种特定的条件，将存放在同一个数
据库中的数据拆分存放到多个数据库（主机）中，从而达到分散单台机器负载的情
况，即分库分表。根据数据切分规则的不同，主要有两种模式，
垂直切分（纵向切分），是对不同的表（或者Schema）进行切分，存储到不同的
数据库（主机）之上。
水平切分（横向切分），是对同一个表中的数据进行切分，存储到不同的数据库
（主机）之上。规则是根据表中数据的逻辑关系，按照某种条件拆分。



索引
索引技术原理
MySQL索引为什么这么快
索引是数据库中用于快速查询数据的一种数据结构。在数据库中，索引的原理类
似于书的目录，它会记录每个关键字对应的数据在哪个数据页中，这样数据库就
可以快速地根据关键字进行查找，并且不用扫描整个数据表。
在 MySQL 数据库中，索引通过 B+ 树数据结构实现。B+ 树是一种平衡树，它的
每个节点都有多个子节点，这些子节点之间是有序的，通过在节点中存储指向子
节点的指针，可以快速地定位到数据。在 B+ 树中，每个节点都包含多个关键字和
指向子节点的指针，这些关键字按照大小有序排列，从而能够快速地定位到需要
查找的数据。
MySQL 索引之所以能够提高查询效率，主要有以下几个原因：
减少数据扫描：当使用索引查询数据时，数据库不需要扫描整个数据表，而是直
接定位到索引对应的数据页，从而减少了数据扫描的时间。
加快数据定位：索引可以将数据分组存储，并通过 B+ 树的查找算法快速定位到需
要查询的数据，从而加快了数据定位的速度。
避免排序和分组：当需要对数据进行排序或者分组时，使用索引可以避免进行数
据的全表扫描，从而提高排序和分组的效率。
总之，MySQL 索引通过使用 B+ 树数据结构，实现了快速定位和快速查询数据的
功能，从而提高了查询效率。在实际开发中，应该根据数据的访问模式和查询需
求来选择适当的索引策略，以达到最优的查询性能。


主键索引和普通索引的区别
主键索引꞉是一种特殊的唯一索引，不允许有空值。
普通索引꞉MySQL 中基本索引类型，没有什么限制，允许在定义索引的列中插入
重复值 和空值，纯粹为了查询数据更快一点

索引失效情况有哪些？
like 以%开头索引无效，当 like 以&结尾，索引有效。
or 语句前后没有同事使用索引，当且仅当 or 语句查询条件的前后列均为索引时，
索引生 效。
组合索引，使用的不是第一列索引时候，索引失效，即最左匹配规则。
数据类型出现隐式转换，如 varchar 不加单引号的时候可能会自动转换为 int 类
型，这个时候索引失效。
在索引列上使用 IS NULL 或者 IS NOT NULL 时候，索引失效，因为索引是不索
引空值的。
在索引字段上使用，NOT、 <>、!= 、时候是不会使用索引的，对于这样的处理只
会进行全表扫描。
对索引字段进行计算操作，函数操作时不会使用索引。
当全表扫描速度比索引速度快的时候不会使用索引。



左外连接查询和右外关联查询的区别？
外连接分为三种，分别是是左外连接(LEFT OUTER J0IN 或 LEFT JOIN 右外连接
(RIGHT OUTER JOIN 或 RIC GHT JOIN、全外连接(FULL OUTER JOIN 或
FULLJOIN)。
112
左外连接꞉又称为左连接，这种连接方式会显示左表不符合条件的数据行，右边不符
合条件的数据 行直接显示 NULL。
右外连接꞉也被称为右连接，他与左连接相对，这种连接方式会显示右表不符合条件的
数据行，左 表不符合条件的数据行直接显示 NULL


数据库建表的范式是什么?
第一范式꞉每个列都不可以再拆分。
第二范式꞉在第一范式的基础上，非主键列完全依赖于主键，而不能是依赖于主键的一
部分。
第三范式꞉在第二范式的基础上，非主键列只依赖于主键，不依赖于其他非主键。
在设计数据库结构的时候，要尽量遵守三范式，如果不遵守，必须有足够的理由。比
如性能。事实上我们经常会为了性能而妥协数据库的设计


    使用过哪些数据连接池？数据库连接池有什么用？
Druid数据库
HikariCP
是维护的数据库连接的缓存，以便在将来需要对数据库发出请求时可以重用连接。 连
接池用于提高在数据库上执行命令的性能。 保护数据库连接总数，避免连接过载。



COUNT：计算数据集合中的记录数。
SUM：计算数据集合中某个字段的总和。
AVG：计算数据集合中某个字段的平均值。
MAX：获取数据集合中某个字段的最大值。
MIN：获取数据集合中某个字段的最小值。
distinct()


悲观锁乐观锁？
悲观锁和乐观锁是并发控制的两种不同策略，用于协调多个线程对共享数据的访问。
它们的主要区别在于对并发冲突的处理方式。
悲观锁：悲观锁的基本思想是，在数据被修改时，采用加锁的方式防止其他线程访
问，即假定数据在大部分时间内都会发生冲突，因此采取一种悲观的策略，避免数据
冲突。悲观锁适用于读写操作时间长、且经常发生冲突的场景。
乐观锁：乐观锁的基本思想是，在数据被修改时，不加锁而是采用版本控制的方式，
通过对比版本号来判断数据是否被修改。乐观锁适用于读写操作时间短、且很少发生
冲突的场景。
乐观锁的实现方式包括CAS（比较并交换）和版本号。CAS是一种基于CPU原语的操
作，原子性地比较当前值和期望值，如果相同就更新值。如果CAS操作失败，则表示
当前值已经被其他线程修改，需要重试。版本号是将数据的版本号和每次更新一起存
储，每次读取数据时都会比较版本号，如果版本号不一致，则表示数据已经被其他线
程修改。



```





















# Spring中注解汇总

## 一、类上添加注解

### 1、@Component/@Controller/@Service/@Repository

作用：将该类设置为bean

![](D:\self_learn\note\img\Snipaste_2023-12-08_06-18-49.png)

@Controller：表现层 控制层，控制业务逻辑

@Service：业务层 service层：业务层控制业务（业务逻辑层）

@Repository：数据层 [dao层](https://so.csdn.net/so/search?q=dao层&spm=1001.2101.3001.7020)：主要是和数据库进行交互。也被称为mapper层

### 2、@Configuration和@ComponentScan

两个注解结合在一起使用

@Configuration注解用于设定当前类为配置类

![image-20231208062015759](C:\Users\dsk\AppData\Roaming\Typora\typora-user-images\image-20231208062015759.png)

@[ComponentScan注解](https://so.csdn.net/so/search?q=ComponentScan注解&spm=1001.2101.3001.7020)用于设定扫描路径，此注解只能添加一次，多个数据请用数组格式

![image-20231208062057294](C:\Users\dsk\AppData\Roaming\Typora\typora-user-images\image-20231208062057294.png)

此外：还可设置哪些不被扫描。



throw抛异常写在方法内  异常类的对象

自定义异常是Exception时throw和throws同时使用,当自定义异常继承runtimeException时,需要使用throw就可以了

创建同步锁的方式有几种:

静态锁

public synchronized  static void test(){

}

成员锁

public synchronized  void test(){

}

同步代码块

synchronized(锁对象){

​			

}

锁对象 分两种状况

1.对象锁,使用this代替

2.类锁,使用类名.class

Error 和Exception的区别

Error是程序处理不了的错误,常见的是占内存溢出

Exception是所有异常的超类,常见的孔指针异常

运行时异常
$$


$$


```java
创建枚举类:
@Data
@NoArgsConstructor
@AllArgsConstructor
enum section {



private String description;

}

相同点:来源于springMvc
      RequestBody 和ResponseBody的区别
位置:   方法参数上                  类上和方法上
作用:post请求处理,将json转对象       对象转json

jdbc执行流程

1.加载驱动
2.创建连接
3.创建statement  preparedStatement
4.执行sql语句
5.处理返回结果
6.关闭连接close

"".replaceAll("-","")

PreparedStatement和Statement的区别

传值 ?占位符                 变量
执行sql 预处理的时候执行      调用执行方法的时候执行
		防止sql注入        不可以
		可读性高             可读性第
        
List Set Map  的区别
来源  继承Collection接口    Map接口
list  arrayList linkedList  HashSet TreeSet   HashMap  TreeMap  
	Object数组             哈希表              key_value
	链表
	可重复               不可以重复        不可以重复
	任意null          只能null一次         key可以null一次 value可以任意null
					TreeSet不可以null      HashMap可以null一次

HashMap 和TreeMap的区别
    
接口 Map接口     NavigableMa接口
排序  无序       			有序
底层实现  数组链表红黑树    红黑树
效率		高             一般
    
    linkedList ArrayList 的区别
    结构  链表        数组
    操作  增       查找快
    
    Collections.sort(users,Compareable)
    
    21.删除集合"#1#2#3"中的"#"
    
    Iterator<String> it=c.iterator()
    while(it.hasNext()){
        String  p=it.next();
        if("#".equals(p)){
            it.remove();
        }
    }
    


            get               post  
识别   地址栏和超连接的请求     表单指定method="post"
      默认表单请求              
http的处理方式                       header  识别到   xxx-form-text识别为post请求
                
安全性   不安全  通过quertsting获取			消息体
                
大小     内容长度4k                                不限制
数据类型  只能发送ascII                    可以发送任意类型
           缓存  有                           无
                
            Arrays.sort()
                
                
                
                复制图片
                
new 
                
                什么是死锁，产生死锁的四个条件
（1） 互斥条件：一个资源每次只能被一个进程使用。
（2） 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不
放。
（3） 不剥夺条件꞉进程已获得的资源，在末使用完之前，不能强行剥夺。
（4） 循环等待条件꞉若干进程之间形成一种头尾相接的循环等待资源关系。
这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要
上述条件之一不满足，就不会发生死锁。
                
                
                this          super
   对象      当前对象        超类对象
              区别成员变量与局部变量   调用超类的成员变量
                
               this调用方法
                成员方法            父类的成员方法
                
                构造this调用构造方法
                this()              只能放在构造方法的首行
                派生类默认调用super的构造方法
                
                
                
                ioc/di
             之间什么关系
                
                ioc  控制反转  
                di 依赖注入 
                关系:控制反转是一种思想  ,依赖注入是一种手段
                   
                    spring  中组件注解有哪些
                    component service controller    repository   
                  RestController 和Controller
              区别    Restful风格  
                    来源   springmvc   spring 
                    是responseBody
                   和controller

                    ${}     #{}  的区别
             传值  字符串相对于变量拼接      占位符
                    
                    RequestParam   param 区别  
                    
                 来源  springmvc   mybatis 
                 参数   get请求参数    处理单个参数
                 位置       控制器类中      持久层类中  
                  相同点      都是传参数的注解
                    
                    
               ComponentScanner 和  MapperScanner 的区别
                    
                来源 spring          mybatis
                作用  扫描组件注解    扫描mapper接口
                    
                    @RequestParam 和  @PathVariable  
                  相同点  都是是方法参数注解
                    来源相同   springmvc  
                    url   get请求路径处理  RESTful 风格的请求处理   
                    
                    
                    delete  turncate   drop
                  的区别  
                         删除数据删除索引           删除数据及索引                 删除表
                    
                    
                    requestMapping     GetMapping
                    
                    
              来源   
                    
               什么是事务:
			一组sql命令,要么成功要失败
                    
                
                事务的特征:

			ACID:    原则性      一致性     隔离性   持久性
                
                commmit rollback
                
                BindException 接口绑定异常  1.mabatis-loacion classpath  2.mappernamespace 是否绑定异常 3.单词是否正确 4.mapperScanner注解
                
                事务的特征:

	select count(*) from  user   group by sex
        
        
        <insert>
        insert into user  values
         
        <foreach  collections="user"  item="user_item"    separator=","   >
        		(#{},#{},#{},#{})
        </foreach>
        </insert>
                
        <update>
        <trim prefix="set"  stuffixoverride=",">
        
        <
        
        <
                    
                    
                    
                  
                
```



# Collection和Collections的区别

| 方面 | Collection    | Collections |
| ---- | ------------- | ----------- |
|      | 接口list  set | 工具类      |
|      |               |             |
|      |               |             |
|      |               |             |
|      |               |             |



