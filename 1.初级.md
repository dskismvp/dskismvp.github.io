

# -2    3次考试   知识点    项目   复习



## 项目   1.开题  2.设计  3.编码  4.整合   系统  网页    

旅游  商城  产物  1. 通过提供的网站找到模块 及功能  

2.思考应该有什么表,有多少长,表之间的关系  桐功能得知关系

3.设计接口  controller

4.程序的逻辑,时序 对象  xmind    navicate  接口 .md

每人20个接口





1.消除恐惧

2.通过代码理解

3.说话说全 ,少用代词

4.少啰嗦



# -1.常见命令

vue通过script引入

```html
<script src="https://cdn.bootcdn.net/ajax/libs/axios/0.21.1/axios.js"></script>
<script src="https://cdn.staticfile.org/vue/2.6.14/vue.js"></script>
```

application.yaml文件

```yaml
spring:
  profiles:
    active: dev

  datasource:
    type: com.alibaba.druid.pool.DruidDataSource
    druid:
      max-active: 50
      min-idle: 2

mybatis-plus:
  mapper-locations: classpath:/mappers/**/*.xml
```

application-dev.yaml

```yaml
server:
  port: 8081

spring:
  datasource:
    url: jdbc:mysql://localhost:3306/etg-springboot-demo?characterEncoding=utf8&useSSL=false&serverTimezone=Asia/Shanghai&rewriteBatchedStatements=true         			
    username: root
    password: ROOT
  messages:
    encoding: utf-8

logging:
  level:
    cn.etg.project.demo: trace
```

# 零.常见网站

| 序号 | 网站名称            | 网址                                                         | 作用             | maven |
| ---- | ------------------- | ------------------------------------------------------------ | ---------------- | ----- |
| 1    | Hutool              | https://doc.hutool.cn/pages/index/                           | 免费开源工具类   |       |
| 2    | MaBatis-plus        | https://baomidou.com/pages/42ea4a/                           | 封装dao和service |       |
| 3    | MaBatis             | https://mybatis.org/mybatis-3/zh/index.html                  | 操作             |       |
| 4    | maven网站           | https://mvnrepository.com/                                   | 提供各种依赖     |       |
| 5    | vue                 | https://v2.cn.vuejs.org/v2/guide/migration-vue-2-7.html      | vue教程          |       |
| 6    | idea-vue.js安装连接 | https://plugins.jetbrains.com/plugin/9442-vue-js             |                  |       |
| 7    | axios               | http://www.axios-js.com/docs/                                | axios教程        |       |
| 8    | element-ui          | https://element.eleme.cn/#/zh-CN/component/input             |                  |       |
| 9    | 文件上传1           | https://blog.csdn.net/Baridhu/article/details/126376517?ops_request_misc=&request_id=&biz_id=102&utm_term=springboot%E4%B8%8A%E4%BC%A0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-8-126376517.nonecase&spm=1018.2226.3001.4187 |                  |       |
| 10   | 文件上传2           | https://blog.csdn.net/weixin_45525177/article/details/133376941?spm=1001.2101.3001.6650.6&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-6-133376941-blog-126376517.235%5Ev38%5Epc_relevant_yljh&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-6-133376941-blog-126376517.235%5Ev38%5Epc_relevant_yljh&utm_relevant_index=11 |                  |       |
| 11   | 疑难杂症            | https://www.cnblogs.com/phdeblog/category/1412779.html       |                  |       |
| 12   | 多平台文件上传详解  | http://blog.ncmem.com/wordpress/2023/09/28/springboot%e5%ae%9e%e7%8e%b0%e6%96%87%e4%bb%b6%e4%b8%8a%e4%bc%a0%e7%9a%84%e5%a4%9a%e7%a7%8d%e6%96%b9%e5%bc%8f/ |                  |       |
| 13   | axios文件上传方法   | https://blog.csdn.net/loonj/article/details/129010827        |                  |       |
| 14   | redis官网           | https://www.redis.net.cn/tutorial/3506.html                  |                  |       |
| 15   | vue电商平台项目     | https://blog.csdn.net/weixin_48701221/article/details/126537611 |                  |       |
| 16   | git                 | git.com                                                      |                  |       |
| 17   | jwt                 | jwt.io                                                       |                  |       |
| 18   | nocos               | https://nacos.io/zh-cn/                                      |                  |       |
|      |                     |                                                              |                  |       |

***区别

cookie  浏览器  4k     字符串  本地

session 服务器   跨页面传输对象  无限制

request 逐页面

1. **Cookie**：是一种存储在客户端的数据，通常在HTTP请求和响应中传递。当用户访问网站时，服务器可能会设置cookie，这个cookie包含一些键值对，可以在用户的浏览器中保存一段时间。在后续的请求中，浏览器会自动附带这些cookie信息，帮助网站识别用户。例如，当用户登录网站后，服务器可能会设置一个有效期至用户下次登录的cookie，这样在用户下次访问网站时，服务器可以通过检查cookie来验证用户的登录状态。
2. **Session**：是一种存储在服务器端的数据，用于跟踪用户的状态。每当用户访问网站时，服务器会为该用户创建一个唯一的session对象，这个session对象包含一些键值对，用于存储用户的特定信息，如登录状态、购物车内容等。这些信息只在用户与网站的交互期间有效，当用户关闭浏览器或会话超时后，session信息会被清除。与cookie不同，session信息不会在用户的浏览器中存储。
3. **Request**：是指HTTP请求，包括GET、POST、PUT、DELETE等操作。它用于向服务器发送数据请求或数据提交。Request可以包含一些参数、头部信息、正文内容等，用于向服务器传递数据或指示服务器执行特定的操作。

总结一下，`Cookie`、`Session`和`Request`的主要区别如下：

- `Cookie`是一种存储在客户端的数据，用于在HTTP请求和响应中传递用户的状态信息；
- `Session`是一种存储在服务器端的数据，用于跟踪用户的状态；
- `Request`是指向服务器发送的HTTP请求，用于获取或提交数据。



# 一.常见注解





| 序号 | 常见注解                           | 来源                      | 作用                                                         | 例如                                                         | 包                                                        | maven |
| ---- | ---------------------------------- | ------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | --------------------------------------------------------- | ----- |
| 1    | @Component                         | spring                    | 在类定义之前添加@Component注解，该类会被Spring IoC容器识别并转为bean。 |                                                              | org.springframework.stereotype.Component                  |       |
| 2    | @Repository                        | spring                    | 用于对Dao实现类进行注解（特殊的@Component）。                |                                                              | org.springframework.stereotype.Repository                 |       |
| 3    | @Service                           | spring                    | 用于对业务逻辑层进行注解（特殊的@Component）。               |                                                              | org.springframework.stereotype.Service                    |       |
| 4    | @Controller                        | spring                    | 用于控制层注解（特殊的@Component）.                          |                                                              | org.springframework.stereotype.Controller                 |       |
| 5    | @RequestMapping                    | spring                    | 用于处理请求地址映射，可以作用于类和方法上。                 |                                                              | org.springframework.web.bind.annotation.RequestMapping    |       |
| 6    | @PathVariable                      | spring                    | 用于接收浏览器地址中QueryString的参数。                      |                                                              | org.springframework.web.bind.annotation.PathVariable      |       |
| 7    | @CookieValue                       | spring                    | 用于获取请求的Cookie值。                                     |                                                              | org.springframework.web.bind.annotation.CookieValue       |       |
| 8    | @Resource                          | spring                    | 此注解和自动注入注解都是做bean的注入时使用。                 |                                                              | javax.annotation.Resource                                 |       |
| 9    | @Transactional                     | spring                    | 将类中的方法变为事务。                                       |                                                              | org.springframework.transaction.annotation.Transactional  |       |
| 10   | @ModelAttribute                    | spring                    | 用于将表单提交的数据绑定到模型对象中。                       |                                                              | org.springframework.web.bind.annotation.ModelAttribute    |       |
| 11   | @RequestParam                      | spring                    | 用于获取请求参数。                                           |                                                              | org.springframework.web.bind.annotation.RequestParam      |       |
| 12   | @RequestBody                       | spring                    | 用于获取请求体中的数据。                                     |                                                              | org.springframework.web.bind.annotation.RequestBody       |       |
| 13   | @SessionAttributes                 | spring                    | 用于将模型对象存储到Session中。                              |                                                              | org.springframework.web.bind.annotation.SessionAttributes |       |
| 14   | @ModelAttribute                    | spring                    | 用于将表单提交的数据绑定到模型对象中。                       |                                                              | org.springframework.web.bind.annotation.ModelAttribute    |       |
| 15   | @RequestMapping                    | spring                    | 用于处理请求地址映射，可以作用于类和方法上。                 |                                                              | org.springframework.web.bind.annotation.RequestMapping    |       |
| 16   | @ComponentScan                     | spring                    | 用于指定Spring组件扫描的包路径。                             |                                                              | org.springframework.context.annotation.ComponentScan      |       |
| 17   | @Bean                              | spring                    | 用于定义一个Spring组件，可以是一个普通的Java对象，也可以是一个配置类。 |                                                              | org.springframework.context.annotation.Bean               |       |
| 18   | @Configuration                     | spring                    | 用于标记一个类作为Spring配置类，通常与@ComponentScan联合使用。 |                                                              | org.springframework.context.annotation.Configuration      |       |
| 19   | @Aspect                            | spring                    | 用于标记一个类作为切面类。                                   |                                                              | org.aspectj.lang.annotation.Aspect                        |       |
| 20   | @Before                            | spring                    | 在目标方法执行之前切入。                                     |                                                              | org.aspectj.lang.annotation.Before                        |       |
| 21   | @After                             | spring                    | 在目标方法执行之后切入。                                     |                                                              | org.aspectj.lang.annotation.After                         |       |
| 22   | @AfterReturning                    | spring                    | 在目标方法执行之后切入，仅当方法返回一个非void类型的结果时切入。 |                                                              | org.aspectj.lang.annotation.AfterReturning                |       |
| 23   | @AfterThrowing                     | spring                    | 在目标方法执行过程中出现异常时切入。                         |                                                              | org.aspectj.lang.annotation.AfterThrowing                 |       |
| 24   | @Around                            | spring                    | 在目标方法执行前后均切入。                                   |                                                              | org.aspectj.lang.annotation.Around                        |       |
| 25   | @Pointcut                          | spring                    | 定义一个切入点，可以是一个方法或者一组方法。                 |                                                              | org.aspectj.lang.annotation.Pointcut                      |       |
| 26   | @Aspect                            | spring                    | 定义一个切面类，可以包含多个切入点表达式和方法表达式，用于定义针对哪些方法和哪些方法执行切面逻辑。 |                                                              | org.aspectj.lang.annotation.Aspect                        |       |
| 27   | @Test                              | spring                    |                                                              |                                                              | org.junit.Test                                            |       |
| 28   | `@Component`                       | spring                    | 将类标记为Spring组件，并将其自动注册为Spring容器中的bean。   |                                                              |                                                           |       |
| 30   | `@Service`                         | spring                    | 将类标记为业务逻辑服务，并自动注册为Spring容器中的bean。     |                                                              |                                                           |       |
| 31   | `@Repository`                      | spring                    | 将类标记为数据访问对象（DAO），并自动注册为Spring容器中的bean。 |                                                              |                                                           |       |
| 32   | @Controller                        | spring                    | 将类标记为控制器层，并自动注册为Spring容器中的bean。 `       |                                                              |                                                           |       |
| 33   | @RestController                    | spring                    | 将类标记为控制器层，并自动注册为Spring容器中的bean，同时将所有返回值直接写入HTTP响应中。 |                                                              |                                                           |       |
| 34   | `@RequestMapping`                  | spring                    | 将HTTP请求映射到特定的处理方法。可以用于类级别或方法级别。   |                                                              |                                                           |       |
| 35   | `@GetMapping`                      | spring                    | 将GET请求映射到特定的处理方法。                              |                                                              |                                                           |       |
| 36   | `@PostMapping`                     | spring                    | 将POST请求映射到特定的处理方法。                             |                                                              |                                                           |       |
| 37   | @PutMapping                        | spring                    | 将PUT请求映射到特定的处理方法。 `@DeleteMapping`：将DELETE请求映射到特定的处理方法。 |                                                              |                                                           |       |
| 38   | @PathVariable                      | spring                    | 用于绑定URL中的一个路径变量到方法的参数上。                  |                                                              |                                                           |       |
| 39   | @RequestParam                      | spring                    | 用于绑定请求参数（query string或form data）到方法的参数上。  |                                                              |                                                           |       |
| 40   | @RequestBody                       | spring                    | 用于绑定请求体到方法的参数上。                               |                                                              |                                                           |       |
| 41   | @Autowired                         | spring                    | 用于自动装配bean属性或构造函数参数。 `                       |                                                              |                                                           |       |
| 42   | @Qualifier                         | spring                    | 用于指定一个bean的名称或类型，以便在自动装配时进行区分。     |                                                              |                                                           |       |
| 43   | @Value                             | spring                    | 用于注入属性值，可以注入配置文件中定义的属性值或常量值。     |                                                              |                                                           |       |
| 44   | `@Profile`                         | spring                    | 用于指定一个或多个Profile，在运行时根据Profile的激活情况来选择使用该Bean。 |                                                              |                                                           |       |
| 45   | `@Bean`                            | spring                    | 用于定义一个Bean，可以指定该Bean的名称、作用域等属性。       |                                                              |                                                           |       |
| 46   | @Configuration                     | spring                    | 用于标记一个类作为Spring配置类，可以在其中定义多个Bean。     |                                                              |                                                           |       |
| 47   | @EnableAutoConfiguration           | spring                    | 用于启用Spring Boot的自动配置功能，自动配置所需的Bean。      |                                                              |                                                           |       |
| 48   | `@SpringBootApplication`           | Spring MVC                | 该注解是Spring Boot应用程序的启动类注解，它组合了`@SpringBootConfiguration`、`@EnableAutoConfiguration`和`@ComponentScan`注解。它用于自动配置和组件扫描，使得Spring Boot应用程序能够自动检测和配置相关组件。 |                                                              |                                                           |       |
| 49   | @Configuration                     | Spring MVC                | 该注解用于标记一个类作为Spring配置类，可以在其中定义Bean和配置其他Spring相关的属性。 |                                                              |                                                           |       |
| 50   | @EnableWebMvc                      | Spring MVC                | 该注解用于启用Spring MVC功能，使得应用程序能够处理HTTP请求和响应。 |                                                              |                                                           |       |
| 51   | @ComponentScan                     | Spring MVC                | 该注解用于指定组件扫描的包或类路径，以便自动检测和注册相关组件。 |                                                              |                                                           |       |
| 52   | `@Autowired`                       | Spring MVC                | 该注解用于自动装配Bean属性或构造函数参数，使得应用程序能够自动注入所需的依赖项。 |                                                              |                                                           |       |
| 53   | @Bean                              | Spring MVC                | 该注解用于定义一个Bean，可以指定该Bean的名称、作用域等属性。 ` |                                                              |                                                           |       |
| 54   | @Value                             | Spring MVC                | 该注解用于注入属性值，可以注入配置文件中定义的属性值或常量值。 |                                                              |                                                           |       |
| 55   | @Profile                           | Spring MVC                | 该注解用于指定一个或多个Profile，在运行时根据Profile的激活情况来选择使用该Bean。 ` |                                                              |                                                           |       |
| 56   | @Controller                        | Spring MVC                | 该注解用于标记控制器类，并自动注册为Spring容器中的bean。 `   |                                                              |                                                           |       |
| 57   | @RestController                    | Spring MVC                | 该注解用于标记控制器类，并自动注册为Spring容器中的bean，同时将所有返回值直接写入HTTP响应中。 |                                                              |                                                           |       |
| 58   | @ControllerAdvice                  | Spring MVC                | 前台报异常显示,加强方法,aop                                  |                                                              | org.springframework.web.bind.annotation.ControllerAdvice  |       |
| 59   | @ResponseBody                      | Spring MVC                | json返回数据                                                 | @ControllerAdvice  public class GlobalExceptionHandler {     //json返回数据     @ResponseBody     @ExceptionHandler(value = ApiException.class)     public CommonResult headler (ApiException e){         if(e.getErrorCode()!=null){             return  CommonResult.failed(e.getErrorCode());         }         return CommonResult.failed(e.getMessage());     } } | org.springframework.web.bind.annotation.ResponseBody      |       |
| 60   | @ExceptionHandler                  |                           | 对异常进行拦截处理                                           | @ExceptionHandler(value = ApiException.class)                | org.springframework.web.bind.annotation.ExceptionHandler  |       |
| 61   | @Data                              | lombok                    | 提供setter ,getter和tostring,equals and hashCode()           |                                                              | lombok.Data                                               |       |
| 62   | @Accessors(chain = true)           | lombok                    | //链式访问                                                   | user.getUserName().getNickName.getPassword()                 | lombok.experimental.Accessors                             |       |
| 63   | @TableName("tab_user")             | mybatisplus               | 指定表名                                                     |                                                              | com.baomidou.mybatisplus.annotation.TableName             |       |
| 64   | @TableId(type = IdType.AUTO)       | mybatisplus               | id自增长设置,主键注解                                        |                                                              | com.baomidou.mybatisplus.annotation.TableId               |       |
| 65   | @NonNull                           | lombok                    | 设置属性不为空                                               |                                                              | lombok.NonNull                                            |       |
| 66   | @TableName("sys_user")             | mybatisplus               | 属性名与表中字段不一致的时候写                               |                                                              |                                                           |       |
| 67   | @Transient                         | beans                     | 不会被序列化                                                 |                                                              | java.beans.Transient                                      |       |
|      | @Scheduled(cron = "*/6 * * * * ?") |                           |                                                              |                                                              |                                                           |       |
|      | @EnableScheduling                  | //定时注解,可以使用定时器 |                                                              |                                                              |                                                           |       |
|      |                                    |                           |                                                              |                                                              |                                                           |       |
|      |                                    |                           |                                                              |                                                              |                                                           |       |
|      |                                    |                           |                                                              |                                                              |                                                           |       |
|      |                                    |                           |                                                              |                                                              |                                                           |       |
|      |                                    |                           |                                                              |                                                              |                                                           |       |
|      |                                    |                           |                                                              |                                                              |                                                           |       |
|      |                                    |                           |                                                              |                                                              |                                                           |       |
|      |                                    |                           |                                                              |                                                              |                                                           |       |
|      |                                    |                           |                                                              |                                                              |                                                           |       |
|      |                                    |                           |                                                              |                                                              |                                                           |       |
|      |                                    |                           |                                                              |                                                              |                                                           |       |



# 二.工厂模式、建造者模式

### 1、什么是工厂模式：【关键字factory】

答：创建对象时，不直接new，而是交由一个工厂类/工厂接口的工厂方法负责创建。

### 2、工厂模式的意义

答：将**实例化对象的代码提取出来，放到一个类(工厂类)中统一管理和维护；实现了创建者和调用者的分离**，达到和主项目的[依赖关系](https://so.csdn.net/so/search?q=依赖关系&spm=1001.2101.3001.7020)的解耦。从而提高项目的**扩展和维护**性。

### 3、工厂模式包括哪三种

答：简单工厂模式、工厂方法模式、抽象工厂模式

### 4、工厂模式的使用对比[简单工厂模式和工厂方法模式对比]：

答：简单工厂模式：虽然某种程度上不符合设计原则，但实际使用最多；工厂方法模式：不修改已有类的前提下，通过增加新的工厂类实现扩展；抽象工厂模式：不可以增加产品，可以增加产品族。

    ★ 虽然简单工厂模式不符合理论中的开闭原则，但是工厂方法模式定义的大量子类工厂实现类，管理也非常麻烦，实际开发中使用的最多是简单工厂模式.
------------------------------------------------
## 5、抽象工厂是什么

答：**是工厂的工厂，超级工厂。适合生产一个稳定的产品族**，**采用`抽象工厂模式不需要关心构建过程，只关心什么产品由什么工厂生产即可`**。

### 6、工厂模式的应用场景：

- jdk中calendar的getInstance方法----简单工厂模式
- JDBC中的Connection对象的获取
- Spring中的IOC容器创建管理bean对象
- 反射中Class对象的newInstance方法

### 一、工厂设计模式

#### 1、作用和意义：`实现了创建者和调用者的分离`。

#### ★ 工厂模式的意义：`将实例化对象的代码提取出来，放到一个类(工厂类)中统一管理和维护`，达到和主项目的依赖关系的解耦。从而提高项目的扩展和维护性。

#### 2、三种工厂模式：

##### 简单工厂模式、工厂方法模式、抽象工厂模式

#### 3、 设计模式的依赖抽象原则：

 创建对象实例时，不要直接 new 类, 而是把这个new 类的动作放在一个工厂的方法中，并返回。

 不要让类继承具体类，而是继承抽象类或者是实现interface(接口)

 不要覆盖基类中已经实现的方法

#### 4、核心本质：

**实例化对象不使用new，用工厂方法代替 factory**
 将选择实现类，创建对象统一管理和控制。从而将调用者跟我们的实现类解耦

#### 简单工厂模式（静态工厂模式）

用来生产同一等级结构中的任意产品（对于增加新的产品，需要扩展已有代码）

★ 对于简单工厂模式的举例：消费者买车

情况一：在没有使用简单工厂模式下，消费者(Consumer类)要买车，需要自己 new来构建一辆自己想要买的车。【需要消费者自己制作车 (new 构建 车对象)，则消费者是需要车的内部细节，才能new出车对象】

情况二：使用简单工厂模式下，消费者只需要调用汽车工厂（CarFactory类）的获取车的方法，就可以买车了，不用关系车的创建的各种细节。而汽车工厂（CarFactory类）作用就是来制作车 (new 构建 车对象)的，并为外界提供获取车对象的方法。
```java
public class Consumer {
    public static void main(String[] args) {
        // 1、没有使用简单工厂模式的情况：
        // Car car = new WuLing();
        // Car car1 = new Tesla();

        // 2、使用工厂创建
        Car car = CarFactory.getCar("wuling");
        Car car1 = CarFactory.getCar("tesila");

        car.name();
        car1.name();
    }
}


public interface Car {
    void name();
}

public class WuLing implements Car{

    @Override
    public void name() {
        System.out.println("五菱宏光");
    }
}

public class Tesla implements Car{

    @Override
    public void name() {
        System.out.println("特斯拉");
    }
}

// 静态工厂模式
// 开闭原则
public class CarFactory {

    // 方法一： 不满足开闭原则
    public static Car getCar(String car){
        if(car.equals("wuling")){
            return new WuLing();
        }else if(car.equals("tesila")){
            return new Tesla();
        }else {
            return null;
        }
    }

    // 方法二：
    public static Car geyWuling(){
        return new WuLing();
    }
    public static Car geyTesla(){
        return new Tesla();
    }


}




```



不满足开闭原则的汽车工厂

![image-20231127161026880](C:\Users\dsk\AppData\Roaming\Typora\typora-user-images\image-20231127161026880.png)









满足开闭原则的汽车工厂



![image-20231127161255969](C:\Users\dsk\AppData\Roaming\Typora\typora-user-images\image-20231127161255969.png)





#####  工厂方法模式：通过将简单工厂模式原先的工厂类抽象成接口，然后根据车的种类，决定了抽象工厂接口的子类工厂实现类，并在子类工厂实现类内创建对应车种类的对象

#### 虽然简单工厂模式不符合理论中的开闭原则，但是工厂方法模式定义的大量子类工厂实现类，管理也非常麻烦，`实际开发中使用的最多是简单工厂模式`



#### 4、抽象工厂模式：“工厂的工厂，超级工厂。适合生产一个稳定的产品族”

围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂

##### (1) 定义：

抽象工厂模式提供了一个创建一系列相关或者相互依赖对象的接口，无需指定他们的具体的类（针对整个产品族，产品等级数量相对固定的产品族）

##### (2) 适用场景：

- 客户端（应用层）不依赖于产品类实例如何被创建、实现等细节
- 强调一系列相关的产品对象（属于同一产品族）一起使用创建对象需要大量的重复代码
- 提供一个产品类的库，所有的产品以同样的接口出现，从而使得客户端不依赖于具体实现



![image-20231128034048121](C:\Users\dsk\AppData\Roaming\Typora\typora-user-images\image-20231128034048121.png)







 抽象工厂模式-其实就是工厂方法模式的抽象，体现在将原先的工厂定义为超级工厂接口，且包含的属性成员也是接口。

1、定义一个超级工厂接口IProductFactory：包含两个产品接口(接口属性成员)-手机产品接口IphoneProduct、路由器产品接口IRouterProduct 【产品族】

2、然后超级工厂接口有具体的实现子类-小米工厂XiaomiFactory、华为工厂HuaweiFactory

3、对于超级工厂接口定义的接口属性成员有对应的实现子类

    然后手机产品接口IphoneProduct有具体的实现子类-小米手机实现子类XiaomiPhone、华为手机实现子类HuaweiPhone
    
    同样路由器产品接口IRouterProduct 也有具体的实现子类-小米路由实现子类XiaomiRouter、华为路由实现子类HuaweiRouter
------------------------------------------------




## 2.java的构造者模式（builder）



我们在工作中写代码会遇到一种情况，就是设置一个对象属性值，通常方式有两种：

```java
1. Animal animal=new Animal("3岁",20kg,"牛奶");
2. Animal animal=new Animal();
   animal.setAge("3岁");
   animal.setWeight("20kg");
   animal.setFood("牛奶");

```

**第一种方式:**
  相当于在构造函数里传递参数，但这样加入参数的时候，不能明确的知道往这个对象里加入了什么属性的内容。

**第二种方式:**
  虽然可以根据set函数名看到将要设置的值是什么值，但是这种写发，略显冗余。

**在设计模式中有构造者模式(builder),在类的构造器或静态工厂具有多个参数。设计这种类时，builder模式就是个不错的选择。Demo代码如下：**

```java
public class Purchase {
private final String shipNo;
private final String menuId;
private final String menuName;
private final Double price;

public static class Builder {
    private final String shipNo;
    private String menuId;
    private String menuName;
    private final Double price = 0.0;

    public Builder(String shipNo) {
        this.shipNo = shipNo;
    }

    public Builder menuId(String val) {
        menuId = val;
        return this;
    }

    public Builder menuName(String val){
        menuName=val;
        return this;
    }

    public Purchase build() {
        return new Purchase(this);
    }
}

private Purchase(Builder builder) {
    shipNo = builder.shipNo;
    menuId = builder.menuId;
    menuName = builder.menuName;
    price = builder.price;
}
}

```

其结果就是这种设置属性是多个方法连接的方式

```csharp
  public static void main(String[] args) {
    Purchase p=new Builder("S0001").menuId("11").menuName("宫保").build();
    System.out.println(p.menuName);
    }
```

也有另一种方式，省去代码的builder写法，就是使用lombok

```java
import lombok.Builder;
import lombok.Data;

@Builder
@Data
public class LomBokDemo {

    private String name;
    private Integer age;
    public static void main(String[] args) {
        LomBokDemo wyz = LomBokDemo.builder().age(12).name("张三").build();
        System.out.println(wyz);

    }   
}
```

## 3.Debug 和Trace有何区别?

Debug仅在debug版本的应用程序输出结果,而Trace在debug和release版本的程序中都起作用。













# 三.项目惠顾



aop-annotion 依赖导入

```xml
   <dependencies>
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-context</artifactId>
            <version>5.2.15.RELEASE</version>
        </dependency>
        <dependency>
            <groupId>org.aspectj</groupId>
            <artifactId>aspectjweaver</artifactId>
            <version>1.9.8</version>
        </dependency>
    </dependencies>
```

```java
/**
 * @Pointcut切入点,选择一个或多个连接点的表示方式
 * execution(参数)
 * 标准写法:访问控制修饰符 返回值类型 包名.类名.方法名(参数列表)
 *
 * public void cn.etg.service.UserService.addUser();
 *
 * 访问控制修饰符:可以省略\,返回值类型可以用* 代替 ,表示所有类型
 *
 * 包名使用* 代表任意包,多级包结构可以使用多个* ,使用*.. 代替任意包结构
 *
 * 类名和方法名可以用* 实现通配参数列表
 *      基本类型直接写类型
 *      引用类型 ,写包名.类名
 *      * 表示匹配一个任意类型的参数
 *      ..表示匹配任意类型任意个数的参数
 *      全通配的写法  * *..*.*(..)
 *
 *      UserService的所有void方法
 *      public void  cn.etg.service.UserService.*(..)
 *      service包下所有方法
 *      public * cn.etg.service.*.*(..)
 *
 *      service所有方法
 *      * cn.etg.service.*.*(..)
 
     * 通知advice注解
     * @Around:环绕通知,即包裹连接后点,你写的代码可以在连接点之间和之后执行
     * @Before:连接点之前运行
     * @AfterReturning仅当连接点方法正确返回后执行,就是抛出异常不会执行
     * @AfterThrowing :仅当连接点抛出异常时执行,也就是说,当方法没有抛出异常,而正常返回并不执行
     * @After连接点之后执行
     * @param pjp
     * @return
     * @throws Throwable
     *    @Around
     *     try{
     *         @Before()
     *                 连接点
     *                 @AfterReturning
     *     }catch(Throwable throwable){
     *         @AfterThrowing
     *     }finally{
     *         @After
     *     }
     *     @Around
     */

```



##### restful风格的代码

```java
@DeleteMapping("/del/{id:[0-9]+}") //restful风格
public CommonResult delUser(@PathVariable("id") Integer id){
    Integer integer = userService.delUser(id);
    return CommonResult.success("删除成功",integer);
}
```



##### 常见maven

```xml
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    <!--mybatis-plus依赖-->
    <dependency>
        <groupId>com.baomidou</groupId>
        <artifactId>mybatis-plus-boot-starter</artifactId>
        <version>3.5.1</version>
    </dependency>
    <!-- MySQL8数据库 -->
    <dependency>
        <groupId>mysql</groupId>
        <artifactId>mysql-connector-java</artifactId>
        <version>8.0.33</version>
    </dependency>
    <!--Druid 依赖 -->
    <dependency>
        <groupId>com.alibaba</groupId>
        <artifactId>druid</artifactId>
        <version>1.2.14</version>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <scope>test</scope>
    </dependency>
    <!--lombok依赖-->
    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <version>1.18.20</version>
    </dependency>
    <dependency>
        <groupId>cn.hutool</groupId>
        <artifactId>hutool-all</artifactId>
        <version>5.8.9</version>
    </dependency>
</dependencies>
```

##### router/index.js写法

```js
import Vue from 'vue'
import VueRouter from 'vue-router'

//导入组件

import home from '../views/Home.vue'
import user from '../views/User.vue'
import main from '../views/Main.vue'


Vue.use(VueRouter)
//使用路由
//配置路由映射
const routes=[
   
    {
        name:'main',
        path:'/',
        component:main,
        redirect:"home",
        children:[
            {
                name:'home',
                path:'home',
                component:home,
            },
            {
                name:'user/:username',
                path:'user',
                component:user,
            },

        ]
    },
]

//创建路由实例

const router=new VueRouter({
    routes
})

//
export default router
```





```
let v=new Vue({
    el:"#app",
    data:function (){
        return {
            users:[]
        }
    },
    methods:{
       list(){
           axios.get("/user/list").then(function(response){
               //打印响应数据
               console.log(response.data.data);
               this.users=response.data.data;
           });
       }
    },
    created(){
        this.list();
    }

});
```

```html
<script src="https://unpkg.com/axios/dist/axios.min.js"></script>
```

```js
axios.get('/user', {
    params: {
      ID: 12345
    }
  })
  .then(function (response) {
    console.log(response);
  })
  .catch(function (error) {
    console.log(error);
  })
  .then(function () {
    // always executed
  });  
```

```java
Instant now = Instant.now();
Timestamp timestamp = new Timestamp(now.toEpochMilli());
user.setUpdateDate(timestamp);
```

##### 如果是使用`Java`后台并且传回来的数据格式是`timestamp`那么JS得到的就是一个时间戳。

```js
var d = new Date(data) //data 表示的是timestamp的时间戳
var date = new Date(时间戳); //获取一个时间对象,也可以直接new Date();这样就是当前时间。

date.getFullYear();  // 获取完整的年份(4位,1970)
date.getMonth();  // 获取月份(0-11,0代表1月,进行显示的时候要加一)
date.getDate();  // 获取日(1-31)
date.getTime();  // 获取时间(从1970.1.1开始的毫秒数)
date.getHours();  // 获取小时数(0-23)，
date.getMinutes();  // 获取分钟数(0-59)
date.getSeconds();  // 获取秒数(0-59)

[男]?[^女]?
```



第三方bean用注解@Bean方法返回值获得默认bean名为方法名



@Bean时参数按类型注入无需写@Autowired注解

目不转睛持之以恒永垂不朽的看着

# 四.项目总结

```xml




1.业务  Controller
    1.注册  前端DTO  转为实体    service  将数据交给Dao/mapper  用实体存入到数据库
    2.登录  前端DTO 转为实体    service  将数据交给Dao/mapper  用实体存入到数据库
    3.列表   /list  获取   后端DB数据 实体 传到前端
    4.列表+分页     后端DB数据取出存到-> 实体 ->service->前端


2.开发过程(注意:入门级)
    1.写pojo
    2.写dao
    3.写service
    4.写controller


CommonResult<T> T是用来渲染页面的
T数据
渲染页面:  数据显示在页面上
            list一条一条的显示
            将数据加载页面上


            @RequestBody 前端json数据转对象
            @ResponseBody 后端对象转json 响应-> postman (json格式数据)
            CR
            CR

控制器原则: 不处理如何异常,只负责获得正确的数据,与前端交互(对象与json的转换),异常交给service


静态页面
    1.login.html
    2.reg.html
    3.list.html

    写在resources/static文件夹下面

json格式数据:

    {"key":value,"key1":"value1"}  key必须是字符串  value类型是任意的


同步刷新
--------------------------
    请求form  action  syyo
B  --->  S

    响应  submit
B  <---  S
----------------------------

局部异步响应(异步请求)
--------------------------
        |--->     请求axios     post
       |                     响应 |
       |                         V
B  <-->| -<---vue响应---then<----Server

    响应then  submit
B  <---  S
----------------------------

axios 是ajax的库

获得数据


post  表单中method为post时 使用post  //加密 上传文件  隐私的
其他都是get

========================================================
1.制作页面  Element-vue

vue 2.0
前后端分离操作步骤:
1.在前端项目创建新的页,复制element-ui组件
2.后端跑起来
观察方法参数值
与控制器参数如何匹配
先后端开发,通过postman跑通接口获得数据  json数据  数据正确后
3.写页面  2.异步处理axios  3.渲染页面 (模板语法) v-? text html  model  bind on for 等模板语法


4.文件上传



服务端要接收客户端页面上传的文件，通常都会使用Apache的两个组件:
        commons-fileupload
		commons-io

<!--进行上传文件所需要的maven依赖-->
    <dependency>
      <groupId>commons-fileupload</groupId>
      <artifactId>commons-fileupload</artifactId>
      <version>1.3.1</version>
    </dependency>
    <dependency>
      <groupId>commons-io</groupId>
      <artifactId>commons-io</artifactId>
      <version>2.4</version>
    </dependency>




```

五,使用Axios发起multipart request请求的方法

```js
import util from '../utils/util'
import {baseURL} from "../utils/request";
import axios from "axios";
export default {
  name: "Menu",
  data(){
    return {
      headers:{}
    }
  },
  created() {
    this.load()
    let user=localStorage.getItem("user")?JSON.parse(localStorage.getItem("user")):null
    if(user){
      this.headers['token'] = user.token
    }
    this.headers['Content-Type']='multipart/form-data'

  },
    
    
   // 第一种方式
axios.post(baseURL+"/upload/upload-qny", formData,
    {headers: this.headers})
    .then(res=>{
      console.log(res.data)
      //第二步，将返回的url替换成文本原位置
      $vm.$img2Url(pos,res.data.fileUrl)
    })
    
    
    


```

### //导表语句

insert into user (name,age)
select name,age from stu;



#### --导入sql

-- source d:\exam.sql;





1.知识点

2.项目

3.复习

# Redis

关系型  mysql  库表   sql查询结构化语言        

非关系  redis  内存 数据结构key-value	 命令











spring 容器 		目的:反射创建对象

1.pom文件导入jar

2. java的配置文件 从jar中的class注入到项目中  IOC/DI 
3. yaml或properity配置bean中的参数

bean

xml  

id  首字母小写  方法名    CLASS  包名.类名





set  key  value

//

##### String字符串命令

[ SET key value](https://www.redis.net.cn/order/3544.html) 设置指定 key 的值

[ GET key](https://www.redis.net.cn/order/3545.html) 获取指定 key 的值。

[GETRANGE key start end](https://www.redis.net.cn/order/3546.html) 返回 key 中字符串值的子字符

[GETSET key value](https://www.redis.net.cn/order/3547.html) 将给定 key 的值设为 value ，并返回 key 的旧值(old value)。

[ MGET key1 [key2..\]](https://www.redis.net.cn/order/3549.html) 获取所有(一个或多个)给定 key 的值。

[ STRLEN key](https://www.redis.net.cn/order/3554.html) 返回 key 所储存的字符串值的长度。

[MSET key value [key value ...\]](https://www.redis.net.cn/order/3555.html) 同时设置一个或多个 key-value 对。

[INCR key](https://www.redis.net.cn/order/3558.html) 将 key 中储存的数字值增一。



##### 哈希

HMSet k v<f,v> 

​				k  {FV  FV  FV}

 HMSET w3ckey name "redis tutorial" description "redis basic commands for caching" likes 20 visitors 23000

HGETALL w3ckey

1. 1) "name"
2. 2) "redis tutorial"
3. 3) "description"
4. 4) "redis basic commands for caching"
5. 5) "likes"
6. 6) "20"
7. 7) "visitors"
8. 8) "23000"





[ HKEYS key](https://www.redis.net.cn/order/3570.html) 获取所有哈希表中的字段

[HDEL key field2 [field2\]](https://www.redis.net.cn/order/3564.html) 删除一个或多个哈希表字段

[HEXISTS key field](https://www.redis.net.cn/order/3565.html) 查看哈希表 key 中，指定的字段是否存在。

[HLEN key](https://www.redis.net.cn/order/3571.html) 获取哈希表中字段的数量

[HGETALL key](https://www.redis.net.cn/order/3567.html) 获取在哈希表中指定 key 的所有字段和值



##### Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素导列表的头部（左边）或者尾部（右边）==>队列 list



[LRANGE key start stop](https://www.redis.net.cn/order/3586.html) 获取列表指定范围内的元素

[ LPUSH key value1 [value2\]](https://www.redis.net.cn/order/3584.html) 将一个或多个值插入到列表头部

[ LINDEX key index](https://www.redis.net.cn/order/3580.html) 通过索引获取列表中的元素

[ LPOP key](https://www.redis.net.cn/order/3583.html) 移出并获取列表的第一个元素

[RPUSHX key value](https://www.redis.net.cn/order/3593.html) 为已存在的列表添加值

[ RPUSH key value1 [value2\]](https://www.redis.net.cn/order/3592.html) 在列表中添加一个或多个值

[RPOP key](https://www.redis.net.cn/order/3590.html) 移除并获取列表最后一个元素

redis项目依赖



##### Redis的Set是string类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。

SADD w3ckey mongodb

SMEMBERS w3ckey

 smembers wkey

[SCARD key](https://www.redis.net.cn/order/3595.html) 获取集合的成员数

[ SDIFFSTORE destination key1 [key2\]](https://www.redis.net.cn/order/3597.html) 返回给定所有集合的差集并存储在 destination 中

[ SINTERSTORE destination key1 [key2\]](https://www.redis.net.cn/order/3599.html) 返回给定所有集合的交集并存储在 destination 中

```
<dependencies>
    <!--SpringBoot通用依赖模块-->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-actuator</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-aop</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <scope>test</scope>
    </dependency>
    <!--redis依赖配置-->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-redis</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-cache</artifactId>
    </dependency>

    <!-- https://mvnrepository.com/artifact/org.apache.commons/commons-pool2 -->
    <dependency>
        <groupId>org.apache.commons</groupId>
        <artifactId>commons-pool2</artifactId>
        <version>2.12.0</version>
    </dependency>
</dependencies>
```

实例变量和静态变量区别

实例变量属于对象 静态变量属于类

对象.   类名.

堆    方法区

多分  一份

相同点:  类中方法外



java是值传递还是引用传递

值传递

引用类型传地址  基本类型传值

抽象类和接口的区别

String str=“abc”

String str=new String(“cba”)  常量池  堆         堆		  驿   				    方法区 

​																			对象	 局部变量        		方法static  常量池



wait和sleep的区别

### *实现notify和wait|实现wait-notify的方法。

因为线程之间是抢占式执行的，所以线程之间执行的先后顺序难以预知。但是实际开发中，我们希望线程之间的执行顺序是能被掌控的，比如线程2开始之前，需要线程1的某个任务先被执行。也就是说,很多时候,我们需要线程之间能协调工作，这就主要涉及到以下三个方法(均为Object类的方法)：

wait()：让当前线程进行等待状态
notify()：唤醒在当前状态上等待的线程(只能唤醒一个等待该对象的对象锁的线程)
notifyAll()：唤醒在当前状态上等待的线程(能唤醒所有等待该对象的对象锁的线程)
1.wait()方法
wait方法的作用是使当前线程进入阻塞等待.

当代码执行到wait()方法时,线程会经过以下过程:

当前线程释放锁.
使当前执行代码的线程进行等待(把线程放到等待队列中).
满足一定条件时线程被唤醒,重新尝试获取这个锁.
注意:wait()必须要和synchronized一起使用.因为wait()方法一执行就要先释放锁,所以wait必须要放到synchronized中使用.且synchronized锁的对象是和调用wait方法的对象是同一个对象.

wait使用示例:



运行这段代码:

 发现代码就停在这里了,这时我们需要使用另外一个唤醒的方法notify().让其能继续进行下去.

wait 结束等待的条件:

其他线程调用该对象的notify方法
其他线程调用该等待线程的interrupted方法,导致wait抛出InterruptedException异常
wait等待的时间超时(wait方法重载了一个带有timeout参数的方法,来指定等待时间)
2. notify方法
notify方法的作用是唤醒等待的线程.

方法notify()要在同步方法或同步方法块中调用,该方法是用来通知那些正在等待该对象的对象锁的其他线程,对其发出通知notify,并使他们重新获取该对象的对象锁.

如果有多个线程都在等待,则线程调度器会随机挑选出一个呈wait状态的线程,没有先来后到这一说.

在notify方法后,当前线程不会马上释放该对象锁,要等到执行notify()方法的线程将程序执行完,也就是退出同步代码块之后才会释放对象锁.

使用notify方法唤醒线程:



分析以上代码,线程t1执行到locker.wait()时释放锁,阻塞等待;t2线程拿到锁,执行到locker.notify()时,将t1线程唤醒,但是此时t2线程还不会先将锁释放,会先将同步代码块执行完才会释放锁,之后t1线程再次开始执行.运行结果如下:



wait和notify方法要搭配使用,比如实现一个场景:线程1与线程2并发执行,线程1执行到某一条件时需要拿到线程2的结果才能继续往下执行,这时就可以用wait方法使其进入等待,当线程2将结果计算出来后,可用notify方法将等待该对象的对象锁的某一线程唤醒,使其重新拿到锁,继续执行.

notifyAll()方法:

notify方法只是唤醒一个线程,而notifyAll()方法可以一次唤醒所有的等待线程,比如有3个线程都在等待该对象的对象锁,那么notifyAll()方法可将这3个线程全部唤醒,但是这3个线程仍需要竞争这一把锁.

wait VS sleep

wait需要搭配synchronized使用,而sleep不需要;

wait是Object的方法,sleep是Thread的静态方法.

二者其实没有任何可比性而言.wait是用于线程之间的通信的,而sleep是让线程阻塞一段时间的.唯一的相同点就是都可以让线程停止执行一段时间.
------------------------------------------------
版权声明：本文为CSDN博主「哆啦A梦的110」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/m0_63039919/article/details/129224741

###  *Callable 和 Future 接口创建线程

从Java1.5版本开始，就提供了 Callable 和 Future 来创建线程，这种方式也是在Java程序员面试中经常会被问到的问题。

上一小节介绍了Thread和Runnable两种方式创建线程，不过这两种方式创建线程都有一个缺陷：在执行完任务之后无法获取执行结果。 如果需要获取执行结果，就必须通过共享变量或者使用线程通信的方式来达到效果，这样使用起来就比较麻烦。

而如果使用Callable和Future，通过它们就可以在任务执行完毕之后得到任务执行结果。

本小节你需要掌握的知识有：

1.什么是Callable和Future；

2.如何通过Callable和Future创建线程。

Callable和Future

它们俩其实挺有意思，在运行的时候各司其职，Callable产生结果，Future获取结果。

使用步骤如下：

创建 Callable 接口的实现类，并实现 call() 方法，该 call() 方法将作为线程执行体，并且有返回值；

创建 Callable 实现类的实例，使用 FutureTask 类来包装 Callable 对象，该 FutureTask 对象封装了该 Callable 对象的 call() 方法的返回值；

使用 FutureTask 对象作为 Thread 对象的 target 创建并启动新线程；

调用 FutureTask 对象的 get() 方法来获得子线程执行结束后的返回值。

接下来通过一个示例来学习这两个对象的使用：

public class Test {
public static void main(String[] args) {
CallableThreadTest cts = new CallableThreadTest();
// 接收
FutureTask<Integer> ft = new FutureTask<>(cts);

new Thread(ft, "有返回值的线程").start();
for (int i = 0; i < 30; i++) {
System.out.println( "main" + " 的循环变量i的值：" + i);
}

try {
System.out.println("子线程的返回值：" + ft.get());
} catch (Exception e) {
e.printStackTrace();
}
}
}

class CallableThreadTest implements Callable<Integer> {

public Integer call() throws Exception {
int i = 0;
for (; i < 30; i++) {
System.out.println(Thread.currentThread().getName() + " " + i);
}
return i;
}
}
运行这段程序你应该可以获取到类似如下结果（每次运行的结果不一致）： ... ... main 的循环变量i的值：28 main 的循环变量i的值：29 有返回值的线程 23 有返回值的线程 24 有返回值的线程 25 有返回值的线程 26 有返回值的线程 27 有返回值的线程 28 有返回值的线程 29 子线程的返回值：30

由于输出过长，省略了部分结果，可以发现在最后接收到了子线程的返回值。

在实现Callable接口中，此时不再是run()方法了，而是call()方法，此call()方法作为线程执行体，同时还具有返回值！

细心的你会发现这个结果是call函数的返回值，怎么拿到这个返回值的呢？是通过FutureTask拿到的，使用ft.get()方法即可获得线程的返回值，这就是一个简单的使用Callable和Future的过程了。

关于Callable和Future的使用，以及他们的常用函数，我们将会在后续的实训中学习。

本题详解：
（一）

ThreadCallable t1=new ThreadCallable(num);
FutureTask<Integer> ft1=new FutureTask<>(t1);
Thread thread1=new Thread(ft1,"thread1");
这三句代码的作用是创建一个可以在另一个线程中执行的可调用对象，并将其封装在一个FutureTask对象中，最后将该FutureTask对象传递给一个新的线程对象，以便在该线程中执行这个可调用对象。

具体来说：

第一行代码创建了一个ThreadCallable对象t1，它实现了Callable接口，该接口表示一个可调用的任务，可以在另一个线程中执行，并返回一个结果。

第二行代码创建了一个FutureTask对象ft1，它是一个可调用的任务，它封装了t1对象，可以在另一个线程中执行，并返回一个结果。FutureTask是一种特殊的RunnableFuture，它表示一个可以取消的异步计算任务，它可以执行Callable或Runnable任务，并保存计算结果。

第三行代码创建了一个Thread对象thread1，它接收一个FutureTask对象ft1作为参数，并将其封装在新的线程中执行，线程的名称是“thread1”。

综上所述，这三句代码的作用是创建一个可在另一个线程中执行的任务，并将其封装在一个FutureTask对象中，最后将该FutureTask对象传递给一个新的线程对象，以便在该线程中执行这个任务。

（二）

try{
	System.out.println("线程的返回值为："+ft1.get());
}catch(Exception e){
	e.printStackTrace();
}
这段代码的作用是获取线程执行的结果，并将结果打印出来。

具体来说：

第一行代码调用FutureTask对象ft1的get()方法获取线程的返回值。get()方法是一个阻塞方法，如果线程还没有执行完毕，它会一直阻塞直到线程执行完毕并返回结果。

如果线程执行成功，get()方法会返回线程的返回值，这个返回值的类型是Integer。

第二行代码将线程的返回值打印出来，以便查看执行结果。

如果线程执行过程中出现了异常，get()方法会抛出一个异常，这个异常需要在catch块中进行处理。通常情况下，我们会打印异常的堆栈信息，以便查看异常的原因和位置。

因此，这段代码的作用是获取线程执行的结果，并将结果打印出来，同时处理可能出现的异常情况。

（三）

这段代码定义了一个类ThreadCallable，它实现了Callable接口，并指定了泛型参数为Integer，表示线程执行的结果是一个整数。

具体来说：

类中定义了一个成员变量num，表示要计算斐波那契数列的第几项。

类中定义了一个构造方法ThreadCallable(int num)，用于初始化成员变量num。

类中定义了另一个构造方法ThreadCallable()，这个构造方法没有参数，什么也不做，可能是为了方便创建对象而定义的。

类中实现了call()方法，这个方法是Callable接口中的一个方法，表示线程需要执行的任务。在这个方法中，调用了getNum(num)方法计算斐波那契数列的第num项，并将结果返回。

类中定义了一个私有方法getNum(int num)，这个方法用递归的方式计算斐波那契数列的第num项。当num小于3时，返回1；否则，返回getNum(num-1) +getNum(num-2)的结果。

因此，这段代码的作用是定义了一个线程任务，用于计算斐波那契数列的第num项，并将结果作为线程的返回值。这个任务使用递归的方式实现，当num小于3时，返回1；否则，返回前两项的和。
------------------------------------------------
版权声明：本文为CSDN博主「MSY～学习日记分享」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/weixin_54570972/article/details/129813150

### `@Param

在这个例子中，`@Param("id")`和`@Param("name")`注解告诉MyBatis，传递给这个方法的参数应该被命名为"id"和"name"。然后，你可以在你的SQL语句中使用这些参数名称，例如：

EXISTS的使用方法



```cobol
EXISTS 是判断是否存在,和in类似,但效率要比in高


SELECT * FROM  EMP (基础表)  WHERE  EMPNO > 0  AND  EXISTS (SELECT ‘X'  FROM DEPT  WHERE  DEPT.DEPTNO = EMP.DEPTNO  AND  LOC = ‘MELB')


SELECT  * FROM  EMP (基础表)  WHERE  EMPNO > 0  AND  DEPTNO IN(SELECT DEPTNO  FROM  DEPT  WHERE  LOC = ‘MELB')
```

## 红黑树简介

红黑树是一种自平衡的二叉查找树，是一种高效的查找树。它是由 Rudolf Bayer 于1972年发明，在当时被称为对称二叉 B 树(symmetric binary B-trees)。后来，在1978年被 Leo J. Guibas 和 Robert Sedgewick 修改为如今的红黑树。

红黑树具有良好的效率，它可在 O(logN) 时间内完成查找、增加、删除等操作。因此，红黑树在业界应用很广泛，比如 Java 中的 TreeMap，JDK 1.8 中的 HashMap、C++ STL 中的 map 均是基于红黑树结构实现的。

考虑到红黑树是一种被广泛应用的数据结构，所以我们很有必要去弄懂它。



![img](https://pic1.zhimg.com/80/v2-39965fba3e7e0ceea2deba09a0446348_720w.webp)



## 红黑树的性质

学过二叉查找树的同学都知道，普通的二叉查找树在极端情况下可退化成链表，此时的增删查效率都会比较低下。

为了避免这种情况，就出现了一些自平衡的查找树，比如 AVL，红黑树等。这些自平衡的查找树通过定义一些性质，将任意节点的左右子树高度差控制在规定范围内，以达到平衡状态。

以红黑树为例，红黑树通过如下的性质定义实现自平衡：

> 节点是红色或黑色。
> 根是黑色。
> 所有叶子都是黑色（叶子是NIL节点）。
> 每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）
> 从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点（简称黑高）。

有了上面的几个性质作为限制，即可避免二叉查找树退化成单链表的情况。

但是，仅仅避免这种情况还不够，这里还要考虑某个节点到其每个叶子节点路径长度的问题。

如果某些路径长度过长，那么，在对这些路径上的及诶单进行增删查操作时，效率也会大大降低。

这个时候性质4和性质5用途就凸显了，有了这两个性质作为约束，即可保证任意节点到其每个叶子节点路径最长不会超过最短路径的2倍。原因如下：

当某条路径最短时，这条路径必然都是由黑色节点构成。当某条路径长度最长时，这条路径必然是由红色和黑色节点相间构成（性质4限定了不能出现两个连续的红色节点）。而性质5又限定了从任一节点到其每个叶子节点的所有路径必须包含相同数量的黑色节点。

此时，在路径最长的情况下，路径上红色节点数量 = 黑色节点数量。该路径长度为两倍黑色节点数量，也就是最短路径长度的2倍。举例说明一下，请看下图：



![img](https://pic1.zhimg.com/80/v2-c5ec8ec8eb6441873cd900e03837c5bc_720w.webp)



上图画出了从根节点 M 出发的到其叶子节点的最长和最短路径。这里偷懒只画出了两条最长路径，实际上最长路径有4条，分别为：

M -> Q -> O -> N

M -> Q -> O -> p

M -> Q -> Y -> X

M -> Q -> Y -> Z

长度为4，最短路径为 M -> E，长度为2。最长路径的长度正好为最短路径长度的2倍。

前面说了关于红黑树的一些性质，这里还需要补充一些其他方面的东西。在红黑树简介一节中说到红黑树被发明出来的时候并不叫红黑树，而是叫做对称二叉 B 树，从名字中可发现红黑树和 B 树（这里指的是2-3树）或许有一定的关联，事实也正是如此。

如果对红黑树的性质稍加修改，就能让红黑树和B树形成一一对应的关系。关于红黑树和 B 树关系的细节这里不展开说明了，有兴趣的同学可以参考《算法》第4版，那本书上讲的很透彻。

## 红黑树操作

红黑树的基本操作和其他树形结构一样，一般都包括查找、插入、删除等操作。前面说到，红黑树是一种自平衡的二叉查找树，既然是二叉查找树的一种，那么查找过程和二叉查找树一样，比较简单，这里不再赘述。

相对于查找操作，红黑树的插入和删除操作就要复杂的多。尤其是删除操作，要处理的情况比较多，不过大家如果静下心来去看，会发现其实也没想的那么难。好了，废话就说到这，接下来步入正题吧。

## 旋转操作

在分析插入和删除操作前，这里需要插个队，先说明一下旋转操作，这个操作在后续操作中都会用得到。

旋转操作分为左旋和右旋，左旋是将某个节点旋转为其右孩子的左孩子，而右旋是节点旋转为其左孩子的右孩子。这话听起来有点绕，所以还是请看下图：



![img](https://pic1.zhimg.com/80/v2-75bdfdabdc54aef5c0fd07e33e340d74_720w.webp)



上图包含了左旋和右旋的示意图，这里以右旋为例进行说明，右旋节点 M 的步骤如下：

1. 将节点 M 的左孩子引用指向节点 E 的右孩子
2. 将节点 E 的右孩子引用指向节点 M，完成旋转



![img](https://pic1.zhimg.com/80/v2-6a1fdb1dc9fe11c6fb8910daa1886534_720w.webp)



上面分析了右旋操作，左旋操作与此类似，大家有兴趣自己画图试试吧，这里不再赘述了。旋转操作本身并不复杂，这里先分析到这吧。

## 插入

红黑树的插入过程和二叉查找树插入过程基本类似，不同的地方在于，红黑树插入新节点后，需要进行调整，以满足红黑树的性质。性质1规定红黑树节点的颜色要么是红色要么是黑色，那么在插入新节点时，这个节点应该是红色还是黑色呢？

答案是红色，原因也不难理解。如果插入的节点是黑色，那么这个节点所在路径比其他路径多出一个黑色节点，这个调整起来会比较麻烦（参考红黑树的删除操作，就知道为啥多一个或少一个黑色节点时，调整起来这么麻烦了）。

如果插入的节点是红色，此时所有路径上的黑色节点数量不变，仅可能会出现两个连续的红色节点的情况。这种情况下，通过变色和旋转进行调整即可，比之前的简单多了。

接下来，将分析插入红色节点后红黑树的情况。这里假设要插入的节点为 N，N 的父节点为 P，祖父节点为 G，叔叔节点为 U。插入红色节点后，会出现5种情况，分别如下：

**情况一：**

插入的新节点 N 是红黑树的根节点，这种情况下，我们把节点 N 的颜色由红色变为黑色，性质2（根是黑色）被满足。同时 N 被染成黑色后，红黑树所有路径上的黑色节点数量增加一个，性质5（从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点）仍然被满足。



![img](https://pic2.zhimg.com/80/v2-02ba6d02bffc15948e04c6aa6f716605_720w.webp)



**情况二：**

N 的父节点是黑色，这种情况下，性质4（每个红色节点必须有两个黑色的子节点）和性质5没有受到影响，不需要调整。



![img](https://pic2.zhimg.com/80/v2-201853b1fbb411081b74bd93ad133641_720w.webp)



**情况三：**

N 的父节点是红色（节点 P 为红色，其父节点必然为黑色），叔叔节点 U 也是红色。由于 P 和 N 均为红色，所有性质4被打破，此时需要进行调整。

这种情况下，先将 P 和 U 的颜色染成黑色，再将 G 的颜色染成红色。此时经过 G 的路径上的黑色节点数量不变，性质5仍然满足。但需要注意的是 G 被染成红色后，可能会和它的父节点形成连续的红色节点，此时需要递归向上调整。



![img](https://pic3.zhimg.com/80/v2-5be69b528010012fee19f0bf86193eb2_720w.webp)



**情况四：**

N 的父节点为红色，叔叔节点为黑色。节点 N 是 P 的右孩子，且节点 P 是 G 的左孩子。此时先对节点 P 进行左旋，调整 N 与 P 的位置。接下来按照情况五进行处理，以恢复性质4。



![img](https://pic2.zhimg.com/80/v2-9f9247d41e7648cc8d0947e3da642a29_720w.webp)



这里需要特别说明一下，上图中的节点 N 并非是新插入的节点。当 P 为红色时，P 有两个孩子节点，且孩子节点均为黑色，这样从 G 出发到各叶子节点路径上的黑色节点数量才能保持一致。既然 P 已经有两个孩子了，所以 N 不是新插入的节点。

情况四是由以 N 为根节点的子树中插入了新节点，经过调整后，导致 N 被变为红色，进而导致了情况四的出现。考虑下面这种情况（PR 节点就是上图的 N 节点）：



![img](https://pic3.zhimg.com/80/v2-e1d6fe954a2ba866ce351ed9d437e0ce_720w.webp)



如上图，插入节点 N 并按情况三处理。此时 PR 被染成了红色，与 P 节点形成了连续的红色节点，这个时候就需按情况四再次进行调整。

**情况五：**

N 的父节点为红色，叔叔节点为黑色。N 是 P 的左孩子，且节点 P 是 G 的左孩子。此时对 G 进行右旋，调整 P 和 G 的位置，并互换颜色。经过这样的调整后，性质4被恢复，同时也未破坏性质5。



![img](https://pic2.zhimg.com/80/v2-dd3f7f7873967f9693d3ec5a81fdd739_720w.webp)



## 插入总结

上面五种情况中，情况一和情况二比较简单，情况三、四、五稍复杂。但如果细心观察，会发现这三种情况的区别在于叔叔节点的颜色，如果叔叔节点为红色，直接变色即可。如果叔叔节点为黑色，则需要选选择，再交换颜色。当把这三种情况的图画在一起就区别就比较容易观察了，如下图：



![img](https://pic3.zhimg.com/80/v2-36af4bd9f695551261f547c27ffce862_720w.webp)



## 删除

相较于插入操作，红黑树的删除操作则要更为复杂一些。删除操作首先要确定待删除节点有几个孩子，如果有两个孩子，不能直接删除该节点。而是要先找到该节点的前驱（该节点左子树中最大的节点）或者后继（该节点右子树中最小的节点），然后将前驱或者后继的值复制到要删除的节点中，最后再将前驱或后继删除。

由于前驱和后继至多只有一个孩子节点，这样我们就把原来要删除的节点有两个孩子的问题转化为只有一个孩子节点的问题，问题被简化了一些。我们并不关心最终被删除的节点是否是我们开始想要删除的那个节点，只要节点里的值最终被删除就行了，至于树结构如何变化，这个并不重要。

红黑树删除操作的复杂度在于删除节点的颜色，当删除的节点是红色时，直接拿其孩子节点补空位即可。因为删除红色节点，性质5（从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点）仍能够被满足。

当删除的节点是黑色时，那么所有经过该节点的路径上的黑节点数量少了一个，破坏了性质5。如果该节点的孩子为红色，直接拿孩子节点替换被删除的节点，并将孩子节点染成黑色，即可恢复性质5。但如果孩子节点为黑色，处理起来就要复杂的多。分为6种情况，下面会展开说明。

在展开说明之前，我们先做一些假设，方便说明。这里假设最终被删除的节点为X（至多只有一个孩子节点），其孩子节点为N，X的兄弟节点为S，S的左节点为 SL，右节点为 SR。接下来讨论是建立在节点 X 被删除，节点 N 替换X的基础上进行的。

这里说明把被删除的节点X特地拎出来说一下的原因是防止大家误以为节点N会被删除，不然后面就会看不明白。



![img](https://pic3.zhimg.com/80/v2-c7c83ee8be475f338179604a74bb3f86_720w.webp)



在上面的基础上，接下来就可以展开讨论了。红黑树删除有6种情况，分别是：

**情况一：**

N 是新的根。在这种情形下，我们就做完了。我们从所有路径去除了一个黑色节点，而新根是黑色的，所以性质都保持着。

上面是维基百科中关于红黑树删除的情况一说明，由于没有配图，看的有点晕。经过思考，我觉得可能会是下面这种情形：

要删除的节点 X 是根节点，且左右孩子节点均为空节点，此时将节点 X 用空节点替换完成删除操作。

可能还有其他情形，大家如果知道，烦请告知。

**情况二：**

S 为红色，其他节点为黑色。这种情况下可以对 N 的父节点进行左旋操作，然后互换 P 与 S 颜色。但这并未结束，经过节点 P 和 N 的路径删除前有3个黑色节点（P -> X -> N），现在只剩两个了（P -> N）。比未经过 N 的路径少一个黑色节点，性质5仍不满足，还需要继续调整。不过此时可以按照情况四、五、六进行调整。



![img](https://pic4.zhimg.com/80/v2-6f7fd7d7f594e3b231c526aa11a219eb_720w.webp)



**情况三：**

N 的父节点，兄弟节点 S 和 S 的孩子节点均为黑色。这种情况下可以简单的把 S 染成红色，所有经过 S 的路径比之前少了一个黑色节点，这样经过 N 的路径和经过 S 的路径黑色节点数量一致了。但经过 P 的路径比不经过 P 的路径少一个黑色节点，此时需要从情况一开始对 P 进行平衡处理。



![img](https://pic3.zhimg.com/80/v2-f1cb182ae6c6ceba9c71c282e05c20c2_720w.webp)



**情况四：**

N 的父节点是红色，S 和 S 孩子为黑色。这种情况比较简单，我们只需交换 P 和 S 颜色即可。这样所有通过 N 的路径上增加了一个黑色节点，所有通过 S 的节点的路径必然也通过 P 节点，由于 P 与 S 只是互换颜色，并不影响这些路径。



![img](https://pic1.zhimg.com/80/v2-fccb3b9e2d270d15375754798bf9dfd4_720w.webp)



这里需要特别说明一下，上图中的节点 N 并非是新插入的节点。当 P 为红色时，P 有两个孩子节点，且孩子节点均为黑色，这样从 G 出发到各叶子节点路径上的黑色节点数量才能保持一致。既然 P 已经有两个孩子了，所以 N 不是新插入的节点。

情况四是由以 N 为根节点的子树中插入了新节点，经过调整后，导致 N 被变为红色，进而导致了情况四的出现。考虑下面这种情况（PR 节点就是上图的 N 节点）：



![img](https://pic2.zhimg.com/80/v2-0f118be1b049211a94689c9006ce3dd5_720w.webp)



**情况五：**

S 为黑色，S 的左孩子为红色，右孩子为黑色。N 的父节点颜色可红可黑，且 N 是 P 左孩子。这种情况下对 S 进行右旋操作，并互换 S 和 SL 的颜色。此时，所有路径上的黑色数量仍然相等，N 兄弟节点的由 S 变为了 SL，而 SL 的右孩子变为红色。接下来我们到情况六继续分析。



![img](https://pic4.zhimg.com/80/v2-41ab641f65f699ef03cfdd18970eac2f_720w.webp)



**情况六：**

S 为黑色，S 的右孩子为红色。N 的父节点颜色可红可黑，且 N 是其父节点左孩子。这种情况下，我们对 P 进行左旋操作，并互换 P 和 S 的颜色，并将 SR 变为黑色。因为 P 变为黑色，所以经过 N 的路径多了一个黑色节点，经过 N 的路径上的黑色节点与删除前的数量一致。对于不经过 N 的路径，则有以下两种情况：

1. 该路径经过 N 新的兄弟节点 SL ，那它之前必然经过 S 和 P。而 S 和 P 现在只是交换颜色，对于经过 SL 的路径不影响。
2. 该路径经过 N 新的叔叔节点 SR，那它之前必然经过 P、 S 和 SR，而现在它只经过 S 和 SR。在对 P 进行左旋，并与 S 换色后，经过 SR 的路径少了一个黑色节点，性质5被打破。另外，由于 S 的颜色可红可黑，如果 S 是红色的话，会与 SR 形成连续的红色节点，打破性质4（每个红色节点必须有两个黑色的子节点）。此时仅需将 SR 由红色变为黑色即可同时恢复性质4和性质5（从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。）。



![img](https://pic4.zhimg.com/80/v2-b8b8b84890d17764f209b676eda04dff_720w.webp)



## 删除总结

红黑树删除的情况比较多，大家刚开始看的时候可能会比较晕。可能会产生这样的疑问，为啥红黑树会有这种删除情况，为啥又会有另一种情况，它们之间有什么联系和区别？

和大家一样，我刚开始看的时候也有这样的困惑，直到我把所有情况对应的图形画在一起时，拨云见日，一切都明了了。此时天空中出现了4个字，原来如此、原来如此、原来如此。所以，请看图吧：



![img](https://pic4.zhimg.com/80/v2-70fc7a9e4f92536e8e192b182d6b1a07_720w.webp)



## 总结

红黑树是一种重要的二叉树，应用广泛，但在很多数据结构相关的书本中出现的次数并不多。很多书中要么不说，要么就一笔带过，并不会进行详细的分析，这可能是因为红黑树比较复杂的缘故。

我在学习红黑树的时候也找了很多资料，但总体感觉讲的都不太好。尤其是在我学习删除操作的时候，很多资料是实在人看不下去，看的我很痛苦。直到我看到维基百科上关于红黑树的分析时，很是欣喜。

这篇文章分析的很有条理，言简意赅，比很多资料好了太多。本文对红黑树的分析也主要参考了维基百科中的红黑树分析，并对维基百科中容易让人产生疑问和误解的地方进行了说明。同时维基百科中文版红黑树文中的图片较为模糊，这里我重新进行了绘制。

需要说明的是，维基百科中文版无法打开了，文中关于维基百科的链接都是英文版的。另外在给大家推荐一个数据结构可视化的网站，里面包含常见数据结构可视化过程，地址为：

> [https://www.cs.usfca.edu/~galles/visualization/Algorithms.html](https://link.zhihu.com/?target=https%3A//www.cs.usfca.edu/~galles/visualization/Algorithms.html)

另外，由于红黑树本身比较复杂，实现也较为复杂。在写这篇文章之前，我曾尝试过用 Java 语言实现红黑树的增删操作，最终只写出了新增节点操作，删除没做出来。而且自己写的新增逻辑实在在太繁琐，写的不好看，没法拿出来 show。

所以最后把 Java 中的 TreeMap 增删相关源码拷出来，按照自己的需求把源码修改了一下，也勉强算是实现了红黑树吧。代码放到了 github 上，传送门 ->

> [https://github.com/code4wt/basic_algorithm/blob/master/src/main/java/search/RBTree.java](https://link.zhihu.com/?target=https%3A//github.com/code4wt/basic_algorithm/blob/master/src/main/java/search/RBTree.java)

最后，如果你也在学习红黑树，希望这篇文章能够帮助到你。另外，由于红黑树本身比较复杂，加之本人水平有限，难免会出一些错误。如果有错，还望大家指出来，我们共同讨论。





# Redis配置



```java
public class RedisConfig {

    @Bean
    public RedisTemplate<String,Object> redisTemplate(RedisConnectionFactory redisConnectionFactory){
        RedisSerializer<Object> serializer=redisSerializer();
        RedisTemplate<String,Object> redisTemplate=new RedisTemplate<>();
        redisTemplate.setConnectionFactory(redisConnectionFactory);
        redisTemplate.setKeySerializer(new StringRedisSerializer());
        redisTemplate.setValueSerializer(serializer);
        redisTemplate.setHashKeySerializer(new StringRedisSerializer());
        redisTemplate.setHashValueSerializer(serializer);
        redisTemplate.afterPropertiesSet();
        return  redisTemplate;
    }
    @Bean
    public RedisSerializer<Object> redisSerializer(){
        Jackson2JsonRedisSerializer<Object> serializer=new Jackson2JsonRedisSerializer<Object>(Object.class);
        ObjectMapper objectMapper=new ObjectMapper();
        objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
        objectMapper.activateDefaultTyping(LaissezFaireSubTypeValidator.instance,ObjectMapper.DefaultTyping.NON_FINAL);
        serializer.setObjectMapper(objectMapper);
        return serializer;
    }

    @Bean
    public RedisService redisService(){
        return new RedisServiceImpl();
    }
}
```

![image-20231206210016746](C:\Users\dsk\AppData\Roaming\Typora\typora-user-images\image-20231206210016746.png)





# spring-security



### config

```java
@Configuration
public class SecurityConfiguration extends WebSecurityConfigurerAdapter {
    //spring security 自带的加密处理类
    @Bean
    public PasswordEncoder passwordEncoder(){
        return new BCryptPasswordEncoder();
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        //白名单,不需要拦截的路径登录的
        //http
        String [] urls={"/**/*.css","/**/*.js","/doc.html","/admin/*","/index.html"};
        http.csrf().disable().authorizeRequests()//开始请求授权
        .mvcMatchers(urls)//匹配某些请求
        .permitAll()//许可,不需要通过认证放行
        .anyRequest()//任何请求
        .authenticated()//要求已经完成认
        .and()
        .formLogin();
        //super.configure(http);
        //调用方法: 当Security认为需要通过认证,但是实际未通过认证,会跳转登录页面
        //未调用:将会报403错误
        //http.formLogin();
    }
}
```



```java
@Service
@Slf4j
public class UserDetalisServiceImpl implements UserDetailsService {
    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        log.debug("用户名:{}",username);
        if (!"root".equals(username)) {
            log.debug("用户名没有匹配信息");
            return null;
        }
        log.debug("用户匹配成功,准备返回此用户名匹配的UserDetail类型对象");
        UserDetails userDetails= User.builder()
                                     .username(username)//用户名
                                     .password("$2a$10$n/poSlc1OXJvp8yl4lF4ruZdqMomU0I6Ddr7hoIq5.yAMUTHFazbe")//密码    当使用此密码UUID不再生成
                                     .disabled(false)//是否被启用
                                     .accountLocked(false)//是否被锁定
                                     .accountExpired(false)//是否过期
                                     .credentialsExpired(false)//凭证是否过期
                                     .authorities("这是一个临时使用的权限")//临时权限
                                     .build();
        return userDetails;
    }
}
```



```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
</dependency>
```







maven依赖操作步骤



父类

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.5.12</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>
    <groupId>cn.etg</groupId>
    <artifactId>ploymerproject2039</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>ploymerproject2039</name>
    <description>Demo project for Spring Boot</description>
    <!--父项目配置packing 为pom-->
<!--    此标签默认值是jar  各个子项目可以不必配置此标签-->
    <packaging>pom</packaging>
    <modules>
        <module>commons</module>
        <module>passport</module>
    </modules>
    <properties>
        <java.version>1.8</java.version>
        <spring-boot.version>2.5.12</spring-boot.version>
        <mysql.version>8.0.33</mysql.version>
        <mybatis-spring-boot-starter.version>2.2.2</mybatis-spring-boot-starter.version>
        <mybatis-plus-spring-boot.version>3.3.0</mybatis-plus-spring-boot.version>
        <pagehelper-spring-boot.version>1.3.0</pagehelper-spring-boot.version>
        <druid-spring-boot.version>1.2.16</druid-spring-boot.version>
        <lombok.version>1.18.20</lombok.version>
        <knife4j-spring-boot.version>2.0.9</knife4j-spring-boot.version>
        <fastjson.version>1.2.75</fastjson.version>
        <jjwt.version>0.9.1</jjwt.version>
        <commons.verson>0.0.1-SNAPSHOT</commons.verson>
    </properties>
    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>cn.etg</groupId>
                <artifactId>commons</artifactId>
                <version>${commons.verson}</version>
            </dependency>
            <!-- JJWT（Java JWT） -->
            <dependency>
                <groupId>io.jsonwebtoken</groupId>
                <artifactId>jjwt</artifactId>
                <version>${jjwt.version}</version>
            </dependency>
            <!-- fastjson：实现对象与JSON的相互转换 -->
            <dependency>
                <groupId>com.alibaba</groupId>
                <artifactId>fastjson</artifactId>
                <version>${fastjson.version}</version>
            </dependency>
            <!-- Knife4j Spring Boot：在线API文档 -->
            <dependency>
                <groupId>com.github.xiaoymin</groupId>
                <artifactId>knife4j-spring-boot-starter</artifactId>
                <version>${knife4j-spring-boot.version}</version>
            </dependency>
            <!-- Mybatis Plus整合Spring Boot的依赖项 -->
            <dependency>
                <groupId>com.baomidou</groupId>
                <artifactId>mybatis-plus-boot-starter</artifactId>
                <version>${mybatis-plus-spring-boot.version}</version>
            </dependency>
            <!-- 基于MyBatis或MyBatis Plus的分页查询框架 -->
            <dependency>
                <groupId>com.github.pagehelper</groupId>
                <artifactId>pagehelper-spring-boot-starter</artifactId>
                <version>${pagehelper-spring-boot.version}</version>
            </dependency>
            <!-- Lombok的依赖项，主要用于简化POJO类的编写 -->
            <dependency>
                <groupId>org.projectlombok</groupId>
                <artifactId>lombok</artifactId>
                <version>${lombok.version}</version>
            </dependency>
            <!-- Druid数据库连接池 -->
            <dependency>
                <groupId>com.alibaba</groupId>
                <artifactId>druid-spring-boot-starter</artifactId>
                <version>${druid-spring-boot.version}</version>
            </dependency>
            <!-- MySQL的依赖项 -->
            <dependency>
                <groupId>mysql</groupId>
                <artifactId>mysql-connector-java</artifactId>
                <version>${mysql.version}</version>
            </dependency>
            <!-- MyBatis整合Spring Boot的依赖项 -->
            <dependency>
                <groupId>org.mybatis.spring.boot</groupId>
                <artifactId>mybatis-spring-boot-starter</artifactId>
                <version>${mybatis-spring-boot-starter.version}</version>
            </dependency>
            <!-- Spring Boot支持Spring MVC的WEB开发依赖项 -->
            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-starter-web</artifactId>
                <version>${spring-boot.version}</version>
            </dependency>
            <!-- Spring Boot支持Spring Validation用于检查方法参数的基本有效性的依赖项 -->
            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-starter-validation</artifactId>
                <version>${spring-boot.version}</version>
            </dependency>
            <!-- Spring Boot支持Spring Security的依赖项，主要解决认证与授权的问题 -->
            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-starter-security</artifactId>
                <version>${spring-boot.version}</version>
            </dependency>
            <!-- Spring Boot支持Spring AOP的依赖项，主要解决横切关注问题 -->
            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-starter-aop</artifactId>
                <version>${spring-boot.version}</version>
            </dependency>
            <!-- Spring Boot支持Redis编程的依赖项 -->
            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-starter-data-redis</artifactId>
                <version>${spring-boot.version}</version>
            </dependency>
            <!-- Spring Boot测试的依赖项 -->
            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-starter-test</artifactId>
                <version>${spring-boot.version}</version>
            </dependency>
        </dependencies>
    </dependencyManagement>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>

</project>
```

子类1

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>cn.etg</groupId>
        <artifactId>ploymerproject2039</artifactId>
        <version>0.0.1-SNAPSHOT</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>
    <groupId>cn.etg</groupId>
    <artifactId>passport</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>passport</name>
    <description>Demo project for Spring Boot</description>
    <properties>
        <java.version>8</java.version>
    </properties>
    <dependencies>
        <dependency>
            <groupId>cn.etg</groupId>
            <artifactId>commons</artifactId>
        </dependency>
        <!-- JJWT（Java JWT） -->
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt</artifactId>
        </dependency>
        <!-- fastjson：实现对象与JSON的相互转换 -->
        <dependency>
            <groupId>com.alibaba</groupId>
            <artifactId>fastjson</artifactId>
        </dependency>
        <!-- Knife4j Spring Boot：在线API文档 -->
        <dependency>
            <groupId>com.github.xiaoymin</groupId>
            <artifactId>knife4j-spring-boot-starter</artifactId>
        </dependency>
        <!-- Spring Boot支持Spring MVC的WEB开发依赖项 -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <!-- Spring Boot支持Spring Validation用于检查方法参数的基本有效性的依赖项 -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>
        <!-- Spring Boot支持Spring Security的依赖项，主要解决认证与授权的问题 -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
        </dependency>
        <!-- Mybatis Plus整合Spring Boot的依赖项 -->
        <dependency>
            <groupId>com.baomidou</groupId>
            <artifactId>mybatis-plus-boot-starter</artifactId>
        </dependency>
        <!-- Lombok的依赖项，主要用于简化POJO类的编写 -->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
        </dependency>
        <!-- Druid数据库连接池 -->
        <dependency>
            <groupId>com.alibaba</groupId>
            <artifactId>druid-spring-boot-starter</artifactId>
        </dependency>
        <!-- MySQL的依赖项 -->
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
        </dependency>
        <!-- MyBatis整合Spring Boot的依赖项 -->
        <dependency>
            <groupId>org.mybatis.spring.boot</groupId>
            <artifactId>mybatis-spring-boot-starter</artifactId>
        </dependency>

        <!-- Spring Boot测试的依赖项 -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>

</project>
```

子类2:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>cn.etg</groupId>
        <artifactId>ploymerproject2039</artifactId>
        <version>0.0.1-SNAPSHOT</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>
    <groupId>cn.etg</groupId>
    <artifactId>commons</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>commons</name>
    <description>Demo project for Spring Boot</description>
    <properties>
        <java.version>8</java.version>
    </properties>
    <dependencies>
        <!-- Spring Boot测试的依赖项 -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
        </dependency>
        <!-- Lombok的依赖项，主要用于简化POJO类的编写 -->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <scope>provided</scope>
        </dependency>
        <!-- Knife4j Spring Boot：在线API文档 -->
        <dependency>
            <groupId>com.github.xiaoymin</groupId>
            <artifactId>knife4j-spring-boot-starter</artifactId>
            <scope>provided</scope>
        </dependency>
        <!-- 基于MyBatis或MyBatis Plus的分页查询框架 -->
        <dependency>
            <groupId>com.github.pagehelper</groupId>
            <artifactId>pagehelper-spring-boot-starter</artifactId>
            <scope>provided</scope>
        </dependency>
        <!-- Spring Boot支持Spring Validation用于检查方法参数的基本有效性的依赖项 -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
            <scope>provided</scope>
        </dependency>
        <!-- Spring Boot支持Spring Security的依赖项，主要解决认证与授权的问题 -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
            <scope>provided</scope>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>
</project>
```

alter table 数据库表名 convert to character set 'utf8';

切面编程

```java
package com.itheima.processor;

import com.itheima.advice.MyAdvice;
import org.springframework.beans.BeansException;
import org.springframework.beans.factory.config.BeanPostProcessor;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;


/**
 * @Author ShaoKangDong
 * @ClassName MockAopBeanPostProcessor
 * @Date 2023-12-09-0:09
 * @PackageName com.itheima
 * @Description
 */
public class MockAopBeanPostProcessor implements BeanPostProcessor, ApplicationContextAware {

    private ApplicationContext applicationContext;

    public Object postProcessAfterInitialization(final Object bean, String beanName) throws BeansException {

        //目的:对UserServiceImpl的show1和show2方法进行增强  增强方法在myAdvice中
        //问题1:筛选UserServiceImpl   或  Service.impl类下的所有方法都可以增强  if-else
        //问题2:MyAdvice如何获取   解决方案  :从spring容器中获取MyAdvice
        if(bean.getClass().getPackage().getName().equals("com.itheima.service.impl")){
            //生成当前bean的proxy对象
            Object beanProxy = Proxy.newProxyInstance(
                    bean.getClass().getClassLoader(),
                    bean.getClass().getInterfaces(),
                    new InvocationHandler() {
                        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                            MyAdvice myAdvice = applicationContext.getBean(MyAdvice.class);
                            myAdvice.beforeAdvice();
                            Object result = method.invoke(bean, args);
                            myAdvice.AfterAdvice();
                            return result;
                        }
                    }

            );
            return beanProxy;
        }

        return bean;
    }

    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
            this.applicationContext=applicationContext;
    }
}
```

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="
       http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/aop
       http://www.springframework.org/schema/aop/spring-aop.xsd">
    <bean id="userService" class="com.itheima.service.impl.UserServiceImpl"></bean>
    <bean id="myAdvice"  class="com.itheima.advice.MyAdvice"></bean>
    <bean class="com.itheima.processor.MockAopBeanPostProcessor"></bean>
    <bean class="com.itheima.dao.impl.UserDaoImpl"></bean>
    <bean class="com.itheima.service.impl.BookServiceImpl" id="book"></bean>
    <aop:config >
        <!--切点表达式:指定哪些方法被增强-->
        <aop:pointcut id="myPointcut" expression="execution(void com.itheima.service.impl.BookServiceImpl.look())"/>
        service包下任意子包的look的任意参数的额方法
        <aop:pointcut id="myPointcut2" expression="execution(void com.itheima.service..BookServiceImpl.look(..))"/>

        <!--织入-->
        <aop:aspect ref="myAdvice">
            <aop:before method="beforeAdvice" pointcut-ref="myPointcut"/>
            <aop:before method="beforeAdvice" pointcut="execution(void com.itheima.service.impl.BookServiceImpl.look())"/>

        </aop:aspect>
    </aop:config>
</beans>
```

```xml
aop

<dependency>
    <groupId>org.aspectj</groupId>
    <artifactId>aspectjweaver</artifactId>
    <version>1.9.8</version>
</dependency>
```





![C:\Users\dsk\AppData\Roaming\Typora\typora-user-images\image-20231209055423985.png](C:\Users\dsk\AppData\Roaming\Typora\typora-user-images\image-20231209055423985.png)





![image-20231209091450343](C:\Users\dsk\AppData\Roaming\Typora\typora-user-images\image-20231209091450343.png)





![image-20231209092746056](C:\Users\dsk\AppData\Roaming\Typora\typora-user-images\image-20231209092746056.png)





![image-20231209093204207](C:\Users\dsk\AppData\Roaming\Typora\typora-user-images\image-20231209093204207.png)

# 连接:

1.笛卡尔连接

2.等值连接

3.不等值连接

4.自连接

5.外连接

# sql

```sql

select ename,to_char(hiredate,'fmMM"月"'),
case 
	when to_char(hiredate,'MM')  between 1 and 3 then "第一季度"
	when to_char(hiredate,'MM')  between 1 and 3 then "第二季度"
	when to_char(hiredate,'MM')  between 1 and 3 then "第三季度"
	when to_char(hiredate,'MM')  between 1 and 3 then "第四季度"
	else "空季度"
	end
from emp;


select ename,trunc(months_between(SYSTEM,hiredate))  worked_month
from emp;

select *
from emp
where (sysdate-hiredate)/365>=40;

select round(sysdate-hiredate)
from emp;

select lower(ename) "last_name" ,to_char(hiredate,"fmYYYY-MM-DD") "hire_date" ,to_char(hiredate,"DAY","HH:MI:SS")
from emp;


select (sal+nvl(comm,0))*12,ename,sal
from emp
where to_char(hiredate,"DD") <15;

select substr(ename,2,1)
from emp;

select trunc(sal/30) t ,ename
from emp
order by t desc;

select to_char(sysdate,"fmYYYY-MM-DD HH12:MI:SS AM DAY")
from dual;


select ename,to_char(hiredate,'YYYY"年"MM"月"DD"日"')
from emp
where hiredate<=last_day(sysdate)


select  e.job ,d.loc
from emp e,dept d
where e.depthno=d.deptno and e.dept=30

select e.ename,e.job,d.deptno.d.dname
from emp e, dept d
where e.depthno=d.depthno and d.loc=upper('Toronto') ;

 select INITCAP(e.ename),e.empno,lower(m.ename),m.empno
 from emp e ,dept d
 where e.mgr=m.empno;


 select  e.depthno,lower(e.ename),lower(c.ename)
 from emp e ,emp c
 where e.depthno=c.deptno and e.empno!=c.empno;
 
 
 select 
 
 from emp e,dept d,salgrade s
 where e.depthno=de.depthno and e.sal between s.local and s.hisal and s.grade !=4;
 
 select 
 from emp e,emp m ,salgrade s1,salgrade s2
 where e.



oracle分页  用rownum来实现

select * 
from (select rownum ,emp.* from emp )m 
where m.r between 6 and 10;


TOP-N

	select *
	from  (select  ... order by xx) m
	where rownum<=n
	
	
	
select empno,ename,sal
from emp
where sal >(select avg(sal) from emp);


select *
from



DQL数据库查询语句  select
DML数据库操作语言  增加 修改 删除  事务处理


create table emp2
as 
select * from emp where deptno=20;


drop
 --ddl  删除表所有数据  回收表空间  表结构就没有了,不能回滚
delete from 
--dml    只删除表数据  表的空间,表结构,都保留,可以回滚

commit 
rollback
savepoint 
rollback to

truncate  table 
--ddl  清空截断表 不能回滚   删除数据,回收空间,只保留表结构


约束
索引
序列
视图
sql1999

left outer join
(+)
将不满足等值连接条件的数据也显示出来
左外连接   (+)右侧
右外连接	(-) 左侧

2.
事务的四大特性 ACID 
原子性  一致性  隔离性  持久性
3.组函数
sum() avg()  min max count 
4 create table student(
	sno number(8) primary key,
    sname varchar2(20)
)
5 
insert into student values(1,'zz');
update student set sname='xz' where sno=1;
7
delete   dml 删除数据 可以回滚
drop 	ddl 	删除全部数据 结构空间回收 不能回滚
truncate ddl 截断表 删除表数据回收表空间,结构还在,不能回滚

8.实体之间的关系 1:1 1:n n:m

9范式
1nf  字段不可分割
2nf  满足1nf  ,非主属性依赖主属性
3nf  满足2nf 属性之间不能存在传递依赖

10. 各个部门的平均薪资
select m.*
	from(
    select d.dname,d.loc,avg(e.sal) a
        from emp e ,dept d
        where e.depthno = d.deptno
        group by d.dname,d.loc) m,salgrade s
     where m.a between s.losal and hisal and s.grade=2;


sql1999

笛卡尔集

select *
from table1 cross join table2

--等值连接
select *
from emp join dept
using(deptno); 
--等值连接和不等值连接
select *
from emp join dept
on(emp.deptno=dept.deptno);

select *
from table1 left outer join table2
using(deptno);

select  d.deptno,count(*)
from emp e right join dept d
on(e.deptno=d.deptno)
group by d.depthno

约束是ddl




```

构造私有则不能被继承

和final差不了多少了



### 约束是ddl

```sql
1.非空约束 not null
2.唯一约束 unique
3.主键约束  primary key
4.外键约束 foreign key
5.检查约束 check   列是否符合域

情况

5.2 约束创建的时机
1.建表的时候  主键  [推荐]
2.建表之后补加约束   

约束的语法:

约束名:
1.自己定义
constraint  约束名   表名_列名_xk    emp_empno_pk   emp_ename_nn  _ck  _uk
2.系统定义

语法规则:取决于定义的位置

create table 表名(
	列  数据类型(大小)  列级约束,
    ...
	列  数据类型(大小)  列级约束,
    
    表级约束(列)...
);
非空约束只能写表级的
外键表级的
单主键都可以
联合主键必须用表级的

列级约束
create student(
	
    sno number(8) constraint stu_sno_pk primary key ,
    
)
表级约束
create student(	
    sno number(8)  ,
    sname varchar2(20),
    constraint stu_sno_pk primary key(sno)
)

非空约束:
约束在某个列上面,改列数据不能为空 not null 只能是列级

create table course(
	cno number(4) not null,
    cname varchar2(20) not null

);
insert into course  values(1,null) 报错

唯一约束
unique
唯一约束,限制在某列,该列不允许重复
表级,列级均可
drop table course;
create table course(
	cno number(4) not null,
    cname varchar(20) constraint cour_cname_uk unique
)
主键约束
主码约束,为表添加某个能够唯一确定表字段
1.任何表都必须有主键,且只有一个主键
2.主键不一定是一个列,很多时,多个列构成主键[联合主键]
3.主键 : 非空+唯一
4.列级或表级

create table course(
	cno number(4) not null constraint cour_cno_pk primary key,
    cname varchar(20) constraint cour_cname_uk unique
);

create table course(
	cno number(4) not null,
    cname varchar(20) constraint cour_cname_uk unique,
    constraint cour_cno_pk primary key(cno)
);

 选课表
 cno sno xdate
 create table sc(
 	
     sno number(4),
     cno number(8),
     xdate date,
     --联合主键
     constraint sc_scno_pk primary key(sno,cno)
 )
 
 5.7外键约束foreign key
 当A表的某个字段参考表表的主键,该A表的列称之为外键
 员工表的部门编号就是外键
 来源于两张表,外键来源于其他表,外键加在某列,限制该列的数据必须参考其他列
 
外键可以有多个,习惯上定义表级别

constraint sc_sno_fk  foreign key(外键列)  references 主表(主键字段)
 create table sc(
 	
     sno number(4),
     cno number(8),
     xdate date,
     --联合主键
     constraint sc_scno_pk primary key(sno,cno)
     constraint sc_sno_fk foreign key(sno) references student(sno),
     constraint s_cno_fk foreign key(cno) references course(cno)
 )
加数据安全 删除数据也是安全的
 delete from student 

级联删除  级联修改


 constraint sc_sno_fk foreign key(外键列) references 主表(主键字段) on delete cascade
 
 
 检查约束:
 限制该列字段的取值范围:
 限制该列的取值范围:[阈值] 表级 和 列级 2  b
 
 
 create table student(
 	sno number(4) primary key,
     sname varchar(20) not null,
     gender varchar(10) check(gender in ('男','女')),
     rdate date,
     score number(4,1),
     constraint stu_score_ck check(score between 1 and 100)
 )
 
 总结:完整性
 域完整性   非空约束 检查约束
 实体完整性  唯一约束  主键约束
 参照完整性  外键约束
 
 
 create  [or replace]  View 视图名  
 as subqurey
  授权
  grant create xx(view ,index,sequence) to  用户;
  收回权限
  revoke create xx from 用户
  
  
  对视图的一切操作,都是在操作原表数据
  
  insert into sal01
  values(111,'aa',8888,20); 
  
  
  
  create sequence sequence
  	 --起始位置
  	 start with n
  	 --增值
  	 increment by n
  	 --最值
  	 maxvalue n/nomaxcalue
  	 --是否循环
  	 cycle/nocycle
  	 --缓存吧
  	 cache /nocahe
  	 
  	 create sequence seq2
  	 start with 50
  	 increment by 10
  	 maxvalue 100
  	 
  	 seq2.nextval  seq.currval
  	 
  	 create index 索引名字
  	 on 表(列 )
  	 
  	 





startup.cmd -m standalone
```

# git

```apl
git init 
ssh -T git@gitee.com
git log
git status
git commit -m "my firt git"
git add 文件名
git add .
ssh-keygen -t rsa -C "376643168@qq.com"
ssh-keygen -t ed25519 -C "376643168@qq.com"
git config --global user.name "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"
git config --global user.name "dsk"
git config --global user.email "376643168@qq.com"
git remote add origin git@gitee.com:dong-shaokang/h2.git
inetcpl.cpl
secpol.msc
git pull --rebase origin master
git push -u orgin master
git remote -v
git remote add shortname 别名  远程地址
git clone 远程地址
git pull 远程仓库名 分支
推送到远程仓库 git push 远程仓库别名 分支
git branch  查看本地所有分支
git branch -r 查看远程所有分支
git branch -a  查看本地和远程所有分支
git branch [name] 创建分支
git checkout [name] 切换分支
git push [shortname][name] 推送至远程仓库分支
git merge [name] 合并分支
git reser --hard id  回到已经的版本
 ssh--keygen -t rsa -C “你的邮箱地址” 	生成密钥
 git remote add origin  “你的SSH” 
 git remote -v 命令验证是否关联成功。
 git push -u origin master 
 git push -f origin master 这里就强行本地覆盖远程了，远程里多的东西也就被删除了。
 git pull --rebase origin master，这个命令是将远程库的文件拉取到本地合并，这也是我们平时需要保存远程库到本地的方法
 git push -u origin master
 创建名为[username].github.io的仓库
git clone https://github.com/dskismvp/dskismvp.github.io.git
cd dskismvp.github.io
git config --global --get http.proxy
git config --global --get https.proxy
 git config --global --unset http.proxy
  git config --global --unset https.proxy
```

# preparedStatement

```
statement 和preparedStatement区别


1.提高sql语句的效率
2.java和sql分离,解耦
3.防止sql注入,避免java的参数拼接入sql
statement不能设置类型 preparedstatement可以设置类型
```

```yaml
云端配置
spring:
  application:
    name: service-goods

  profiles:
    active: dev

  cloud:
    nacos:
      discovery:
        server-addr: http://localhost:8848
      config:
        server-addr: http://localhost:8848
        prefix: application
        file-extension: yaml
        group: DEFAULT_GROUP
        namespace: public
        
        
        
   startup.cmd -m standalone;
```







# dubbo配置   消费者

```yaml
server:
  port: 7020

spring:
  application:
    name: dubbo-consumer

dubbo:
  registry:
    address: nacos://localhost:8848

  application:
    name: dubbo-consumer

  consumer:
    timeout: 30000
```

doubbo 提供者



```yaml
server:
  port: 7010

spring:
  application:
    name: dubbo-provider

dubbo:
  registry:
    address: nacos://localhost:8848
  application:
    name: dubbo-provider
  protocol:
    name: dubbo
    port: 20880
  scan:
    base-packages: cn.etg.dubboprovider.service.impl
  provider:
    timeout: 30000
```



# mysql枚举

```
首先看下面这段代码：

mysql> create table ss
    -> (
    ->  no int check(no <= 4 and no >=
    -> );
Query OK, 0 rows affected (0.11 sec)
 
mysql> insert into ss values(1);
Query OK, 1 row affected (0.01 sec)
 
mysql> select * from ss;
+------+
| no   |
+------+
|    1 |
+------+
1 row in set (0.00 sec)
 
mysql> insert into ss values(5);
Query OK, 1 row affected (0.03 sec)
 
mysql> select * from ss;
+------+
| no   |
+------+
|    1 |
|    5 |
+------+
2 rows in set (0.00 sec)

很明显，CHECK语句在声明中并未起到作用，为什么呢？

原因是因为，不同于SQL，在MYSQL中，CHECK只是一段可调用但无意义的子句。MySQL会直接忽略。

CHECK子句会被分析，但是会被忽略。
请参见“CREATE TABLE语法”：接受这些子句但又忽略子句的原因是为了提高兼容性，以便更容易地从其它SQL服务器中导入代码，并运行应用程序，创建带参考数据的表。

解决这个问题有两种办法：
1.
如果需要设置CHECK约束的字段范围小，并且比较容易列举全部的值，就可以考虑将该字段的类型设置为枚举类型 enum()或集合类型set()。比如性别字段可以这样设置，插入枚举值以外值的操作将不被允许。

 1 mysql> create table checkDemoTable(a enum('男','女'),b int,id int,primary key(id));
 2 Query OK, 0 rows affected
 3 
 4 mysql> insert into checkDemoTable values('男',1,1);
 5 Query OK, 1 row affected
 6 
 7 mysql> select * from checkDemoTable;
 8 +----+---+----+
 9 | a  | b | id |
10 +----+---+----+
11 | 男 | 1 |  1 |
12 +----+---+----+
13 1 row in set
如果需要设置CHECK约束的字段范围大，且列举全部值比较困难，比如：>0的值，那就只能使用触发器来代替约束实现数据的有效性了。如下代码，可以保证a>0。

CREATE TRIGGER TestField1_BeforeInsert BEFORE INSERT ON checkDemoTable
FOR EACH ROW
BEGIN
IF NEW.a < 0 THEN
SET NEW.a = 0;
END IF;
此外，在MYSQL中，域(Domain)与断言(Assertion)也是无法使用的，原因类似于CHECK，后续将会在其他文章中提到。更多相关代码可以访问

```

# 树状nav

```java
 private  List<NavMenu> list;
    public List<NavTreeVo> listTurn(){
        list= list();
        List<NavTreeVo> child = findChild(0);
        return child;
    }


    private NavTreeVo turnTo(NavMenu navMenu,List<NavTreeVo> child){
        NavTreeVo navTreeVo = new NavTreeVo();
       return navTreeVo.setLabel(navMenu.getName()).setChild(child);
    }

    private List<NavTreeVo> findChild(Integer id){
        List<NavTreeVo> navTreeVos1=new ArrayList<>();

        for (NavMenu navMenu : list) {
            List<NavTreeVo> child=null;
            if(navMenu.getParentId()==id){
                if(navMenu.getIsParent()==1){
                    child = findChild(navMenu.getId());
                }
                navTreeVos1.add(turnTo(navMenu,child)) ;
            }
        }
        return navTreeVos1;
    }
```

```yaml
server:
  port: 7010

spring:
  application:
    name: dubbo-provider

dubbo:
  registry:
    address: nacos://localhost:8848
  application:
    name: dubbo-provider
  protocol:
    name: dubbo
    port: 20880
  scan:
    base-packages: cn.etg.dubboprovider.service.impl
  provider:
    timeout: 30000
```



云端配置

# provider:用于被nacos发现的注解

```java
@EnableDiscoveryClient
```

application.yaml

```yaml
server:
  port: 7001
```

bootstrap.yaml

```yaml
spring:
  application:
    name: service-goods

  profiles:
    active: dev

  cloud:
    nacos:
      discovery:
        server-addr: http://localhost:8848
      config:
        server-addr: http://localhost:8848
        prefix: application
        file-extension: yaml
        group: DEFAULT_GROUP
        namespace: public
```

```java
//获取云端配置信息返回给消费者
@RestController
public class ReadConfigController {
    @Value("${myinfo}")
    private String myinfo;

    @RequestMapping("/myinfo")
    public String myinfo(){
        return myinfo;
    }

}
```



# 解决使用代理时 Win11 UWP 应用无法联网问题

[![img](https://cdn2.jianshu.io/assets/default_avatar/4-3397163ecdb3855a0a4139c34a695885.jpg)](https://www.jianshu.com/u/62128bacb2ba)

[阿修哥](https://www.jianshu.com/u/62128bacb2ba)关注IP属地: 四川

2022.04.15 02:47:48字数 76阅读 1,057

以管理员权限启动 powershell 敲下面命令即可：

foreach ($n in (get-appxpackage).packagefamilyname) {checknetisolation loopbackexempt -a -n="$n"}

如果只想对某个特定 UWP 应用设置代理，用 $n=(get-appxpackage *应用名的独特部分，比如邮件应用是commu*).packagefamilyname | checknetisolation loopbackexempt -a -n="$n"



第 1 步：同时按下Win + R键以启动“运行”对话框。

# 当它打开时，输入inetcpl.cpl并按Enter键启动Internet Properties。

第 2 步：首先单击“连接”选项卡。

接下来，单击名为LAN settings的按钮。

# restTmplate消费者端的启动类配置

```java
@SpringBootApplication
@EnableDiscoveryClient
public class ConsumerApplication {

    public static void main(String[] args) {
        SpringApplication.run(ConsumerApplication.class, args);
    }

    @Bean
    @LoadBalanced
    public RestTemplate restTemplate(){

        return new RestTemplate();
    }

}
```

```java

public class OrderController {

    @Value("${server.port}")
    private Integer port;

    @Autowired
    private RestTemplate restTemplate;
    //http://localhost:7001/goods/findByGid?gid=1000
    //http://localhost:7002/order/findByOid?oid=zzz
    @RequestMapping("/order/findByOid")
    public String findByOid(@RequestParam("oid") String oid){
        String url="http://service-goods/goods/findByGid?gid=1000";
        String goods=restTemplate.getForObject(url,String.class);


        return  "server port "+port+",findByOid:"+oid+",goods:"+goods;
    }


}
```

消费者配置文件

```yaml
server:
  port: 7002

spring:
  application:
    name: server-order

  cloud:
    nacos:
      discovery:
        server-addr: http://localhost:8848
```











restTemplate  和 openFeign  和  Dubbo的相同

```java
restTemplate  http协议  getForObject(url,返回值类型.class)
    提供者提供controller  url为:协议://ip:端口/uri (url: http://服务名/uri)

openFeign 
    消费者中创建Controller接口加上@FeignClient("提供者服务名")  在消费者中注入即可
    
@FeignClient("feign-provider")
public interface ProviderControllerInter {
    @RequestMapping("/provider")
    String getInfo();
}
@RestController
public class FeignConsumerController {

    @Autowired
    private ProviderControllerInter providerControllerInter;
    //http://localhost:8111/consumer
    @RequestMapping("/consumer")
    public String getConsumer(){

        return providerControllerInter.getInfo();
    }

}

服务提供者
    public class ProviderApplication {

    public static void main(String[] args) {
        SpringApplication.run(ProviderApplication.class, args);
    }

    @Bean
    @LoadBalanced
    public RestTemplate aa(){
        return new RestTemplate();
    }
}

    


```

dubbo



1.公共接口

2.服务提供者实现

```java
@Service
@DubboService
public class InfoServiceImpl implements InfoService {
    @Override
    public String getInfo() {

        return "这是dubbo-provider模块";
    }
}
```

服务提供者dubbo配置

```yaml
server:
  port: 7010

spring:
  application:
    name: dubbo-provider

dubbo:
  registry:
    address: nacos://localhost:8848
  application:
    name: dubbo-provider
  protocol:
    name: dubbo
    port: 20880
  scan:
    base-packages: cn.etg.dubboprovider.service.impl
  provider:
    timeout: 30000
```



服务提供者配置类

```java
@EnableDubbo
@EnableDiscoveryClient
@SpringBootApplication
public class DubboProviderApplication {

    public static void main(String[] args) {
        SpringApplication.run(DubboProviderApplication.class, args);
    }


}
```



消费者

```yaml
server:
  port: 7020

spring:
  application:
    name: dubbo-consumer

dubbo:
  registry:
    address: nacos://localhost:8848

  application:
    name: dubbo-consumer

  consumer:
    timeout: 30000
```



```java
@RestController
public class InfoController {

    @DubboReference(check = false)
    private InfoService infoService;
    @RequestMapping("/info")
    public String getInfo(){
        return infoService.getInfo();
    }

}
```



restTemplateDemo

provider





consumer

